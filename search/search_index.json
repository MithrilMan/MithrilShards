{"config": {"lang": ["en"], "min_search_length": 3, "prebuild_index": false, "separator": "[\\s\\-]+"}, "docs": [{"location": "", "text": "Goal Mithril Shards goal is to implement a .NET 5 extensible P2P network & distributed services library from scratch with focus on architecture and performance. Allows you to define custom network serialization protocol, easily handle payload messages and interact with the software leveraging any available features (named Shards) like WEB Api endpoints, Blazor UI , and a lot of other exciting stuffs that community can implements and release to the public too! The project is very ambitious and it's currently developed just by me as a pet project but a huge effort has gone into already and some part of this unique code base has been already reused in other blockchain technologies to improve their performance. How things started I have DLT experience in the past years and one of my previous experience has been working for a blockchain tech firm that had a FN implementation in C#. I really love C# and .Net core has improved a lot performance too. Workin on their codebase I saw lot of things that could have been improved, both in design and in performance. Their implementation started as a kind of 1-1 porting of bitcoin core source with all the cons that it brings. So I thought about diving into this titanic effort of creating a full node in C# starting from scratch, mainly to go as deeper as possible into technical details, trying to focus both on a proper architecture design and performance improvements. One of the first thing I implemented was of course the basic handshake process between two nodes, to achieve that My I started by following bitcoin core source because unluckily that's the only part that contains kind of specifications, it's hard to find a detailed updated technical documentations (even this protocol documentation page contains wrong informations, even if it's still useful). I started using .Net TCP classes, using an internal state machine to handle peer connection statuses, then I found Bedrock Framework , that allowed me to abstract better my code and rely on it for the low level connection stuff (at the time of writing this documentation, that library is still in alpha and my concern about that project activity has been appeased ). As soon as I started defining properly my design, I found it interesting to abstract most of the stuff into an agnostic library that allows me to create a P2P application in a modular way and attach additional features when needed, and this is how Mithril Shards started. Since then I added more and more stuff, both for generic Mithril Shards project and for specific Bitcoin needs. The Example Shard (that composed by multiple projects) showcase how you can create a custom P2P software leveraging networking, custom messages, WEB Api endpoints Diagnostic tools, everything with a proper logging system. Current Tech A random list of available tech used within Mithril Shards. .Net 5 - ... for everything. Bedrock Framework - TCP/IP default connectivity implementation. Swashbuckle - to handle Web API (multiple) documents and have a playground to test APIs with swagger. Serilog - default logging implementation. BenchmarkDotNet - a benchmark framework, very handy to benchmark different approach during implementation phases. Why the Mithril Shards name? Well... let's bullet some facts I like fantasy a lot, J.R.R. Tolkien of course has been one of my reads and mithril is a fictional metal in his universe. The main properties of mithri are: being very strong, light and in its pure form very malleable to work with. I'm a developer that like to curate its software to be extensible and solid. My github handle is MithrilMan, guess what? Now take these informations, mix them up, and you'll see that to I aim to have a robust, fast and flexible project! So this explain mithril, while about Shards , is because I see this project as a mix of shards that can be assembled togheter to give you a precious artifact! In fact you shouldn't be surprised that the root class is called Forge... who says we can't have a bit of fun while designing a software? Call to Action! Join to give feedback, ask for features, support, etc... Discord server: https://discord.gg/T9kyKz4bAu CI Current status", "title": "Welcome!"}, {"location": "#goal", "text": "Mithril Shards goal is to implement a .NET 5 extensible P2P network & distributed services library from scratch with focus on architecture and performance. Allows you to define custom network serialization protocol, easily handle payload messages and interact with the software leveraging any available features (named Shards) like WEB Api endpoints, Blazor UI , and a lot of other exciting stuffs that community can implements and release to the public too! The project is very ambitious and it's currently developed just by me as a pet project but a huge effort has gone into already and some part of this unique code base has been already reused in other blockchain technologies to improve their performance.", "title": "Goal"}, {"location": "#how-things-started", "text": "I have DLT experience in the past years and one of my previous experience has been working for a blockchain tech firm that had a FN implementation in C#. I really love C# and .Net core has improved a lot performance too. Workin on their codebase I saw lot of things that could have been improved, both in design and in performance. Their implementation started as a kind of 1-1 porting of bitcoin core source with all the cons that it brings. So I thought about diving into this titanic effort of creating a full node in C# starting from scratch, mainly to go as deeper as possible into technical details, trying to focus both on a proper architecture design and performance improvements. One of the first thing I implemented was of course the basic handshake process between two nodes, to achieve that My I started by following bitcoin core source because unluckily that's the only part that contains kind of specifications, it's hard to find a detailed updated technical documentations (even this protocol documentation page contains wrong informations, even if it's still useful). I started using .Net TCP classes, using an internal state machine to handle peer connection statuses, then I found Bedrock Framework , that allowed me to abstract better my code and rely on it for the low level connection stuff (at the time of writing this documentation, that library is still in alpha and my concern about that project activity has been appeased ). As soon as I started defining properly my design, I found it interesting to abstract most of the stuff into an agnostic library that allows me to create a P2P application in a modular way and attach additional features when needed, and this is how Mithril Shards started. Since then I added more and more stuff, both for generic Mithril Shards project and for specific Bitcoin needs. The Example Shard (that composed by multiple projects) showcase how you can create a custom P2P software leveraging networking, custom messages, WEB Api endpoints Diagnostic tools, everything with a proper logging system.", "title": "How things started"}, {"location": "#current-tech", "text": "A random list of available tech used within Mithril Shards. .Net 5 - ... for everything. Bedrock Framework - TCP/IP default connectivity implementation. Swashbuckle - to handle Web API (multiple) documents and have a playground to test APIs with swagger. Serilog - default logging implementation. BenchmarkDotNet - a benchmark framework, very handy to benchmark different approach during implementation phases.", "title": "Current Tech"}, {"location": "#why-the-mithril-shards-name", "text": "Well... let's bullet some facts I like fantasy a lot, J.R.R. Tolkien of course has been one of my reads and mithril is a fictional metal in his universe. The main properties of mithri are: being very strong, light and in its pure form very malleable to work with. I'm a developer that like to curate its software to be extensible and solid. My github handle is MithrilMan, guess what? Now take these informations, mix them up, and you'll see that to I aim to have a robust, fast and flexible project! So this explain mithril, while about Shards , is because I see this project as a mix of shards that can be assembled togheter to give you a precious artifact! In fact you shouldn't be surprised that the root class is called Forge... who says we can't have a bit of fun while designing a software?", "title": "Why the Mithril Shards name?"}, {"location": "#call-to-action", "text": "Join to give feedback, ask for features, support, etc... Discord server: https://discord.gg/T9kyKz4bAu", "title": "Call to Action!"}, {"location": "#ci", "text": "Current status", "title": "CI"}, {"location": "mithril-shards/", "text": "Architecture Overview Mithril Shards is a modular framework for building P2P Applications that can be expanded by additional features like WEB Api endpoints, MQ based services, SignalR hubs, cross platform UI and much more. Pretending to be into a Tolkien universe, I thought of defining features as shards , where each shard of mithril can be put into a forge and fused togheter with other mithril shards, to create a final artifact. To find analogies with .net naming conventions: Forge (to be more precise, ForgeBuilder ) is a HostBuilder on steroids (actually it encapsulate a HostBuilder instance). Shard is an application part that gets merged into the hostbuilder, using dependency injection, extending its functionality Artifact is just an allegoric view of the result of forgeBuilderInstance.RunConsoleAsync() . Note Current naming may be subject to changes. To build an application using these concepts, we have to create a ForgeBuilder, specify which Forge type to use and then we can put into the forge all the shards we need by calling AddShard method. Since a shard may require complex configurations and inject service implementations it may need, usually you don't want to call that method directly but instead you'd want to have a IForgeBuilder extension that you can put in a class in your shard project, where your initialization logic happens. That's how .Net core features and services are injected into the host builder and I think it's a good thing to use a similar approach because would be more friendly to devs used to .Net conventions. Each shard may be configured by a strong typed setting class that supports eager validation (would throw if the setting files contains invalid data) and each shard is responsible to register services it needs that would cooperate with the IForge implementation to perform needed tasks, more on this in the specific documentation sections. After all shards are added and ForgeBuilder is started by RunConsoleAsync , the forge will take care of all the plumbing stuff, initializing all the shards. For a detailed description of the components composing the Mithril Shards framework, refers to specific documentation pages. The entry point of a Mithril Shards application is the ForgeBuilder class.", "title": "Overview"}, {"location": "mithril-shards/#architecture-overview", "text": "Mithril Shards is a modular framework for building P2P Applications that can be expanded by additional features like WEB Api endpoints, MQ based services, SignalR hubs, cross platform UI and much more. Pretending to be into a Tolkien universe, I thought of defining features as shards , where each shard of mithril can be put into a forge and fused togheter with other mithril shards, to create a final artifact. To find analogies with .net naming conventions: Forge (to be more precise, ForgeBuilder ) is a HostBuilder on steroids (actually it encapsulate a HostBuilder instance). Shard is an application part that gets merged into the hostbuilder, using dependency injection, extending its functionality Artifact is just an allegoric view of the result of forgeBuilderInstance.RunConsoleAsync() . Note Current naming may be subject to changes. To build an application using these concepts, we have to create a ForgeBuilder, specify which Forge type to use and then we can put into the forge all the shards we need by calling AddShard method. Since a shard may require complex configurations and inject service implementations it may need, usually you don't want to call that method directly but instead you'd want to have a IForgeBuilder extension that you can put in a class in your shard project, where your initialization logic happens. That's how .Net core features and services are injected into the host builder and I think it's a good thing to use a similar approach because would be more friendly to devs used to .Net conventions. Each shard may be configured by a strong typed setting class that supports eager validation (would throw if the setting files contains invalid data) and each shard is responsible to register services it needs that would cooperate with the IForge implementation to perform needed tasks, more on this in the specific documentation sections. After all shards are added and ForgeBuilder is started by RunConsoleAsync , the forge will take care of all the plumbing stuff, initializing all the shards. For a detailed description of the components composing the Mithril Shards framework, refers to specific documentation pages. The entry point of a Mithril Shards application is the ForgeBuilder class.", "title": "Architecture Overview"}, {"location": "mithril-shards/default-forge/", "text": "The entry point is our forge builder class. After declaring an instance we have to specify which implementation of Forge we want to use. Actually the only available implementation is DefaultForge", "title": "DefaultForge"}, {"location": "mithril-shards/example-project/", "text": "The best way to see it in action is by inspecting the Example project I've created.", "title": "Example Project"}, {"location": "mithril-shards/forge-builder/", "text": "ForgeBuilder class represents the entry point of a Mithril Shards application, it allows to add a shard by calling the generic AddShard method, with different overloads that accept an optional strongly typed shard setting file with an optional setting file validator. By using ConfigureLogging it's possible to configure logging, it's basically a wrapper on the inner hostbiulder ConfigureLogging method, you could use it to have a finer control over logging configuration and available providers, but the easier way to log is by using the available SerilogShard that uses Serilog to configure the logging and relies on a configurable setting file where you can specify which sink to use. You can find more details on its specific documentation page and an example of its usage in the example project After declaring an instance we have to specify which implementation of Forge we want to use. Actually the only available implementation is DefaultForge class.", "title": "ForgeBuilder"}, {"location": "shards/bitcoin/", "text": "Premise This folder contains technical documentation that helps to understand the choices behind the implementation and design of current project. Personally I'm not a fan of bitcoin core code base: even if it improved since early days, it's confusing, it lacks of an homogeneous design and architecture and suffers from old bad choices and above all lacks of proper technical documentation, following the mantra \"source code is the documentation\". To be clear, I don't blame who contributes on bitcoin core, I'm just stating objective facts and I hope to fix some of these issues with my project. I don't pretend to have all the documentation always in sync with latest changes because it's a huge effort and I agree at a large extent that source code is the final judge and I encourage you to dig into it if you want to go deeper in implementation details or verify that an information written here is correct. Please, if you find any issue about documentation, feel free to open an issue and I'll be happy to fix it (even a PR with your corrections can be valuable!). To me a proper documentation doesn't have to explain the source code (source code should be as much readable as possible) but it should give insights about the process that leads toward specific implementations and have indications about good practice to work within the built library. Beside this premise, I'm writing this documentation as if I were the target, in order to have a maintainable and easy to follow repository and of course be able to give good understanding about how to extend this project further with custom features (shards) to people that may be interested. Nevertheless I would be happy to know that it could be useful to someone who may find it interesting and help in understanding why an approach has been chosen over another! Also if you have question or want to discuss about technical details, you can use the repository Discussion section . Project Overview Bitcoin Mithril Shard has been built on top of Mithril Shards framework. Mithril Shards goal is to be a framework and toolkit to build modular and distributed/ P2P applications using .Net 5 stack, focusing both on good design, good practices and performance. Core functionalities can be glued togheter to compose the needed application, ranging from a P2P network layer, WEB Api layer, Diagnostic tools, cross platform UI based on blazor, distributed eventing using SignalR, MQ brokers like RabbitMq or any kind of other useful libraries. Thanks to its design, anyone can build it's own Shard to create other features that can be used by Mithril Shards community. More details about Mithril Shards can be found on the main documentation (TODO). Bitcoin shard is a very good example about how to build a fully functional full node for bitcoin, leveraging all the juicy features that Mithril Shards exposes. Network layer is implemented by leveraging Bedrock Framework for the TCP implementation using both Client and Server connections. Data is serialized thanks to an well defined set of interfaces and classes that allows to implement an easy to read and maintain code. Incoming messages are dispatched to \"Message Processors\" that allow to handle the application logic following a good practice of separation of concerns. Meaningful events are dispatched using a message bus implementation that can reach any component in any application layer. A WEB Api infrastructure allow to create WEB Api endpoint easily and each feature can have its set of API published on different document specifications. Swagger is used as a UI to expose these API documents and allows to execute these APIs straight from that interface. For development/debugging purpose, a Shard inject some useful endpoint to inspect internal details of the running application. Logging is done using structured logging, makes use of Serilog to persist them and a configuration example shows how to use Seq to have a very good UI to view logs, filter them, etc... Blazor is used to implement a cross platform UI as a companion for the full node.", "title": "Overview"}, {"location": "shards/bitcoin/#premise", "text": "This folder contains technical documentation that helps to understand the choices behind the implementation and design of current project. Personally I'm not a fan of bitcoin core code base: even if it improved since early days, it's confusing, it lacks of an homogeneous design and architecture and suffers from old bad choices and above all lacks of proper technical documentation, following the mantra \"source code is the documentation\". To be clear, I don't blame who contributes on bitcoin core, I'm just stating objective facts and I hope to fix some of these issues with my project. I don't pretend to have all the documentation always in sync with latest changes because it's a huge effort and I agree at a large extent that source code is the final judge and I encourage you to dig into it if you want to go deeper in implementation details or verify that an information written here is correct. Please, if you find any issue about documentation, feel free to open an issue and I'll be happy to fix it (even a PR with your corrections can be valuable!). To me a proper documentation doesn't have to explain the source code (source code should be as much readable as possible) but it should give insights about the process that leads toward specific implementations and have indications about good practice to work within the built library. Beside this premise, I'm writing this documentation as if I were the target, in order to have a maintainable and easy to follow repository and of course be able to give good understanding about how to extend this project further with custom features (shards) to people that may be interested. Nevertheless I would be happy to know that it could be useful to someone who may find it interesting and help in understanding why an approach has been chosen over another! Also if you have question or want to discuss about technical details, you can use the repository Discussion section .", "title": "Premise"}, {"location": "shards/bitcoin/#project-overview", "text": "Bitcoin Mithril Shard has been built on top of Mithril Shards framework. Mithril Shards goal is to be a framework and toolkit to build modular and distributed/ P2P applications using .Net 5 stack, focusing both on good design, good practices and performance. Core functionalities can be glued togheter to compose the needed application, ranging from a P2P network layer, WEB Api layer, Diagnostic tools, cross platform UI based on blazor, distributed eventing using SignalR, MQ brokers like RabbitMq or any kind of other useful libraries. Thanks to its design, anyone can build it's own Shard to create other features that can be used by Mithril Shards community. More details about Mithril Shards can be found on the main documentation (TODO). Bitcoin shard is a very good example about how to build a fully functional full node for bitcoin, leveraging all the juicy features that Mithril Shards exposes. Network layer is implemented by leveraging Bedrock Framework for the TCP implementation using both Client and Server connections. Data is serialized thanks to an well defined set of interfaces and classes that allows to implement an easy to read and maintain code. Incoming messages are dispatched to \"Message Processors\" that allow to handle the application logic following a good practice of separation of concerns. Meaningful events are dispatched using a message bus implementation that can reach any component in any application layer. A WEB Api infrastructure allow to create WEB Api endpoint easily and each feature can have its set of API published on different document specifications. Swagger is used as a UI to expose these API documents and allows to execute these APIs straight from that interface. For development/debugging purpose, a Shard inject some useful endpoint to inspect internal details of the running application. Logging is done using structured logging, makes use of Serilog to persist them and a configuration example shows how to use Seq to have a very good UI to view logs, filter them, etc... Blazor is used to implement a cross platform UI as a companion for the full node.", "title": "Project Overview"}, {"location": "shards/bitcoin/network/", "text": "Network Protocol The Bitcoin network protocol is a TCP protocol that serializes messages starting from a special 4 bytes constant data called Magic bytes , followed by 12 bytes representing the command name , 4 bytes representing the payload size and 4 bytes with the checksum of the payload. More specific information about bitcoin protocol can be found here. Mithril Shards implements a low level stack of interfaces and implementations that allow to focus on the application logic instead on low level details. A default implementation uses Bedrock Framework to leverage the low level communication between peers and this is what's used in the Bitcoin shard to provide P2P connectivity. A typical Bitcoin full node (henceforth called FN ) is able to connect to other nodes and accept incoming connections. Before two peers can exchange information, they have to perform an handshake to prove that they can understand each other (more details on the the bitcoin network protocol can be found on this bitcoin developer resource ). Before being able to handshake, whenever a connection has been established between two peers the FN stores some metadata about the remote peer. This data is stored into a class that implements IPeerContext interface and its implementation represents our next section. Peer Context Default Mithril Shards implementation uses PeerContext class to store, among other things, information like peer unique identification, direction (inbound/outbound) remote and local endpoints, user agent identification, negotiated protocol version and other attachable properties leveraging the .Net IFeatureCollection interface. Bitcoin needs some additional information and some of the properties that are ubiquitous needed among all optional Bitcoin features (shards) like wallet, APIs, indexer, etc... have been defined directly into BitcoinPeerContext that extends the default PeerContext . Some of the additional properties are Permissions (that may change the FN behavior based on its set) and TimeOffset, that's an important aspect for the consensus logic. Another important property exposed by peer context is the ConnectionCancellationTokenSource property, that's a CancellationTokenSource that can be used to trigger the disconnection from a peer. It's internally used to know when the connection has been closed, to stop the execution of async methods that rely on an active connection to a remote peer. As per IPeerContext interface, ConnectionCancellationTokenSource can only be read so it's important that custom implementation of IPeerContext don't change it's value out of constructor. This property is actively used within message processors (more about it in a later section). The cancellation of ConnectionCancellationTokenSource shouldn't be canceled directly, to force a peer disconnection an event of type PeerDisconnectionRequired has to be published on the event bus, but for simplicity BitcoinPeerContext implements a Disconnect method that does that. So anytime you have a need to disconnect a peer, just call thePeerContext.Disconnect(\"My Disconnection reason!\") . You can find already usage of it in message processor classes. The peer context creation is handled by the core Mithril Shard network implementation and since it can't know about the BitcoinPeerContext properties, it relies on a peer context factory, in this case we are talking about BitcoinPeerContextFactory class. It leverages the generic class PeerContextFactory<> and its implementation is bare bone, no need to override anything. 1 public class PeerContextFactory < TPeerContext > : IPeerContextFactory where TPeerContext : IPeerContext Accepting a connection Once the peer context has been created, a sanity check is performed to see if the two peers can connect to each other before trying to handshake and the behavior is very similar to both inbound and outbound connections. The only difference is that actually for outgoing connection the check is done before trying to connect but very likely it would be done as per incoming connection soon. What happens when an incoming connection has been accepted is that the connection has to pass all registered (in the DI containers) implementations of IServerPeerConnectionGuard interface. ServerPeerConnectionGuardBase In Bitcoin shard all guard rules are extending ServerPeerConnectionGuardBase implementation that's a simple class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public abstract class ServerPeerConnectionGuardBase : IServerPeerConnectionGuard { protected readonly ILogger logger ; protected readonly ForgeConnectivitySettings settings ; public ServerPeerConnectionGuardBase ( ILogger logger , IOptions < ForgeConnectivitySettings > options ) { this . logger = logger ; settings = options . Value ; } public ServerPeerConnectionGuardResult Check ( IPeerContext peerContext ) { string? denyReason = TryGetDenyReason ( peerContext ); if (! string . IsNullOrEmpty ( denyReason )) { logger . LogDebug ( \"Peer connection guard not passed: {denyReason}\" , denyReason ); return ServerPeerConnectionGuardResult . Deny ( denyReason ); } return ServerPeerConnectionGuardResult . Allow (); } internal abstract string? TryGetDenyReason ( IPeerContext peerContext ); } This class implements the plumbing code required to run (and log in case of rule check not passed) the guard rule, so a guard rule implementation has just to focus on its guarding logic. A simple example is the MaxConnectionThresholdGuard rule that ensure that an incoming transaction doesn't exceed the maximum allowed number of inbound connections: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MaxConnectionThresholdGuard : ServerPeerConnectionGuardBase { readonly IConnectivityPeerStats _peerStats ; public MaxConnectionThresholdGuard ( ILogger < MaxConnectionThresholdGuard > logger , IOptions < ForgeConnectivitySettings > settings , IConnectivityPeerStats serverPeerStats ) : base ( logger , settings ) { _peerStats = serverPeerStats ; } internal override string? TryGetDenyReason ( IPeerContext peerContext ) { if ( _peerStats . ConnectedInboundPeersCount >= settings . MaxInboundConnections ) { return \"Inbound connection refused: max connection threshold reached.\" ; } return null ; } } In order to be used during connection check, these guard classes have to be registered in the DI container. MaxConnectionThresholdGuard for example is registered into the extension that register the bitcoin shard by using 1 services.AddSingleton<IServerPeerConnectionGuard, InitialBlockDownloadStateGuard>() This allow the flexibility of having custom guard rule simply by implementing a rule and register in the DI container, any required service will be injected automatically; of course if it relies on a custom service not already available in my implementation, that service has to be registered too. Info These classes have to be registered as singleton and therefor must be stateless Network protocol is implemented through the serialization of classes which implement INetworkMessage interface and are decorated with NetworkMessageAttribute that works in synergy with an implementation of INetworkMessageSerializer to implement network serialization. Handshake Once a connection has been accepted between two nodes, they start exchanging messages in order to handshake and prove each other they are two compatible nodes that can exchange informations. Info Bitcoin protocol doesn't punish nodes that send unknown messages. I think however that a node has to monitor its connected peer activities and punish them if they send too many unknown messages causing our node to waste resources. Without going too deeper into bitcoin handshake process, the exchanges messages are summarized by this sequence diagram: sequenceDiagram participant L as Local participant R as Remote L-->>+R:Connects to L->>+R:Version R->>L:Version R->>L:Verack L->>R:Verack Info Bitcoin protocol doesn't define a specific order for the Remote node to send its Verack and Version message so Local node has to account that and accept these messages in any order.", "title": "Network implementation"}, {"location": "shards/bitcoin/network/#network-protocol", "text": "The Bitcoin network protocol is a TCP protocol that serializes messages starting from a special 4 bytes constant data called Magic bytes , followed by 12 bytes representing the command name , 4 bytes representing the payload size and 4 bytes with the checksum of the payload. More specific information about bitcoin protocol can be found here. Mithril Shards implements a low level stack of interfaces and implementations that allow to focus on the application logic instead on low level details. A default implementation uses Bedrock Framework to leverage the low level communication between peers and this is what's used in the Bitcoin shard to provide P2P connectivity. A typical Bitcoin full node (henceforth called FN ) is able to connect to other nodes and accept incoming connections. Before two peers can exchange information, they have to perform an handshake to prove that they can understand each other (more details on the the bitcoin network protocol can be found on this bitcoin developer resource ). Before being able to handshake, whenever a connection has been established between two peers the FN stores some metadata about the remote peer. This data is stored into a class that implements IPeerContext interface and its implementation represents our next section.", "title": "Network Protocol"}, {"location": "shards/bitcoin/network/#peer-context", "text": "Default Mithril Shards implementation uses PeerContext class to store, among other things, information like peer unique identification, direction (inbound/outbound) remote and local endpoints, user agent identification, negotiated protocol version and other attachable properties leveraging the .Net IFeatureCollection interface. Bitcoin needs some additional information and some of the properties that are ubiquitous needed among all optional Bitcoin features (shards) like wallet, APIs, indexer, etc... have been defined directly into BitcoinPeerContext that extends the default PeerContext . Some of the additional properties are Permissions (that may change the FN behavior based on its set) and TimeOffset, that's an important aspect for the consensus logic. Another important property exposed by peer context is the ConnectionCancellationTokenSource property, that's a CancellationTokenSource that can be used to trigger the disconnection from a peer. It's internally used to know when the connection has been closed, to stop the execution of async methods that rely on an active connection to a remote peer. As per IPeerContext interface, ConnectionCancellationTokenSource can only be read so it's important that custom implementation of IPeerContext don't change it's value out of constructor. This property is actively used within message processors (more about it in a later section). The cancellation of ConnectionCancellationTokenSource shouldn't be canceled directly, to force a peer disconnection an event of type PeerDisconnectionRequired has to be published on the event bus, but for simplicity BitcoinPeerContext implements a Disconnect method that does that. So anytime you have a need to disconnect a peer, just call thePeerContext.Disconnect(\"My Disconnection reason!\") . You can find already usage of it in message processor classes. The peer context creation is handled by the core Mithril Shard network implementation and since it can't know about the BitcoinPeerContext properties, it relies on a peer context factory, in this case we are talking about BitcoinPeerContextFactory class. It leverages the generic class PeerContextFactory<> and its implementation is bare bone, no need to override anything. 1 public class PeerContextFactory < TPeerContext > : IPeerContextFactory where TPeerContext : IPeerContext", "title": "Peer Context"}, {"location": "shards/bitcoin/network/#accepting-a-connection", "text": "Once the peer context has been created, a sanity check is performed to see if the two peers can connect to each other before trying to handshake and the behavior is very similar to both inbound and outbound connections. The only difference is that actually for outgoing connection the check is done before trying to connect but very likely it would be done as per incoming connection soon. What happens when an incoming connection has been accepted is that the connection has to pass all registered (in the DI containers) implementations of IServerPeerConnectionGuard interface.", "title": "Accepting a connection"}, {"location": "shards/bitcoin/network/#serverpeerconnectionguardbase", "text": "In Bitcoin shard all guard rules are extending ServerPeerConnectionGuardBase implementation that's a simple class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public abstract class ServerPeerConnectionGuardBase : IServerPeerConnectionGuard { protected readonly ILogger logger ; protected readonly ForgeConnectivitySettings settings ; public ServerPeerConnectionGuardBase ( ILogger logger , IOptions < ForgeConnectivitySettings > options ) { this . logger = logger ; settings = options . Value ; } public ServerPeerConnectionGuardResult Check ( IPeerContext peerContext ) { string? denyReason = TryGetDenyReason ( peerContext ); if (! string . IsNullOrEmpty ( denyReason )) { logger . LogDebug ( \"Peer connection guard not passed: {denyReason}\" , denyReason ); return ServerPeerConnectionGuardResult . Deny ( denyReason ); } return ServerPeerConnectionGuardResult . Allow (); } internal abstract string? TryGetDenyReason ( IPeerContext peerContext ); } This class implements the plumbing code required to run (and log in case of rule check not passed) the guard rule, so a guard rule implementation has just to focus on its guarding logic. A simple example is the MaxConnectionThresholdGuard rule that ensure that an incoming transaction doesn't exceed the maximum allowed number of inbound connections: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MaxConnectionThresholdGuard : ServerPeerConnectionGuardBase { readonly IConnectivityPeerStats _peerStats ; public MaxConnectionThresholdGuard ( ILogger < MaxConnectionThresholdGuard > logger , IOptions < ForgeConnectivitySettings > settings , IConnectivityPeerStats serverPeerStats ) : base ( logger , settings ) { _peerStats = serverPeerStats ; } internal override string? TryGetDenyReason ( IPeerContext peerContext ) { if ( _peerStats . ConnectedInboundPeersCount >= settings . MaxInboundConnections ) { return \"Inbound connection refused: max connection threshold reached.\" ; } return null ; } } In order to be used during connection check, these guard classes have to be registered in the DI container. MaxConnectionThresholdGuard for example is registered into the extension that register the bitcoin shard by using 1 services.AddSingleton<IServerPeerConnectionGuard, InitialBlockDownloadStateGuard>() This allow the flexibility of having custom guard rule simply by implementing a rule and register in the DI container, any required service will be injected automatically; of course if it relies on a custom service not already available in my implementation, that service has to be registered too. Info These classes have to be registered as singleton and therefor must be stateless Network protocol is implemented through the serialization of classes which implement INetworkMessage interface and are decorated with NetworkMessageAttribute that works in synergy with an implementation of INetworkMessageSerializer to implement network serialization.", "title": "ServerPeerConnectionGuardBase"}, {"location": "shards/bitcoin/network/#handshake", "text": "Once a connection has been accepted between two nodes, they start exchanging messages in order to handshake and prove each other they are two compatible nodes that can exchange informations. Info Bitcoin protocol doesn't punish nodes that send unknown messages. I think however that a node has to monitor its connected peer activities and punish them if they send too many unknown messages causing our node to waste resources. Without going too deeper into bitcoin handshake process, the exchanges messages are summarized by this sequence diagram: sequenceDiagram participant L as Local participant R as Remote L-->>+R:Connects to L->>+R:Version R->>L:Version R->>L:Verack L->>R:Verack Info Bitcoin protocol doesn't define a specific order for the Remote node to send its Verack and Version message so Local node has to account that and accept these messages in any order.", "title": "Handshake"}, {"location": "shards/bitcoin/testing_node_communication/", "text": "Testing node communication In order to test the Forge implementation, I used the handy bitcoin testnet in a box I used the docker implementation: docker pull freewil/bitcoin-testnet-box then I modified the suggested docker run arguments, in order to open the node port, this way, to run the image with an reachable testnet node, run the image as docker run -t -i -p 19000:19000 -p 19001:19001 -p 19011:19011 freewil/bitcoin-testnet-box after that, in the tty console, write make start to start the node and this way you can connect to the testnet box using the endpoint 127.0.0.1:19000 If everything is going as expected and you ran the Forge within bitcoin-testnet network, you should see something similar to this At the time of the screenshot (2nd of January 2020) only the handshake implementation was ready, this is why of warnings following the successful handshake. Troubleshooting System.Net.Sockets.SocketException (10013) In case you receive this error while trying to open some port for listening, the reason may be your OS is excluding some port ranges for some reason. To check if the port is reserved, you can use the command netsh interface ipv4 show excludedportrange tcp you'll see a list of port ranges that may include the port you are trying to open. To fix that your best bet is to just change the port you want to use in your configuration file, otherwise you need to understand why a specific port range is being reserved and eventually change it. You can delete the excludedportrange if you want and you know what you are doing, using commands like netsh int ipv4 delete excludedportrange protocol=tcp startport=45000 numberofports=100 and add new ones with netsh int ipv4 add excludedportrange protocol=tcp startport=45000 numberofports=100", "title": "Testing node communication"}, {"location": "shards/bitcoin/testing_node_communication/#testing-node-communication", "text": "In order to test the Forge implementation, I used the handy bitcoin testnet in a box I used the docker implementation: docker pull freewil/bitcoin-testnet-box then I modified the suggested docker run arguments, in order to open the node port, this way, to run the image with an reachable testnet node, run the image as docker run -t -i -p 19000:19000 -p 19001:19001 -p 19011:19011 freewil/bitcoin-testnet-box after that, in the tty console, write make start to start the node and this way you can connect to the testnet box using the endpoint 127.0.0.1:19000 If everything is going as expected and you ran the Forge within bitcoin-testnet network, you should see something similar to this At the time of the screenshot (2nd of January 2020) only the handshake implementation was ready, this is why of warnings following the successful handshake.", "title": "Testing node communication"}, {"location": "shards/bitcoin/testing_node_communication/#troubleshooting", "text": "", "title": "Troubleshooting"}, {"location": "shards/bitcoin/testing_node_communication/#systemnetsocketssocketexception-10013", "text": "In case you receive this error while trying to open some port for listening, the reason may be your OS is excluding some port ranges for some reason. To check if the port is reserved, you can use the command netsh interface ipv4 show excludedportrange tcp you'll see a list of port ranges that may include the port you are trying to open. To fix that your best bet is to just change the port you want to use in your configuration file, otherwise you need to understand why a specific port range is being reserved and eventually change it. You can delete the excludedportrange if you want and you know what you are doing, using commands like netsh int ipv4 delete excludedportrange protocol=tcp startport=45000 numberofports=100 and add new ones with netsh int ipv4 add excludedportrange protocol=tcp startport=45000 numberofports=100", "title": "System.Net.Sockets.SocketException (10013)"}, {"location": "shards/dev-controller/", "text": "DevControllerShard is a shard that depends on WebApiShard", "title": "Overview"}, {"location": "shards/serilog/", "text": "SerilogShard allows to inject Serilog log provider into the forge, allowing every service to leverage it to produce a proper loggin implementation for the application. It can be injected into the forge just by using the IForgeBuilder extension 1 public static IForgeBuilder UseSerilog ( this IForgeBuilder forgeBuilder , string? configurationFile = null ) configurationFile is optional, and can contain the path of a JSON configuration file, refers to Serilog documentation to see how to configure it properly. If no configurationFile is specified, the forge configuration file is used. Note Using an explicit configuration file allows to have more control over the configuration files used during debug and deploy, because allows you to have a file for application configuration, and a different set of configuration files specific for logging, where you can pre-configure a set of filters based on your needs An example of a configuration section is this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 { \"Serilog\" : { \"Using\" : [ \"Serilog.Sinks.Console\" , \"Serilog.Sinks.Seq\" ], \"Enrich\" : [ \"FromLogContext\" , \"WithMachineName\" , \"WithThreadId\" ], \"WriteTo\" : [ { \"Name\" : \"Console\" , \"Args\" : { \"IncludeScopes\" : true , \"theme\" : \"Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console\" } }, { \"Name\" : \"Seq\" , \"Args\" : { \"serverUrl\" : \"http://localhost:5341\" } } ], \"MinimumLevel\" : { \"Default\" : \"Debug\" , \"Override\" : { \"Bedrock.Framework\" : \"Warning\" , \"Microsoft\" : \"Warning\" , \"System\" : \"Warning\" } } } } In this example we are defining two serilog sinks: console and seq sink . MinimulLevel section allows to configure the filter based on logging severity level, in this case the default level is Debug and we have a couple of override to rise the level to warning for all classes belonging to namespace Bedrok.Framework , Microsoft and System Tweaking these settings is important to reduce the noise of unwanted logs of 3rd party libraries and focus our attention on logs that matter to us. Console Sink Console configure the logger to use console output and in the WriteTo section we specify to include scopes and use a theme to colorize the output. An output example is this Seq Sink Seq is an interesting web application that can be configured to receive logs generated by Serilog, it has a free plan for single user and in my case it was a good choice for development purpose because I can host it in my local environment and leverage its feature to be able to investigate problems. It can be both installed locally or be hosted in a docker container. In the example above it has been configured to receive logs on port 5341 1 2 3 4 { \"Name\" : \"Seq\" , \"Args\" : { \"serverUrl\" : \"http://localhost:5341\" } } It shares the same MinimumLevel section to configure which logs will be persisted but can have dynamic overrides. Seq allows you to query, create filters, signals and show structured logs in a friendly way, for further information refers to Seq website. An example of Seq interface with a couple of expanded logs, to show you additional information you can found in these logs", "title": "Overview"}, {"location": "shards/serilog/#console-sink", "text": "Console configure the logger to use console output and in the WriteTo section we specify to include scopes and use a theme to colorize the output. An output example is this", "title": "Console Sink"}, {"location": "shards/serilog/#seq-sink", "text": "Seq is an interesting web application that can be configured to receive logs generated by Serilog, it has a free plan for single user and in my case it was a good choice for development purpose because I can host it in my local environment and leverage its feature to be able to investigate problems. It can be both installed locally or be hosted in a docker container. In the example above it has been configured to receive logs on port 5341 1 2 3 4 { \"Name\" : \"Seq\" , \"Args\" : { \"serverUrl\" : \"http://localhost:5341\" } } It shares the same MinimumLevel section to configure which logs will be persisted but can have dynamic overrides. Seq allows you to query, create filters, signals and show structured logs in a friendly way, for further information refers to Seq website. An example of Seq interface with a couple of expanded logs, to show you additional information you can found in these logs", "title": "Seq Sink"}, {"location": "shards/web-api/", "text": "WebApiShard is an important shard that allows to expose Web API (s) endpoints based on OpeAPI specifications . Swashbuckle is used under the hood and you can find more technical information about OpenAPI, REST APIs and Swagger concepts on microsoft documentation . WebApiShard comes with a WebApiSettings class that holds settings to configure the service. To add the shard to the forge, the IForgeBuilder extension UseApi has to be called, passing optional options to further configure the service 1 public static IForgeBuilder UseApi ( this IForgeBuilder forgeBuilder , Action < WebApiOptions >? options = null ) WebApiShard implements the WEB API controllers using the standard aspnet ControllerBase class but decorates it with a set of default attributes needed to expose these controllers in the right context. To create a proper WebApiShard controller, an abstract base class MithrilControllerBase exists that applies already the required attributes. 1 2 3 4 [ApiController] [Produces(\"application/json\")] [Route(\"[area] /[ controller ]/[ action ] \")] public abstract class MithrilControllerBase : ControllerBase { } Areas are used to subdivide APIs based on grouping criteria and each area can be enabled or disabled by configuring the corresponding ApiServiceDefinition . By default two areas are defined but custom areas can be created easily. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /// <summary> /// Placeholder to define known core WEB API areas. /// This class may be extended to add more const for 3rd party areas. /// </summary> public abstract class WebApiArea { /// <summary> /// The default API area where common actions will be available. /// </summary> public const string AREA_API = \"api\" ; /// <summary> /// The area where Dev controllers has to be placed. /// Dev controllers are controllers useful during debug that can expose internal details /// or are risky to be used in a public environment /// They may be risky to execute by an end user that doesn't have good technical details /// knowledge about the application. /// </summary> public const string AREA_DEV = \"dev\" ; } Note WebApiShard controllers have to belong to a specific area. More information in Creating a Controller section. DisableByEndPointActionFilterAttribute class, that's a registered ActionFilterAttribute , is responsible to enforce proper checks against executing an action on an unspecified, unknown or disabled area. Warning The current implementation may be subject to changes to implement the authentication and authorization layer.", "title": "Overview"}, {"location": "shards/web-api/areas/", "text": "WebApiShard organize controllers assigning them to specific areas. Areas are used to subdivide APIs based on grouping criteria and each area can be enabled or disabled by configuring the corresponding ApiServiceDefinition . By default two areas are defined: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /// <summary> /// Placeholder to define known core WEB API areas. /// This class may be extended to add more const for 3rd party areas. /// </summary> public abstract class WebApiArea { /// <summary> /// The default API area where common actions will be available. /// </summary> public const string AREA_API = \"api\" ; /// <summary> /// The area where Dev controllers has to be placed. /// Dev controllers are controllers useful during debug that can expose internal details /// or are risky to be used in a public environment /// They may be risky to execute by an end user that doesn't have good technical details /// knowledge about the application. /// </summary> public const string AREA_DEV = \"dev\" ; } Custom areas can be created easily by defining them using ApiServiceDefinition . DevControllerShard for example defines its own ApiServiceDefinition to group all controllers meant to be used for development / diagnostic purpose. Note Any WebApiShard compliant controller has to belong to a specific area, by specifying an AreaAttribute at controller class level. ApiServiceDefinition ApiServiceDefinition is a class responsible to hold a WEB Api area configuration. It contains an Enabled property used to enable or disable that specific area and its value is usually set by using the configuration file of the shard responsible for the ApiServiceDefinition. DevControllerShard code shows an example of how to register an area during the shard registration: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 forgeBuilder . AddShard < DevControllerShard , DevControllerSettings >(( hostBuildContext , services ) => { services . AddSingleton < ApiServiceDefinition >( sp => { var settings = sp . GetService < IOptions < DevControllerSettings >>()!. Value ; var definition = new ApiServiceDefinition { Enabled = settings . Enabled , Area = WebApiArea . AREA_DEV , Name = \"Dev API\" , Description = \"API useful for debug purpose.\" , Version = \"v1\" , }; forgeBuilder . AddApiService ( definition ); return definition ; }); }); In this example you can see that Area is set to WebApiArea.AREA_DEV that's simply a constant string that's the equivalent of set it to \"dev\" and Enabled is set to settings.Enabled , this way it's enabled or disabled based on the DevControllerSettings configuration. Creating custom areas The process to create a custom area is the same as the one shown in the example above, the only difference is the Area value, that can be any string. In order to have controllers assigned to such area, a controller has to be decorated with an Area attribute like in this example: 1 2 [Area(WebApiArea.AREA_DEV)] public class PeerManagementController : MithrilControllerBase You can find more information on controller creation in the Creating a Controller section.", "title": "WEB API Areas"}, {"location": "shards/web-api/areas/#apiservicedefinition", "text": "ApiServiceDefinition is a class responsible to hold a WEB Api area configuration. It contains an Enabled property used to enable or disable that specific area and its value is usually set by using the configuration file of the shard responsible for the ApiServiceDefinition. DevControllerShard code shows an example of how to register an area during the shard registration: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 forgeBuilder . AddShard < DevControllerShard , DevControllerSettings >(( hostBuildContext , services ) => { services . AddSingleton < ApiServiceDefinition >( sp => { var settings = sp . GetService < IOptions < DevControllerSettings >>()!. Value ; var definition = new ApiServiceDefinition { Enabled = settings . Enabled , Area = WebApiArea . AREA_DEV , Name = \"Dev API\" , Description = \"API useful for debug purpose.\" , Version = \"v1\" , }; forgeBuilder . AddApiService ( definition ); return definition ; }); }); In this example you can see that Area is set to WebApiArea.AREA_DEV that's simply a constant string that's the equivalent of set it to \"dev\" and Enabled is set to settings.Enabled , this way it's enabled or disabled based on the DevControllerSettings configuration.", "title": "ApiServiceDefinition"}, {"location": "shards/web-api/areas/#creating-custom-areas", "text": "The process to create a custom area is the same as the one shown in the example above, the only difference is the Area value, that can be any string. In order to have controllers assigned to such area, a controller has to be decorated with an Area attribute like in this example: 1 2 [Area(WebApiArea.AREA_DEV)] public class PeerManagementController : MithrilControllerBase You can find more information on controller creation in the Creating a Controller section.", "title": "Creating custom areas"}, {"location": "shards/web-api/creating-a-controller/", "text": "To create a controller that can be exposed by the WebApiShard we can take advantage of the MithrilControllerBase class. We can take a look at the controller implemented in the example project , to dissect it and discuss about its implementation. Let's take a meaningful part of that class and let's dissect it by highlighting some code part: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [Area(WebApiArea.AREA_API)] public class ExampleController : MithrilControllerBase { private readonly ILogger < ExampleController > _logger ; readonly IQuoteService _quoteService ; public ExampleController ( ILogger < ExampleController > logger , IQuoteService quoteService ) { _logger = logger ; _quoteService = quoteService ; } [HttpGet] [ProducesResponseType(StatusCodes.Status200OK)] public ActionResult GetQuotes () { return Ok ( _quoteService . Quotes ); } Define the area Line 1 describes, using AreaAttribute , the area we want this controller to be included. WebApiArea is an helper class that just contains a bounch of constant string of known areas: \"api\" and \"dev\". \"api\" ( WebApiArea.AREA_API ) is the area where generic purpose controller should be placed. They are meant to be used by end users or 3rd party integration, to interact with our application. \"dev\" ( WebApiArea.AREA_DEV ) is the area where Dev controllers should be placed. Dev controllers are controllers useful during debug that can expose internal details or are risky to be used in a public environment. They may be risky to execute by an end user that doesn't have good technical details knowledge about the application and generally you want to enable them when you are developing or you need to collect more information on a running instance of your application. There are some Controllers that are available out of the box when you use Mithril Shards features, an example is SerilogShard that includes SeriLogController that allows to control Log filters at runtime and it's exposed in the \"api\" area, while many more Controllers are exposed in \"dev\" area like the ones included by DevControllerShard . Declare controller Type Line 2 is the Controller class definition and it just declare our ExampleController class that inherit from MithrilControllerBase. The name of the controller class is important because by default the actions implemented in the controller will have a route like the one defined by RouteAttribute that decorates the MithrilControllerBase 1 [Route(\"[area] /[ controller ]/[ action ] \")] area will be replaced by the are we declared our controller belongs to (e.g. \"api\"). controller is the name of the Controller class, stripping out \"Controller\" part, e.g. ExampleController will become \"Example\" action is the name of the action we can invoke ExampleController action GetQuotes URL will then become api/Example/GetQuotes . This represents the part of the url to append to the WebApiShard configured Endpoint, so if we configured it to 127.0.0.1:45030 the complete url will be http://127.0.0.1:45020/api/Example/GetQuotes (or https if we enabled Https). Inject services into constructor Line 7-10 is the Controller constructor. A controller is created automatically at each web request and the parameters declared in the constructor will be populated by using DI In this example, ILogger<ExampleController> logger gets populated with strongly typed instance of our logger and IQuoteService quoteService with the instance of the concrete implementation of our IQuoteService that in our example project we registered as a singleton 1 . AddSingleton < IQuoteService , QuoteService >() Note It's important to know the life cycle of our injected service because they may impact performance. If the constructor of a service is slow and that service is defined as Transient (or Scoped) every action will have to wait its completion before being able to perform its job. Implement an action Lines 13-18 declare and implement an action. In this case, the action is declared as HttpGet , this mean that it will only respond to GET requests. If you try to access that action with others HTTP verbs, it will return a status error 405 Method Not Allowed [ProducesResponseType(StatusCodes.Status200OK)] declare known action status that can be returned by the action. It's just an helpful attribute useful to produce a better documentation on swagger interface and document definition but the action itself may even generate different statuses. This documentation however don't cover canonical Web API implementation, so refer to .Net documentation . to read more about it. To return an action result, the method Ok is invoked, passing the payload (that will be serialized in JSON ) as a response. To document better the result type, we could specify in ProduceResponseTypeAttribute the returned type, it could be helpful for the consumer to know which type of object to receive back and which properties it exposes. In this example it's a simple list of string but it can be any JSON serializable type: 1 [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(List<string>))] As an additional example, this is the code of a DEV controller action that generates different status based on internal state of the node 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 [HttpPost] [ProducesResponseType(StatusCodes.Status200OK)] [ProducesResponseType(StatusCodes.Status404NotFound)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public IActionResult Connect ( PeerManagementConnectRequest request ) { if ( _requiredConnection == null ) { return NotFound ( $ \"Cannot produce output because {nameof(RequiredConnection)} is not available\" ); } if (! IPEndPoint . TryParse ( request . EndPoint , out IPEndPoint ? ipEndPoint )) { return ValidationProblem ( \"Incorrect endpoint\" ); } _requiredConnection . TryAddEndPoint ( ipEndPoint ); return Ok (); } In this example, this action will return 404 (not found) if the member variables _requiredConnection isn't set, or 400 (bad request) if the input peer isn't formatted properly as a valid endpoint. If everything goes fine it will instead return 200 (ok). Tip In case of action problems, instead of calling BadRequest or Problem method extensions, use ValidationProblem , it uses a ValidationProblemDetails response that's consistent with automatic validation error responses, as stated here . In the example above, NotFound could be replaced with ValidationProblem too for a consistent behavior. Producing documentation for Swagger UI In order to produce proper documentation to be shown on Swagger UI , XML comments within C# source can be used but the build process has to generate a documentation file. The easier way is to edit your project file adding this snippet: 1 2 3 <PropertyGroup> <GenerateDocumentationFile> true </GenerateDocumentationFile> </PropertyGroup> For Mithril Shards project defined within the Mithril Shard solution folder this is not necessary because that snippet is already defined in Directory.Build.props file. Note WebApiShard already take care of including documentation files by looking at files with the name of the assembly that contains the controller, with an .xml extension. var xmlFile = $\"{assembly.GetName().Name}.xml\"; Tip Directory.Build.props file is a powerful way to set common project configurations for complex solutions with multiple projects, you can read more about it here .", "title": "Creating a Controller"}, {"location": "shards/web-api/creating-a-controller/#define-the-area", "text": "Line 1 describes, using AreaAttribute , the area we want this controller to be included. WebApiArea is an helper class that just contains a bounch of constant string of known areas: \"api\" and \"dev\". \"api\" ( WebApiArea.AREA_API ) is the area where generic purpose controller should be placed. They are meant to be used by end users or 3rd party integration, to interact with our application. \"dev\" ( WebApiArea.AREA_DEV ) is the area where Dev controllers should be placed. Dev controllers are controllers useful during debug that can expose internal details or are risky to be used in a public environment. They may be risky to execute by an end user that doesn't have good technical details knowledge about the application and generally you want to enable them when you are developing or you need to collect more information on a running instance of your application. There are some Controllers that are available out of the box when you use Mithril Shards features, an example is SerilogShard that includes SeriLogController that allows to control Log filters at runtime and it's exposed in the \"api\" area, while many more Controllers are exposed in \"dev\" area like the ones included by DevControllerShard .", "title": "Define the area"}, {"location": "shards/web-api/creating-a-controller/#declare-controller-type", "text": "Line 2 is the Controller class definition and it just declare our ExampleController class that inherit from MithrilControllerBase. The name of the controller class is important because by default the actions implemented in the controller will have a route like the one defined by RouteAttribute that decorates the MithrilControllerBase 1 [Route(\"[area] /[ controller ]/[ action ] \")] area will be replaced by the are we declared our controller belongs to (e.g. \"api\"). controller is the name of the Controller class, stripping out \"Controller\" part, e.g. ExampleController will become \"Example\" action is the name of the action we can invoke ExampleController action GetQuotes URL will then become api/Example/GetQuotes . This represents the part of the url to append to the WebApiShard configured Endpoint, so if we configured it to 127.0.0.1:45030 the complete url will be http://127.0.0.1:45020/api/Example/GetQuotes (or https if we enabled Https).", "title": "Declare controller Type"}, {"location": "shards/web-api/creating-a-controller/#inject-services-into-constructor", "text": "Line 7-10 is the Controller constructor. A controller is created automatically at each web request and the parameters declared in the constructor will be populated by using DI In this example, ILogger<ExampleController> logger gets populated with strongly typed instance of our logger and IQuoteService quoteService with the instance of the concrete implementation of our IQuoteService that in our example project we registered as a singleton 1 . AddSingleton < IQuoteService , QuoteService >() Note It's important to know the life cycle of our injected service because they may impact performance. If the constructor of a service is slow and that service is defined as Transient (or Scoped) every action will have to wait its completion before being able to perform its job.", "title": "Inject services into constructor"}, {"location": "shards/web-api/creating-a-controller/#implement-an-action", "text": "Lines 13-18 declare and implement an action. In this case, the action is declared as HttpGet , this mean that it will only respond to GET requests. If you try to access that action with others HTTP verbs, it will return a status error 405 Method Not Allowed [ProducesResponseType(StatusCodes.Status200OK)] declare known action status that can be returned by the action. It's just an helpful attribute useful to produce a better documentation on swagger interface and document definition but the action itself may even generate different statuses. This documentation however don't cover canonical Web API implementation, so refer to .Net documentation . to read more about it. To return an action result, the method Ok is invoked, passing the payload (that will be serialized in JSON ) as a response. To document better the result type, we could specify in ProduceResponseTypeAttribute the returned type, it could be helpful for the consumer to know which type of object to receive back and which properties it exposes. In this example it's a simple list of string but it can be any JSON serializable type: 1 [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(List<string>))] As an additional example, this is the code of a DEV controller action that generates different status based on internal state of the node 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 [HttpPost] [ProducesResponseType(StatusCodes.Status200OK)] [ProducesResponseType(StatusCodes.Status404NotFound)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public IActionResult Connect ( PeerManagementConnectRequest request ) { if ( _requiredConnection == null ) { return NotFound ( $ \"Cannot produce output because {nameof(RequiredConnection)} is not available\" ); } if (! IPEndPoint . TryParse ( request . EndPoint , out IPEndPoint ? ipEndPoint )) { return ValidationProblem ( \"Incorrect endpoint\" ); } _requiredConnection . TryAddEndPoint ( ipEndPoint ); return Ok (); } In this example, this action will return 404 (not found) if the member variables _requiredConnection isn't set, or 400 (bad request) if the input peer isn't formatted properly as a valid endpoint. If everything goes fine it will instead return 200 (ok). Tip In case of action problems, instead of calling BadRequest or Problem method extensions, use ValidationProblem , it uses a ValidationProblemDetails response that's consistent with automatic validation error responses, as stated here . In the example above, NotFound could be replaced with ValidationProblem too for a consistent behavior.", "title": "Implement an action"}, {"location": "shards/web-api/creating-a-controller/#producing-documentation-for-swagger-ui", "text": "In order to produce proper documentation to be shown on Swagger UI , XML comments within C# source can be used but the build process has to generate a documentation file. The easier way is to edit your project file adding this snippet: 1 2 3 <PropertyGroup> <GenerateDocumentationFile> true </GenerateDocumentationFile> </PropertyGroup> For Mithril Shards project defined within the Mithril Shard solution folder this is not necessary because that snippet is already defined in Directory.Build.props file. Note WebApiShard already take care of including documentation files by looking at files with the name of the assembly that contains the controller, with an .xml extension. var xmlFile = $\"{assembly.GetName().Name}.xml\"; Tip Directory.Build.props file is a powerful way to set common project configurations for complex solutions with multiple projects, you can read more about it here .", "title": "Producing documentation for Swagger UI"}, {"location": "shards/web-api/swagger-ui/", "text": "TODO", "title": "Using Swagger UI"}, {"location": "shards/web-api/swagger-ui/#todo", "text": "", "title": "TODO"}, {"location": "shards/web-api/using-webapishard/", "text": "Add WebApiService to the forge To add the shard to the forge, the IForgeBuilder extension UseApi has to be called, passing optional options to further configure the service 1 public static IForgeBuilder UseApi ( this IForgeBuilder forgeBuilder , Action < WebApiOptions >? options = null ) WebApiOptions WebApiOptions class allows to customize the discovery process that's responsible to find and register Web API controllers end include them into a specific ApiServiceDefinition . The discovery process happens during WebApiShard initialization: it generates an ApplicationPart for each registered shard that will include all discovered MithrilControllerBase (ControllerBase) types defined in the shard assembly. ControllersSeeker Sometimes you may have a project that just holds Controllers but isn't exposed as a shard, in this scenario you can use WebApiOptions during the call of UseApi, to explicitly add an assembly to inspect for controllers. The example project makes use of this when it builds the forge: 1 2 3 4 5 /// we are injecting ExampleDev type to allow <see cref=\"WebApi.WebApiShard\"/> to find all the controllers /// defined there because only controllers defined in an included shard assemblies are discovered automatically. /// Passing ExampleDev will cause dotnet runtime to load the assembly where ExampleDev Type is defined and every /// controllers defined there will be found later during <see cref=\"WebApi.WebApiShard\"/> initialization. . UseApi ( options => options . ControllersSeeker = ( seeker ) => seeker . LoadAssemblyFromType < ExampleDev >()) By doing this WebApiOptions will create an Application part for each explicitly added assembly and all Controller types defined in that assembly will be found and added to the available controllers in their specific area. EnablePublicApi This settings enables or disables the public API area . The public area corresponds to the ApiServiceDefinition that's responsible to enable all controllers assigned to the area WebApiArea.AREA_API . If you are creating an application where a public area is never needed, you may want to use this property rather than relying on external configuration file that may be missing or edited. WebApiSettings WebApiSettings is the class that holds configuration settings required by the shard to works. It contains few properties to configure the endpoint used to listen to API requests and its behavior: Property Type Description Default EndPoint string IP address and port number on which the shard will serve its Web API endpoint, in the form of ip_address:port . \"127.0.0.1:45020\" Https bool Whether WEB API should be exposed on HTTPS. false Enabled bool Whether WebApiShard is enabled or not. Disabling it would cause any shard depending on WebApiShard, such as custom controllers or custom areas, to be unable to be served. true Configuration properties can be set in the application configuartion file, within its root section, under the name of WebApi Note every shard configuration section is mapped by default to the name of the configuration setting class, stripping out the Settings part example: 1 2 3 4 5 \"WebApi\" : { \"EndPoint\" : \"127.0.0.1:45030\" , \"Enabled\" : false , \"Https\" : false }", "title": "Using WebApiShard"}, {"location": "shards/web-api/using-webapishard/#add-webapiservice-to-the-forge", "text": "To add the shard to the forge, the IForgeBuilder extension UseApi has to be called, passing optional options to further configure the service 1 public static IForgeBuilder UseApi ( this IForgeBuilder forgeBuilder , Action < WebApiOptions >? options = null )", "title": "Add WebApiService to the forge"}, {"location": "shards/web-api/using-webapishard/#webapioptions", "text": "WebApiOptions class allows to customize the discovery process that's responsible to find and register Web API controllers end include them into a specific ApiServiceDefinition . The discovery process happens during WebApiShard initialization: it generates an ApplicationPart for each registered shard that will include all discovered MithrilControllerBase (ControllerBase) types defined in the shard assembly.", "title": "WebApiOptions"}, {"location": "shards/web-api/using-webapishard/#controllersseeker", "text": "Sometimes you may have a project that just holds Controllers but isn't exposed as a shard, in this scenario you can use WebApiOptions during the call of UseApi, to explicitly add an assembly to inspect for controllers. The example project makes use of this when it builds the forge: 1 2 3 4 5 /// we are injecting ExampleDev type to allow <see cref=\"WebApi.WebApiShard\"/> to find all the controllers /// defined there because only controllers defined in an included shard assemblies are discovered automatically. /// Passing ExampleDev will cause dotnet runtime to load the assembly where ExampleDev Type is defined and every /// controllers defined there will be found later during <see cref=\"WebApi.WebApiShard\"/> initialization. . UseApi ( options => options . ControllersSeeker = ( seeker ) => seeker . LoadAssemblyFromType < ExampleDev >()) By doing this WebApiOptions will create an Application part for each explicitly added assembly and all Controller types defined in that assembly will be found and added to the available controllers in their specific area.", "title": "ControllersSeeker"}, {"location": "shards/web-api/using-webapishard/#enablepublicapi", "text": "This settings enables or disables the public API area . The public area corresponds to the ApiServiceDefinition that's responsible to enable all controllers assigned to the area WebApiArea.AREA_API . If you are creating an application where a public area is never needed, you may want to use this property rather than relying on external configuration file that may be missing or edited.", "title": "EnablePublicApi"}, {"location": "shards/web-api/using-webapishard/#webapisettings", "text": "WebApiSettings is the class that holds configuration settings required by the shard to works. It contains few properties to configure the endpoint used to listen to API requests and its behavior: Property Type Description Default EndPoint string IP address and port number on which the shard will serve its Web API endpoint, in the form of ip_address:port . \"127.0.0.1:45020\" Https bool Whether WEB API should be exposed on HTTPS. false Enabled bool Whether WebApiShard is enabled or not. Disabling it would cause any shard depending on WebApiShard, such as custom controllers or custom areas, to be unable to be served. true Configuration properties can be set in the application configuartion file, within its root section, under the name of WebApi Note every shard configuration section is mapped by default to the name of the configuration setting class, stripping out the Settings part example: 1 2 3 4 5 \"WebApi\" : { \"EndPoint\" : \"127.0.0.1:45030\" , \"Enabled\" : false , \"Https\" : false }", "title": "WebApiSettings"}]}