{"config": {"lang": ["en"], "min_search_length": 3, "prebuild_index": false, "separator": "[\\s\\-]+"}, "docs": [{"location": "", "text": "Goal Mithril Shards goal is to implement a .NET 5 extensible P2P network & distributed services library from scratch with focus on architecture and performance. Allows you to define custom network serialization protocol, easily handle payload messages and interact with the software leveraging any available features (named Shards) like Web API endpoints, cross platform Blazor UI , and a lot of other exciting stuffs that community can implement and release to the public too! The project is very ambitious and it's currently developed just by me as a pet project but a huge effort has already been made and some part of this unique code base has been reused in other blockchain technologies to improve their performance. Current Tech A random list of available tech used within Mithril Shards. .Net 5 - ... for everything. Bedrock Framework - TCP/IP default connectivity implementation. Swashbuckle - to handle Web API in a configurable, multi-area environment and have a playground to test APIs with swagger. Serilog - default logging implementation. BenchmarkDotNet - a benchmark framework, very handy to benchmark different approach during implementation phases. How things started I have DLT experience in the past years and one of my previous experience has been working for a blockchain tech firm that had a FN implementation in C#. I really love C# and .Net core has improved a lot performance too. Working on their codebase I saw lot of things that could have been improved, both in design and in performance. Their implementation started as a kind of 1-1 porting of bitcoin core source with all the cons that it brings. So I thought about diving into this titanic effort of creating a full node in C# starting from scratch, mainly to go as deeper as possible into technical details, trying to focus both on a proper architecture design and performance improvements. One of the first thing I implemented was of course the basic handshake process between two nodes and to achieve that, I started by following bitcoin core source because unluckily that's the only part that contains kind of specifications: it's hard to find a detailed updated technical documentations, even this protocol documentation page contains wrong information, even if it's still useful. I started using .Net TCP classes, using an internal state machine to handle peer connection statuses, then I found Bedrock Framework , that allowed me to abstract better my code and rely on it for the low level connection stuff (at the time of writing this documentation, that library is still in alpha and my concern about that project activity has been appeased ). As soon as I started defining properly my design, I found it interesting to abstract most of the stuff into an agnostic library that would allows me to create a P2P application in a modular way and attach additional features when needed, and this is how Mithril Shards started. Since then I added more and more stuff, both for generic Mithril Shards project and for specific Bitcoin needs. The multi project Example Shard showcases how you can create a custom P2P software leveraging networking, custom messages, Web API endpoints Diagnostic tools, everything with a proper logging system. Why the Mithril Shards name? Well... let's bullet some facts I like fantasy a lot, J.R.R. Tolkien of course has been one of my reads and mithril is a fictional metal in his universe. The main properties of mithri are: being very strong, light and in its pure form very malleable to work with. I'm a developer who likes to engineer my software to be extensible and solid. My github handle is MithrilMan, guess what? Now take these information, mix them up, and you'll see that to I aim to have a robust, fast and flexible project! So this explain mithril, while about Shards , is because I see this project as a mix of shards that can be assembled together to give you a precious artifact! In fact you shouldn't be surprised that the root class is called Forge... who says we can't have a bit of fun while designing a software? Call to Action! Join to give feedback, ask for features, support, etc. Discord server: https://discord.gg/T9kyKz4bAu CI Current status", "title": "Welcome!"}, {"location": "#goal", "text": "Mithril Shards goal is to implement a .NET 5 extensible P2P network & distributed services library from scratch with focus on architecture and performance. Allows you to define custom network serialization protocol, easily handle payload messages and interact with the software leveraging any available features (named Shards) like Web API endpoints, cross platform Blazor UI , and a lot of other exciting stuffs that community can implement and release to the public too! The project is very ambitious and it's currently developed just by me as a pet project but a huge effort has already been made and some part of this unique code base has been reused in other blockchain technologies to improve their performance.", "title": "Goal"}, {"location": "#current-tech", "text": "A random list of available tech used within Mithril Shards. .Net 5 - ... for everything. Bedrock Framework - TCP/IP default connectivity implementation. Swashbuckle - to handle Web API in a configurable, multi-area environment and have a playground to test APIs with swagger. Serilog - default logging implementation. BenchmarkDotNet - a benchmark framework, very handy to benchmark different approach during implementation phases.", "title": "Current Tech"}, {"location": "#how-things-started", "text": "I have DLT experience in the past years and one of my previous experience has been working for a blockchain tech firm that had a FN implementation in C#. I really love C# and .Net core has improved a lot performance too. Working on their codebase I saw lot of things that could have been improved, both in design and in performance. Their implementation started as a kind of 1-1 porting of bitcoin core source with all the cons that it brings. So I thought about diving into this titanic effort of creating a full node in C# starting from scratch, mainly to go as deeper as possible into technical details, trying to focus both on a proper architecture design and performance improvements. One of the first thing I implemented was of course the basic handshake process between two nodes and to achieve that, I started by following bitcoin core source because unluckily that's the only part that contains kind of specifications: it's hard to find a detailed updated technical documentations, even this protocol documentation page contains wrong information, even if it's still useful. I started using .Net TCP classes, using an internal state machine to handle peer connection statuses, then I found Bedrock Framework , that allowed me to abstract better my code and rely on it for the low level connection stuff (at the time of writing this documentation, that library is still in alpha and my concern about that project activity has been appeased ). As soon as I started defining properly my design, I found it interesting to abstract most of the stuff into an agnostic library that would allows me to create a P2P application in a modular way and attach additional features when needed, and this is how Mithril Shards started. Since then I added more and more stuff, both for generic Mithril Shards project and for specific Bitcoin needs. The multi project Example Shard showcases how you can create a custom P2P software leveraging networking, custom messages, Web API endpoints Diagnostic tools, everything with a proper logging system.", "title": "How things started"}, {"location": "#why-the-mithril-shards-name", "text": "Well... let's bullet some facts I like fantasy a lot, J.R.R. Tolkien of course has been one of my reads and mithril is a fictional metal in his universe. The main properties of mithri are: being very strong, light and in its pure form very malleable to work with. I'm a developer who likes to engineer my software to be extensible and solid. My github handle is MithrilMan, guess what? Now take these information, mix them up, and you'll see that to I aim to have a robust, fast and flexible project! So this explain mithril, while about Shards , is because I see this project as a mix of shards that can be assembled together to give you a precious artifact! In fact you shouldn't be surprised that the root class is called Forge... who says we can't have a bit of fun while designing a software?", "title": "Why the Mithril Shards name?"}, {"location": "#call-to-action", "text": "Join to give feedback, ask for features, support, etc. Discord server: https://discord.gg/T9kyKz4bAu", "title": "Call to Action!"}, {"location": "#ci", "text": "Current status", "title": "CI"}, {"location": "example-projects/", "text": "The best way to see it in action is by inspecting the Example projects I've created. It's a multi-project example where each project plays its role into the modular application architecture. Its goal is to show how to make use of Mithril Shards to implement a P2P application that implements a custom Web API controller, a custom network implementation and its own protocol with custom messages and serializators. It reuses some other standard shards like : BedrockNetworkShard [StatisticCollectorShard] SerilogShard WebApiShard DevControllerShard What it does is quite simple: You can run two instance of this project to connect to each other and every 10 seconds a ping message will be sent to the other peer, with a random quote message. The quote message is randomly picked by the QuoteService and quotes can be manipulated by using the ExampleController exposed by the Web API . Example Projects The example is composed by several projects, each one with their own scope, to mimic a (simple) typical modular application: MithrilShards.Example MithrilShards.Example.Network.Bedrock MithrilShards.Example.Dev MithrilShards.Example.Node Each project has its own documentation page to present its purpose and to explain some implementation details, however all the code is well commented so you shouldn't have any problems understanding it, in any case the Discussions on my repository is open for you.", "title": "Example Projects Overview"}, {"location": "example-projects/#example-projects", "text": "The example is composed by several projects, each one with their own scope, to mimic a (simple) typical modular application: MithrilShards.Example MithrilShards.Example.Network.Bedrock MithrilShards.Example.Dev MithrilShards.Example.Node Each project has its own documentation page to present its purpose and to explain some implementation details, however all the code is well commented so you shouldn't have any problems understanding it, in any case the Discussions on my repository is open for you.", "title": "Example Projects"}, {"location": "example-projects/mithril-shards-example-dev/", "text": "MithrilShards.Example.Dev Contains just a Controller that expose a couple of Web API actions to manipulate the QuoteService and list, add and remove quotes. In order to show an alternative way to register controllers, this project doesn't implement a shard and doesn't have any Add* / Use* extension method to add its share, instead its controller is discovered using the ControllersSeeker property of WebApiShard in its UseApi extension method..", "title": "MithrilShards.Example.Dev"}, {"location": "example-projects/mithril-shards-example-dev/#mithrilshardsexampledev", "text": "Contains just a Controller that expose a couple of Web API actions to manipulate the QuoteService and list, add and remove quotes. In order to show an alternative way to register controllers, this project doesn't implement a shard and doesn't have any Add* / Use* extension method to add its share, instead its controller is discovered using the ControllersSeeker property of WebApiShard in its UseApi extension method..", "title": "MithrilShards.Example.Dev"}, {"location": "example-projects/mithril-shards-example-network-bedrock/", "text": "MithrilShards.Example.Network.Bedrock Contains few classes that are implementing the INetworkProtocolMessageSerializer interface needed by the BedrockNetworkShard shard to perform message serialization. In this example we are mimicking bitcoin protocol that uses a magic word (4 bytes) that mark the start of a new message and it's message layout to define the rule to decode and encode messages over the network (see ProtocolDefinition.cs file). Note how the code is really small and how it's easy to define custom network serialization of messages. Current implementation relies on Bedrock framework shard, but if you want to create another lol level network implementation you are free to do so, you don't have to change anything else except this project to make use of your new low level network protocol, everything is abstracted out in the Mithril Shards Core project!!", "title": "MithrilShards.Example.Network.Bedrock"}, {"location": "example-projects/mithril-shards-example-network-bedrock/#mithrilshardsexamplenetworkbedrock", "text": "Contains few classes that are implementing the INetworkProtocolMessageSerializer interface needed by the BedrockNetworkShard shard to perform message serialization. In this example we are mimicking bitcoin protocol that uses a magic word (4 bytes) that mark the start of a new message and it's message layout to define the rule to decode and encode messages over the network (see ProtocolDefinition.cs file). Note how the code is really small and how it's easy to define custom network serialization of messages. Current implementation relies on Bedrock framework shard, but if you want to create another lol level network implementation you are free to do so, you don't have to change anything else except this project to make use of your new low level network protocol, everything is abstracted out in the Mithril Shards Core project!!", "title": "MithrilShards.Example.Network.Bedrock"}, {"location": "example-projects/mithril-shards-example-node/", "text": "MithrilShards.Example.Node It makes use of System.CommandLine to have implement the application as a CLI . While all other projects were C# Class Library projects, this one produces an executable that's the actual, assembled application. It contains the Program.cs file that melt the shards into the forge and run it, plus a couple of configuration files that you can inspect to see different configuration combinations. Program.cs file is quote short and easy to read: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 using System.CommandLine ; using System.CommandLine.Invocation ; using System.Threading.Tasks ; using MithrilShards.Core.Forge ; using MithrilShards.Dev.Controller ; using MithrilShards.Diagnostic.StatisticsCollector ; using MithrilShards.Example.Dev ; using MithrilShards.Example.Network.Bedrock ; using MithrilShards.Example.Protocol ; using MithrilShards.Logging.Serilog ; using MithrilShards.Network.Bedrock ; using Serilog ; namespace MithrilShards.Example.Node { static class Program { static async Task Main ( string [] args ) { // Create a root command with some options var rootCommand = new RootCommand { new Option < string >( \"--settings\" , getDefaultValue : () => \"forge-settings.json\" , description : \"Specify the path to the forge settings file.\" ), new Option < string? >( \"--log-settings\" , getDefaultValue : () => null , description : \"Specify the path to the forge log settings file. If not specified, try to get logging information from the main forge settings file.\" ), new Option < int >( \"--protocol-version\" , getDefaultValue : () => KnownVersion . CurrentVersion , description : \"Specify the path to the forge settings file.\" ) }; rootCommand . Description = \"Example App\" ; rootCommand . TreatUnmatchedTokensAsErrors = false ; // Note that the parameters of the handler method are matched according to the names of the options rootCommand . Handler = CommandHandler . Create < string , string , int >( async ( settings , logSettings , protocolVersion ) => { await new ForgeBuilder () . UseForge < DefaultForge >( args , settings ) . UseSerilog ( logSettings ) . UseBedrockNetwork < ExampleNetworkProtocolMessageSerializer >() . UseStatisticsCollector ( options => options . DumpOnConsoleOnKeyPress = true ) /// we are injecting ExampleDev type to allow <see cref=\"MithrilShards.WebApi.WebApiShard\"/> to find all the controllers /// defined there because only controllers defined in an included shard assemblies are discovered automatically. /// Passing ExampleDev will cause dotnet runtime to load the assembly where ExampleDev Type is defined and every /// controllers defined there will be found later during <see cref=\"MithrilShards.WebApi.WebApiShard\"/> initialization. . UseApi ( options => options . ControllersSeeker = ( seeker ) => seeker . LoadAssemblyFromType < ExampleDev >()) . UseDevController () . UseExample ( KnownVersion . V1 , protocolVersion ) . RunConsoleAsync () . ConfigureAwait ( false ); }); await rootCommand . InvokeAsync ( args ). ConfigureAwait ( false ); } } }", "title": "MithrilShards.Example.Node"}, {"location": "example-projects/mithril-shards-example-node/#mithrilshardsexamplenode", "text": "It makes use of System.CommandLine to have implement the application as a CLI . While all other projects were C# Class Library projects, this one produces an executable that's the actual, assembled application. It contains the Program.cs file that melt the shards into the forge and run it, plus a couple of configuration files that you can inspect to see different configuration combinations. Program.cs file is quote short and easy to read: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 using System.CommandLine ; using System.CommandLine.Invocation ; using System.Threading.Tasks ; using MithrilShards.Core.Forge ; using MithrilShards.Dev.Controller ; using MithrilShards.Diagnostic.StatisticsCollector ; using MithrilShards.Example.Dev ; using MithrilShards.Example.Network.Bedrock ; using MithrilShards.Example.Protocol ; using MithrilShards.Logging.Serilog ; using MithrilShards.Network.Bedrock ; using Serilog ; namespace MithrilShards.Example.Node { static class Program { static async Task Main ( string [] args ) { // Create a root command with some options var rootCommand = new RootCommand { new Option < string >( \"--settings\" , getDefaultValue : () => \"forge-settings.json\" , description : \"Specify the path to the forge settings file.\" ), new Option < string? >( \"--log-settings\" , getDefaultValue : () => null , description : \"Specify the path to the forge log settings file. If not specified, try to get logging information from the main forge settings file.\" ), new Option < int >( \"--protocol-version\" , getDefaultValue : () => KnownVersion . CurrentVersion , description : \"Specify the path to the forge settings file.\" ) }; rootCommand . Description = \"Example App\" ; rootCommand . TreatUnmatchedTokensAsErrors = false ; // Note that the parameters of the handler method are matched according to the names of the options rootCommand . Handler = CommandHandler . Create < string , string , int >( async ( settings , logSettings , protocolVersion ) => { await new ForgeBuilder () . UseForge < DefaultForge >( args , settings ) . UseSerilog ( logSettings ) . UseBedrockNetwork < ExampleNetworkProtocolMessageSerializer >() . UseStatisticsCollector ( options => options . DumpOnConsoleOnKeyPress = true ) /// we are injecting ExampleDev type to allow <see cref=\"MithrilShards.WebApi.WebApiShard\"/> to find all the controllers /// defined there because only controllers defined in an included shard assemblies are discovered automatically. /// Passing ExampleDev will cause dotnet runtime to load the assembly where ExampleDev Type is defined and every /// controllers defined there will be found later during <see cref=\"MithrilShards.WebApi.WebApiShard\"/> initialization. . UseApi ( options => options . ControllersSeeker = ( seeker ) => seeker . LoadAssemblyFromType < ExampleDev >()) . UseDevController () . UseExample ( KnownVersion . V1 , protocolVersion ) . RunConsoleAsync () . ConfigureAwait ( false ); }); await rootCommand . InvokeAsync ( args ). ConfigureAwait ( false ); } } }", "title": "MithrilShards.Example.Node"}, {"location": "example-projects/mithril-shards-example/", "text": "MithrilShards.Example project represents the core project where most of the fundamental example application classes lies. Most of the custom application code is implemented here: network classes like a custom IPeerContext implementation and its factory class some custom IServerPeerConnectionGuard implementation to filter incoming connections and a custom ConnectorBase implementation that contains the logic to connect to other peers protocol classes like INetworkMessage implementations of custom messages (payloads) and complex types used within their implementation. INetworkMessage and type serializators that serialize classes into a byte representation that can be sent through the network. INetworkMessage processors that contain the logic to parse incoming messages and send messages to other peers classes like shard class and its setting class that forms the plumbing of our application. custom services used by processors or other internal components like QuoteService . Main classes In the following sections we are going to dissect the project to expose and study the main classes implemented in the project. ExampleShard This class represents the core Example Shard, actually it doesn't contains any code but you could extend this example to start for example an async task when the shard starts ( StartAsync method) and stop it when it stops ( StopAsync method). Note that a shard StartAsync is implicitly called when the forge implementation starts, see DefaultForge for more information. ExampleSettings Holds configuration settings for the ExampleShard. You can declare everything may be useful to customize the behavior of the shard by configuration, in this simple example we have few properties 1 2 3 4 5 6 7 8 public class ExampleSettings : MithrilShardSettingsBase { const long DEFAULT_MAX_TIME_ADJUSTMENT = 70 * 60 ; public long MaxTimeAdjustment { get ; set ; } = DEFAULT_MAX_TIME_ADJUSTMENT ; public List < ExampleClientPeerBinding > Connections { get ; } = new List < ExampleClientPeerBinding >(); } Connections parameter is a list of ExampleClientPeerBinding instances that has been added to show how to define and use complex classes within a configuration settings class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /// <summary> /// Client Peer endpoint the node would like to be connected to. /// </summary> public class ExampleClientPeerBinding { /// <summary>IP address and port number of the peer we wants to connect to.</summary> [IPEndPointValidator] [Required] public string? EndPoint { get ; set ; } public string? AdditionalInformation { get ; set ; } public bool TryGetExampleEndPoint ([ MaybeNullWhen ( false )] out ExampleEndPoint endPoint ) { endPoint = null ; if (! IPEndPoint . TryParse ( EndPoint ?? string . Empty , out IPEndPoint ? ipEndPoint )) { return false ; } if ( AdditionalInformation == null ) { return false ; } endPoint = new ExampleEndPoint ( ipEndPoint . Address , ipEndPoint . Port , AdditionalInformation ); return true ; } } Validating settings ExampleClientPeerBinding class has an EndPoint property that represents the endpoint (IP:Address) of a remote node we'd like to connect to and it's decorated with attributes that are used to validate the configuration during the initialization of the forge. Validation of the settings make use of System.ComponentModel.DataAnnotations and RequiredAttribute used in the example is one of those attribute that belongs to standard set. A different story is [IPEndPointValidator]: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /// <summary> /// Ensure the value is a valid IPEndPoint. /// Null value is considered valid, use <see cref=\"RequiredAttribute\"/> if you don't want to allow null values. /// </summary> /// <seealso cref=\"System.ComponentModel.DataAnnotations.ValidationAttribute\" /> [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = true)] public class IPEndPointValidator : ValidationAttribute { protected override ValidationResult ? IsValid ( object? value , ValidationContext validationContext ) { if ( value is null ) return ValidationResult . Success ; string instance = value as string ?? string . Empty ; if (! IPEndPoint . TryParse ( instance , out IPEndPoint ? _ )) { return new ValidationResult ( $ \"Not a valid EndPoint ({instance})\" , new string [] { validationContext . MemberName ! }); } return ValidationResult . Success ; } } This is a concrete example about how to perform validation for custom settings when default validation attributes aren't enough. Tip Validating settings is important because would stop the node during the forge build process if some settings aren't properly configured, for example if the settings file is malformed or instead of an expected endpoint like in this case, the user specify an incorrect endpoint string. Having a sanity check during validation, allows you to write simpler code when you make use of the setting file, because you can be assured that the values are correct. Configuration file To populate ExampleSettings file by using a json configuration file, we have to add Example section in your application configuration file 1 2 3 4 5 6 7 8 9 \"Example\" : { \"MaxTimeAdjustment\" : 4200 , \"Connections\" : [ { \"Endpoint\" : \"127.0.0.1:45061\" , \"AdditionalInformation\" : \"I'm cool!\" } ] } Important By inheriting a setting class from [MithrilShardSettingsBase], the section name to specify in the json file is the name of the setting class without the suffix \" Settings \". ExampleSettings becomes then Example. You can override this behavior by overriding ConfigurationSection property in your settings file. IQuoteService This interface (and its QuoteService implementation) is an example of a service used within the example application to provide a random quote to send as a message to our pong reply. It's definition is purposely simple: 1 2 3 4 5 6 public interface IQuoteService { List < string > Quotes { get ; } string GetRandomQuote (); } Warning In a proper application you wouldn't want to expose directly a list of quotes but rather expose methods like GetQuotes, AddQuote, RemoveQuote, anyway this example goal is to showcase Mithril Shards library and not to teach about how properly write your services classes. QuoteService implementation simply initialize a list of quotes (from The Lord of the Rings movies and books!), exposes the resulting list as a property that can be updated and a method GetRandomQuote to return a random quote from the available quotes. Tip As a further excercise you could try to implement a persistence layer for QuoteService, or a complete different implementation and then replace default QuoteService registration with your own! ServerPeerConnectionGuardBase This class implements the interface [IServerPeerConnectionGuard] whose purpose is to validate an incoming connection before we attempt to handshake and exchange information with it. It's an abstract class and its purpose is to implement generic useful code to be used by concrete peer guard implementations in such a way that guard implementation has just to focus on the guarding rule. Currently the example implements two guards: MaxConnectionThresholdGuard makes use of ForgeConnectivitySettings to ensure that the number of incoming transaction doesn't exceeds the MaxInboundConnections settings value. BannedPeerGuard ensures that the connecting node isn't flagged as banned in our IPeerAddressBook. Actually it's not honored because the default IPeerAddressBook implementation ( DefaultPeerAddressBook ) is a fake implementation that just log messages but does nothing. As a reference, this is the MaxConnectionThresholdGuard implementation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MaxConnectionThresholdGuard : ServerPeerConnectionGuardBase { readonly IConnectivityPeerStats _peerStats ; public MaxConnectionThresholdGuard ( ILogger < MaxConnectionThresholdGuard > logger , IOptions < ForgeConnectivitySettings > settings , IConnectivityPeerStats serverPeerStats ) : base ( logger , settings ) { _peerStats = serverPeerStats ; } internal override string? TryGetDenyReason ( IPeerContext peerContext ) { if ( _peerStats . ConnectedInboundPeersCount >= settings . MaxInboundConnections ) { return \"Inbound connection refused: max connection threshold reached.\" ; } return null ; } } ExampleRequiredConnection This class implements [IConnector], extending ConnectorBase abstract class. A RequiredConnection connector is already implemented and added by default when we build a forge, this example shows how you can override default registered services with a custom implementation: ExampleRequiredConnection is meant to replace RequiredConnection. By default, to instruct our node to try to connect to specific remote nodes, we can specify these endpoints in ForgeConnectivitySettings Connections property and the RequiredConnection connector will attempt to connect to the specified nodes automatically but since we have our custom list of remote endpoints defined in our ExampleSettings Connections property, we want to use that list instead. Info Check ReplaceServices method in ForgeBuilderExtensions.cs class to see how service replacement is performed. Protocol Messages Of course in a P2P example application we have to talk with other peers, so we need messages to exchange! In this example we implemented four messages: two for the handshake process (borrowed by bitcoin protocol), namely VerackMessage and VersionMessage and two to implement the ping pong logic: PingMessage and PongMessage . Let's just examine one of them and lets pick the one that contains a complex type that has to be serialized over the network. PongMessage 1 2 3 4 5 6 7 8 [NetworkMessage(COMMAND)] public sealed class PongMessage : INetworkMessage { private const string COMMAND = \"pong\" ; string INetworkMessage . Command => COMMAND ; public PongFancyResponse ? PongFancyResponse { get ; set ; } } A message has to implement [INetworkMessage] interface and be decorated with the [NetworkMessageAttribute] in order to be serialized by the [NetworkMessageSerializerManager]. Since the message name, exposed by the Command property, is used both as the return value of the property and as the parameter passed to the NetworkMessageAttribute, a private const string is used to prevent manual errors when creating a new message: just edit the message name in one place. The PongMessage payload just contains one serialized property, PongFancyResponse, and the PongMessageSerializer will show how to serialize this complex type. PongFancyResponse This type represent a complex type that is serialized when we send a PongMessage to a peer. We could have added the property that this type contains, straight into the PongMessage class but since this example project has the goal to showcase Mithril Shards features, having a complex type is useful to describe the process needed to handle such scenarios. The class itself is a simple POCO class (it's POCO by choice but it's not mandatory to be so, you can use any kind of class, as long as you implement a serializer for that specific type) 1 2 3 4 5 6 7 8 9 public class PongFancyResponse { /// <summary> /// The nonce received from the ping request. /// </summary> public ulong Nonce { get ; set ; } public string? Quote { get ; set ; } } Nonce is a simple unsigned long value that's used to link a pong response to a ping request, just returning back the ping Nonce value, while Quote is a nullable string that contains the Quote generated by the node sending the PongMessage. Note Projects within Mithril Shards solution make use of nullable references types and proper .editorconfig configuration to raise warning and exceptions in multiple scenarios and proudly have a 0 warning build (most of the time ). Protocol Messages Serializers Like for messages, their serializer has to implement an interface, in this case to follow DRY, a base generic class ExampleNetworkMessageSerializerBase<TMessage> is implemented that acts just as placeholder because it contains no code except an empty method and some comments, that explain how doing so you can expand a serializer by having a custom [IPeerContext] like in this example and some helper methods you may find useful in your implementation. Usually you have one message serializer for each message you have, so in this case we have four message serializers: VersionMessageSerializer, VerackMessageSerializer, PingMessageSerializer and PongMessageSerializer. PongMessageSerializer Since we have already described the PongMessage in details, makes sense to explain its serializer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /// <summary> /// PongMessage serializer, used to serialize and send through the network a <see cref=\"PongMessage\"/> /// </summary> /// <seealso cref=\"ExampleNetworkMessageSerializerBase{PongMessage}\" /> public class PongMessageSerializer : ExampleNetworkMessageSerializerBase < PongMessage > { readonly IProtocolTypeSerializer < PongFancyResponse > _pongFancyResponseSerializator ; public PongMessageSerializer ( IProtocolTypeSerializer < PongFancyResponse > pongFancyResponseSerializator ) { /// since the pong message has a complex type that can be reused in other payload (well, /// this is specific to pong but you get the idea) we are implementing a custom /// type serializer and inject it into this message serializer _pongFancyResponseSerializator = pongFancyResponseSerializator ; } public override void Serialize ( PongMessage message , int protocolVersion , ExamplePeerContext peerContext , IBufferWriter < byte > output ) { output . WriteWithSerializer ( message . PongFancyResponse !, protocolVersion , _pongFancyResponseSerializator ); } public override PongMessage Deserialize ( ref SequenceReader < byte > reader , int protocolVersion , ExamplePeerContext peerContext ) { return new PongMessage { PongFancyResponse = reader . ReadWithSerializer ( protocolVersion , _pongFancyResponseSerializator ) }; } } What to highlight in this code is: PongMessageSerializer declares it's a serializer for the PongMessage by extending ExampleNetworkMessageSerializerBase<PongMessage> (note that the generic type argument is PongMessage) It's constructor accepts a IProtocolTypeSerializer<PongFancyResponse> pongFancyResponseSerializator , this will be injected automatically by the DI container when the serializer is resolved and it will be used to serialize the complex type PongFancyResponse. Later we'll see the PongFancyResponseSerializer that will be used, note how actually we ask for a IProtocolTypeSerializer and at runtime our serializer PongFancyResponseSerializer will be used, no need to worry about knowing the real implementation of our serializer, we can even change it at runtime or using a custom feature that changes serializers, that's the power of abstraction ! We have to implement Serialize and Deserialize methods and in this example we are just relying on the extension WriteWithSerializer and ReadWithSerializer , nothing easier than that. If we had other primitive types to serialize, like an integer property, we had just to use the proper IBufferWriter<byte> primitive extension WriteInt (to serialize) and SequenceReader<byte> ReadInt primitive extension (to read). Info You are encouraged to check source code: IBufferWriterExtensions.cs and SequenceReaderExtensions.cs classes contains all the primitive extensions to serialize primitive types and helper to leverage the use of IProtocolTypeSerializer used to serialize complex types. Protocol Types Serializers When a message contains a complex type like our PongFancyResponse type, we can make use of IProtocolTypeSerializer implementations. In our example we have the PongFancryResponseSerializer class that we can study 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class PongFancyResponseSerializer : IProtocolTypeSerializer < PongFancyResponse > { public int Serialize ( PongFancyResponse typeInstance , int protocolVersion , IBufferWriter < byte > writer , ProtocolTypeSerializerOptions ? options = null ) { int size = 0 ; size += writer . WriteULong ( typeInstance . Nonce ); size += writer . WriteVarString ( typeInstance . Quote ); return size ; } public PongFancyResponse Deserialize ( ref SequenceReader < byte > reader , int protocolVersion , ProtocolTypeSerializerOptions ? options = null ) { return new PongFancyResponse { Nonce = reader . ReadULong (), Quote = reader . ReadVarString () }; } } The logic is similar to message serializer, we have to implement the interface IProtocolTypeSerializer<TComplextype> that requires us to implement the Serialize and Deserialize method. In this specific example we can see how an unsigned long and a nullable string are serialized in our protocol implementaiton. Tip IProtocolTypeSerializer implementations can inject other IProtocolTypeSerializer implementations if they include other complex types. Processors Processors are fundamental classes that allow us to react to incoming messages. Mithril Shards has a clever way to handle messages: whenever a stream of data arrives, it gets read to see if it represents a known messages and if it's the case, all the processors that are registered as interested in that particular message are activated. Technically it's like a publish-subscribe pattern but it's transparent for the developer, everything it's handled by following conventions and implementing specific classes. Processors are attached to a peer context by the Mithril Shards core class NetworkMessageProcessorFactory, their lifetime scope is defined as Transient, this mean that each peer context has its own processor instance attached (processors aren't mean to natively share data between peers but you can anyway create a singleton service that inject in the processor to do so). In our example, an abstract BaseProcessor class implements the code to deal with common needs, it has a lot of helper methods that allow you to subscribe and unsubscribe to event bus messages, react to peer handshake, send messages, execute conditional statement asynchronously and much more (check out the BaseProcess.cs file). Processors can be quite complex, in this example PingPongProcessor is quite simple but still contains useful snippets that you can learn and use. PingPongProcessor To shed some light on this, let's inspect the PingPongProcessor, whose goal is to process incoming ping requests and reply with pong messages, or generate ping messages after a certain period of time that has elapsed (it's not meant to be an optimized protocol, in such case you'd want to ping only if you don't receive data from the peer for a certain time, but the goal is to keep the example simple in logic but exhaustive as implementation). Declaration This time I'm not including the full class source code but just meaningful snippets, let's start from the declaration: 1 2 3 public partial class PingPongProcessor : BaseProcessor , INetworkMessageHandler < PingMessage >, INetworkMessageHandler < PongMessage > PingPongProcessor inherits from BaseProcessor and is declared as a partial class, because its internal status is declared as an inner class and defined into a nested file PingProcessor.Status.cs. This allow us to restrict Status scope while keeping our source more compact. In visual studio the inner file is shown as a child of the PingProngProcessor.cs as you can see. It also implements two interfaces: INetworkMessageHandler<PingMessage> and INetworkMessageHandler<PongMessage> . Implementing INetworkMessageHandler generic interface is a way to instruct the Mithril Shards framework that this processor is interested in handling incoming PingMessage and PongMessage. Declarative syntax like this allow us to maintain better our code when we have several processors and allow us to have a better control over which process elaborates which messages without much effort. Constructor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public PingPongProcessor ( ILogger < PingPongProcessor > logger , IEventBus eventBus , IPeerBehaviorManager peerBehaviorManager , IRandomNumberGenerator randomNumberGenerator , IDateTimeProvider dateTimeProvider , IPeriodicWork periodicPing , IQuoteService quoteService ) : base ( logger , eventBus , peerBehaviorManager , isHandshakeAware : true , receiveMessagesOnlyIfHandshaked : true ) { _randomNumberGenerator = randomNumberGenerator ; _dateTimeProvider = dateTimeProvider ; _periodicPing = periodicPing ; _quoteService = quoteService ; } The constructor declares which services we need and calls the base constructor passing its needed services. I'd emphasize the last 2 base constructor parameter that I've specified by using named arguments to better show their meaning: isHandshakeAware: true, receiveMessagesOnlyIfHandshaked: true Specifying true to isHandshakeAware means that the processor is handshake aware and when our peer handshake correctly with a remote peer, OnPeerHandshakedAsync method is invoked. In our example we uses this information to start a periodic task that ensures that we send a ping request every PING_INTERVAL amount of time 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 protected override ValueTask OnPeerHandshakedAsync () { _ = _periodicPing . StartAsync ( label : $ \"{nameof(_periodicPing)}-{PeerContext.PeerId}\" , work : PingAsync , interval : TimeSpan . FromSeconds ( PING_INTERVAL ), cancellation : PeerContext . ConnectionCancellationTokenSource . Token ); return default ; } private async Task PingAsync ( CancellationToken cancellationToken ) { var ping = new PingMessage (); ping . Nonce = _randomNumberGenerator . GetUint64 (); await SendMessageAsync ( ping ). ConfigureAwait ( false ); _status . PingSent ( _dateTimeProvider . GetTimeMicros (), ping ); logger . LogDebug ( \"Sent ping request with nonce {PingNonce}\" , _status . PingRequestNonce ); //in case of memory leak, investigate this. _pingCancellationTokenSource = CancellationTokenSource . CreateLinkedTokenSource ( cancellationToken ); // ensures the handshake is performed timely await DisconnectIfAsync (() => { return new ValueTask < bool >( _status . PingResponseTime == 0 ); }, TimeSpan . FromSeconds ( TIMEOUT_INTERVAL ), \"Pong not received in time\" , _pingCancellationTokenSource . Token ). ConfigureAwait ( false ); } The call to DisconnectIfAsync within PingAsync method, ensures that if the other peers doesn't reply to us with a proper pong messages, we disconnect from the remote peer. The action passed to DisconnectIfAsync gets evaluated when the time specified by TimeSpan.FromSeconds(TIMEOUT_INTERVAL) elapses. Current status of our processor is held in the inner Status class, when we call its PingSent we are resetting the PingResponseTime to 0. When we receive a pong message PingResponseTime is set to a value and thus when the timeout elapses we are expected to find a value if the peer replied, or 0 if it didn't (and thus disconnect the peer). Warning This logic to works requires that TIMEOUT_INTERVAL is lower than PING_INTERVAL. Handling the PingMessage As we saw earlier, we declared that the class was implementing INetworkMessageHandler , this mean that we have to implement its ProcessMessageAsync where we can put our logic to handle the ping message: 1 2 3 4 5 6 7 8 9 10 11 12 13 async ValueTask < bool > INetworkMessageHandler < PingMessage >. ProcessMessageAsync ( PingMessage message , CancellationToken cancellation ) { await SendMessageAsync ( new PongMessage { PongFancyResponse = new PongFancyResponse { Nonce = message . Nonce , Quote = _quoteService . GetRandomQuote () } }). ConfigureAwait ( false ); return true ; } This method is pretty simple, it just sends an async PongMessage, returning the original ping Nonce and a random quote picked from the IQuoteService implementation. Note In this example, ProcessMessageAsync has been implemented as an explicit implementation of the interface , this allows us to hide these methods from the publicly available methods of the type. Handling the PongMessage Similarly to the PingMessage handler, we implements PongMessage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ValueTask < bool > INetworkMessageHandler < PongMessage >. ProcessMessageAsync ( PongMessage message , CancellationToken cancellation ) { if ( _status . PingRequestNonce != 0 && message . PongFancyResponse ?. Nonce == _status . PingRequestNonce ) { ( ulong Nonce , long RoundTrip ) = _status . PongReceived ( _dateTimeProvider . GetTimeMicros ()); logger . LogDebug ( \"Received pong with nonce {PingNonce} in {PingRoundTrip} usec. {Quote}\" , Nonce , RoundTrip , message . PongFancyResponse . Quote ); _pingCancellationTokenSource . Cancel (); } else { logger . LogDebug ( \"Received pong with wrong nonce: {PingNonce}\" , _status . PingRequestNonce ); } return new ValueTask < bool >( true ); } In this method we check that the returned Nonce is the same of our last ping request, if so we update our internal status to signal that we received the pong message. Add the shard into the forge To add the shard to the forge, the [IForgeBuilder] extension UseExample in ForgeBuilderExtensions class has to be used, here what it does: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /// <summary> /// Inject the Example shard. /// </summary> /// <param name=\"forgeBuilder\">The forge builder.</param> /// <param name=\"minimumSupportedVersion\">The minimum version local nodes requires in order to connect to other peers.</param> /// <param name=\"currentVersion\">The current version local peer aim to use with connected peers.</param> /// <returns></returns> public static IForgeBuilder UseExample ( this IForgeBuilder forgeBuilder , int minimumSupportedVersion , int currentVersion ) { if ( forgeBuilder is null ) throw new ArgumentNullException ( nameof ( forgeBuilder )); forgeBuilder . AddShard < ExampleShard , ExampleSettings >( ( hostBuildContext , services ) => { services . AddSingleton ( new NodeImplementation ( minimumSupportedVersion , currentVersion )) . AddSingleton < IDateTimeProvider , DateTimeProvider >() . AddSingleton < IQuoteService , QuoteService >() . AddPeerGuards () . AddMessageSerializers () . AddProtocolTypeSerializers () . AddMessageProcessors () . ReplaceServices (); }); return forgeBuilder ; } As you can see it makes use of AddShard method to register the ExampleShard and specify its settings ( ExampleSettings ). AddShards exposes an action where you can leverage to register custom services, like in this case IDateTimeProvider, IQuoteService and a lot more. This is a very important aspect because allows you Tip While it's possible to add all service within the AddShard action parameter, I encourage you to split registrations based on their scope and responsibility, like in the example above, it allows you to have a better code base that's easier to manage. You can check the ForgeBuilderExtensions.cs file in MithrilShards.Example project to see all services registered, for example AddPeerGuards is a method in the same file that adds some [IServerPeerConnectionGuard]). AddMessageSerializers and AddProtocolTypeSerializers are two interesting methods that use reflection to automatically register all [INetworkMessageSerializer] and [IProtocolTypeSerializer] defined in this class without having to manually register each one.", "title": "MithrilShards.Example"}, {"location": "example-projects/mithril-shards-example/#main-classes", "text": "In the following sections we are going to dissect the project to expose and study the main classes implemented in the project.", "title": "Main classes"}, {"location": "example-projects/mithril-shards-example/#exampleshard", "text": "This class represents the core Example Shard, actually it doesn't contains any code but you could extend this example to start for example an async task when the shard starts ( StartAsync method) and stop it when it stops ( StopAsync method). Note that a shard StartAsync is implicitly called when the forge implementation starts, see DefaultForge for more information.", "title": "ExampleShard"}, {"location": "example-projects/mithril-shards-example/#examplesettings", "text": "Holds configuration settings for the ExampleShard. You can declare everything may be useful to customize the behavior of the shard by configuration, in this simple example we have few properties 1 2 3 4 5 6 7 8 public class ExampleSettings : MithrilShardSettingsBase { const long DEFAULT_MAX_TIME_ADJUSTMENT = 70 * 60 ; public long MaxTimeAdjustment { get ; set ; } = DEFAULT_MAX_TIME_ADJUSTMENT ; public List < ExampleClientPeerBinding > Connections { get ; } = new List < ExampleClientPeerBinding >(); } Connections parameter is a list of ExampleClientPeerBinding instances that has been added to show how to define and use complex classes within a configuration settings class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /// <summary> /// Client Peer endpoint the node would like to be connected to. /// </summary> public class ExampleClientPeerBinding { /// <summary>IP address and port number of the peer we wants to connect to.</summary> [IPEndPointValidator] [Required] public string? EndPoint { get ; set ; } public string? AdditionalInformation { get ; set ; } public bool TryGetExampleEndPoint ([ MaybeNullWhen ( false )] out ExampleEndPoint endPoint ) { endPoint = null ; if (! IPEndPoint . TryParse ( EndPoint ?? string . Empty , out IPEndPoint ? ipEndPoint )) { return false ; } if ( AdditionalInformation == null ) { return false ; } endPoint = new ExampleEndPoint ( ipEndPoint . Address , ipEndPoint . Port , AdditionalInformation ); return true ; } }", "title": "ExampleSettings"}, {"location": "example-projects/mithril-shards-example/#validating-settings", "text": "ExampleClientPeerBinding class has an EndPoint property that represents the endpoint (IP:Address) of a remote node we'd like to connect to and it's decorated with attributes that are used to validate the configuration during the initialization of the forge. Validation of the settings make use of System.ComponentModel.DataAnnotations and RequiredAttribute used in the example is one of those attribute that belongs to standard set. A different story is [IPEndPointValidator]: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /// <summary> /// Ensure the value is a valid IPEndPoint. /// Null value is considered valid, use <see cref=\"RequiredAttribute\"/> if you don't want to allow null values. /// </summary> /// <seealso cref=\"System.ComponentModel.DataAnnotations.ValidationAttribute\" /> [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = true)] public class IPEndPointValidator : ValidationAttribute { protected override ValidationResult ? IsValid ( object? value , ValidationContext validationContext ) { if ( value is null ) return ValidationResult . Success ; string instance = value as string ?? string . Empty ; if (! IPEndPoint . TryParse ( instance , out IPEndPoint ? _ )) { return new ValidationResult ( $ \"Not a valid EndPoint ({instance})\" , new string [] { validationContext . MemberName ! }); } return ValidationResult . Success ; } } This is a concrete example about how to perform validation for custom settings when default validation attributes aren't enough. Tip Validating settings is important because would stop the node during the forge build process if some settings aren't properly configured, for example if the settings file is malformed or instead of an expected endpoint like in this case, the user specify an incorrect endpoint string. Having a sanity check during validation, allows you to write simpler code when you make use of the setting file, because you can be assured that the values are correct.", "title": "Validating settings"}, {"location": "example-projects/mithril-shards-example/#configuration-file", "text": "To populate ExampleSettings file by using a json configuration file, we have to add Example section in your application configuration file 1 2 3 4 5 6 7 8 9 \"Example\" : { \"MaxTimeAdjustment\" : 4200 , \"Connections\" : [ { \"Endpoint\" : \"127.0.0.1:45061\" , \"AdditionalInformation\" : \"I'm cool!\" } ] } Important By inheriting a setting class from [MithrilShardSettingsBase], the section name to specify in the json file is the name of the setting class without the suffix \" Settings \". ExampleSettings becomes then Example. You can override this behavior by overriding ConfigurationSection property in your settings file.", "title": "Configuration file"}, {"location": "example-projects/mithril-shards-example/#iquoteservice", "text": "This interface (and its QuoteService implementation) is an example of a service used within the example application to provide a random quote to send as a message to our pong reply. It's definition is purposely simple: 1 2 3 4 5 6 public interface IQuoteService { List < string > Quotes { get ; } string GetRandomQuote (); } Warning In a proper application you wouldn't want to expose directly a list of quotes but rather expose methods like GetQuotes, AddQuote, RemoveQuote, anyway this example goal is to showcase Mithril Shards library and not to teach about how properly write your services classes. QuoteService implementation simply initialize a list of quotes (from The Lord of the Rings movies and books!), exposes the resulting list as a property that can be updated and a method GetRandomQuote to return a random quote from the available quotes. Tip As a further excercise you could try to implement a persistence layer for QuoteService, or a complete different implementation and then replace default QuoteService registration with your own!", "title": "IQuoteService"}, {"location": "example-projects/mithril-shards-example/#serverpeerconnectionguardbase", "text": "This class implements the interface [IServerPeerConnectionGuard] whose purpose is to validate an incoming connection before we attempt to handshake and exchange information with it. It's an abstract class and its purpose is to implement generic useful code to be used by concrete peer guard implementations in such a way that guard implementation has just to focus on the guarding rule. Currently the example implements two guards: MaxConnectionThresholdGuard makes use of ForgeConnectivitySettings to ensure that the number of incoming transaction doesn't exceeds the MaxInboundConnections settings value. BannedPeerGuard ensures that the connecting node isn't flagged as banned in our IPeerAddressBook. Actually it's not honored because the default IPeerAddressBook implementation ( DefaultPeerAddressBook ) is a fake implementation that just log messages but does nothing. As a reference, this is the MaxConnectionThresholdGuard implementation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MaxConnectionThresholdGuard : ServerPeerConnectionGuardBase { readonly IConnectivityPeerStats _peerStats ; public MaxConnectionThresholdGuard ( ILogger < MaxConnectionThresholdGuard > logger , IOptions < ForgeConnectivitySettings > settings , IConnectivityPeerStats serverPeerStats ) : base ( logger , settings ) { _peerStats = serverPeerStats ; } internal override string? TryGetDenyReason ( IPeerContext peerContext ) { if ( _peerStats . ConnectedInboundPeersCount >= settings . MaxInboundConnections ) { return \"Inbound connection refused: max connection threshold reached.\" ; } return null ; } }", "title": "ServerPeerConnectionGuardBase"}, {"location": "example-projects/mithril-shards-example/#examplerequiredconnection", "text": "This class implements [IConnector], extending ConnectorBase abstract class. A RequiredConnection connector is already implemented and added by default when we build a forge, this example shows how you can override default registered services with a custom implementation: ExampleRequiredConnection is meant to replace RequiredConnection. By default, to instruct our node to try to connect to specific remote nodes, we can specify these endpoints in ForgeConnectivitySettings Connections property and the RequiredConnection connector will attempt to connect to the specified nodes automatically but since we have our custom list of remote endpoints defined in our ExampleSettings Connections property, we want to use that list instead. Info Check ReplaceServices method in ForgeBuilderExtensions.cs class to see how service replacement is performed.", "title": "ExampleRequiredConnection"}, {"location": "example-projects/mithril-shards-example/#protocol-messages", "text": "Of course in a P2P example application we have to talk with other peers, so we need messages to exchange! In this example we implemented four messages: two for the handshake process (borrowed by bitcoin protocol), namely VerackMessage and VersionMessage and two to implement the ping pong logic: PingMessage and PongMessage . Let's just examine one of them and lets pick the one that contains a complex type that has to be serialized over the network.", "title": "Protocol Messages"}, {"location": "example-projects/mithril-shards-example/#pongmessage", "text": "1 2 3 4 5 6 7 8 [NetworkMessage(COMMAND)] public sealed class PongMessage : INetworkMessage { private const string COMMAND = \"pong\" ; string INetworkMessage . Command => COMMAND ; public PongFancyResponse ? PongFancyResponse { get ; set ; } } A message has to implement [INetworkMessage] interface and be decorated with the [NetworkMessageAttribute] in order to be serialized by the [NetworkMessageSerializerManager]. Since the message name, exposed by the Command property, is used both as the return value of the property and as the parameter passed to the NetworkMessageAttribute, a private const string is used to prevent manual errors when creating a new message: just edit the message name in one place. The PongMessage payload just contains one serialized property, PongFancyResponse, and the PongMessageSerializer will show how to serialize this complex type.", "title": "PongMessage"}, {"location": "example-projects/mithril-shards-example/#pongfancyresponse", "text": "This type represent a complex type that is serialized when we send a PongMessage to a peer. We could have added the property that this type contains, straight into the PongMessage class but since this example project has the goal to showcase Mithril Shards features, having a complex type is useful to describe the process needed to handle such scenarios. The class itself is a simple POCO class (it's POCO by choice but it's not mandatory to be so, you can use any kind of class, as long as you implement a serializer for that specific type) 1 2 3 4 5 6 7 8 9 public class PongFancyResponse { /// <summary> /// The nonce received from the ping request. /// </summary> public ulong Nonce { get ; set ; } public string? Quote { get ; set ; } } Nonce is a simple unsigned long value that's used to link a pong response to a ping request, just returning back the ping Nonce value, while Quote is a nullable string that contains the Quote generated by the node sending the PongMessage. Note Projects within Mithril Shards solution make use of nullable references types and proper .editorconfig configuration to raise warning and exceptions in multiple scenarios and proudly have a 0 warning build (most of the time ).", "title": "PongFancyResponse"}, {"location": "example-projects/mithril-shards-example/#protocol-messages-serializers", "text": "Like for messages, their serializer has to implement an interface, in this case to follow DRY, a base generic class ExampleNetworkMessageSerializerBase<TMessage> is implemented that acts just as placeholder because it contains no code except an empty method and some comments, that explain how doing so you can expand a serializer by having a custom [IPeerContext] like in this example and some helper methods you may find useful in your implementation. Usually you have one message serializer for each message you have, so in this case we have four message serializers: VersionMessageSerializer, VerackMessageSerializer, PingMessageSerializer and PongMessageSerializer.", "title": "Protocol Messages Serializers"}, {"location": "example-projects/mithril-shards-example/#pongmessageserializer", "text": "Since we have already described the PongMessage in details, makes sense to explain its serializer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /// <summary> /// PongMessage serializer, used to serialize and send through the network a <see cref=\"PongMessage\"/> /// </summary> /// <seealso cref=\"ExampleNetworkMessageSerializerBase{PongMessage}\" /> public class PongMessageSerializer : ExampleNetworkMessageSerializerBase < PongMessage > { readonly IProtocolTypeSerializer < PongFancyResponse > _pongFancyResponseSerializator ; public PongMessageSerializer ( IProtocolTypeSerializer < PongFancyResponse > pongFancyResponseSerializator ) { /// since the pong message has a complex type that can be reused in other payload (well, /// this is specific to pong but you get the idea) we are implementing a custom /// type serializer and inject it into this message serializer _pongFancyResponseSerializator = pongFancyResponseSerializator ; } public override void Serialize ( PongMessage message , int protocolVersion , ExamplePeerContext peerContext , IBufferWriter < byte > output ) { output . WriteWithSerializer ( message . PongFancyResponse !, protocolVersion , _pongFancyResponseSerializator ); } public override PongMessage Deserialize ( ref SequenceReader < byte > reader , int protocolVersion , ExamplePeerContext peerContext ) { return new PongMessage { PongFancyResponse = reader . ReadWithSerializer ( protocolVersion , _pongFancyResponseSerializator ) }; } } What to highlight in this code is: PongMessageSerializer declares it's a serializer for the PongMessage by extending ExampleNetworkMessageSerializerBase<PongMessage> (note that the generic type argument is PongMessage) It's constructor accepts a IProtocolTypeSerializer<PongFancyResponse> pongFancyResponseSerializator , this will be injected automatically by the DI container when the serializer is resolved and it will be used to serialize the complex type PongFancyResponse. Later we'll see the PongFancyResponseSerializer that will be used, note how actually we ask for a IProtocolTypeSerializer and at runtime our serializer PongFancyResponseSerializer will be used, no need to worry about knowing the real implementation of our serializer, we can even change it at runtime or using a custom feature that changes serializers, that's the power of abstraction ! We have to implement Serialize and Deserialize methods and in this example we are just relying on the extension WriteWithSerializer and ReadWithSerializer , nothing easier than that. If we had other primitive types to serialize, like an integer property, we had just to use the proper IBufferWriter<byte> primitive extension WriteInt (to serialize) and SequenceReader<byte> ReadInt primitive extension (to read). Info You are encouraged to check source code: IBufferWriterExtensions.cs and SequenceReaderExtensions.cs classes contains all the primitive extensions to serialize primitive types and helper to leverage the use of IProtocolTypeSerializer used to serialize complex types.", "title": "PongMessageSerializer"}, {"location": "example-projects/mithril-shards-example/#protocol-types-serializers", "text": "When a message contains a complex type like our PongFancyResponse type, we can make use of IProtocolTypeSerializer implementations. In our example we have the PongFancryResponseSerializer class that we can study 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class PongFancyResponseSerializer : IProtocolTypeSerializer < PongFancyResponse > { public int Serialize ( PongFancyResponse typeInstance , int protocolVersion , IBufferWriter < byte > writer , ProtocolTypeSerializerOptions ? options = null ) { int size = 0 ; size += writer . WriteULong ( typeInstance . Nonce ); size += writer . WriteVarString ( typeInstance . Quote ); return size ; } public PongFancyResponse Deserialize ( ref SequenceReader < byte > reader , int protocolVersion , ProtocolTypeSerializerOptions ? options = null ) { return new PongFancyResponse { Nonce = reader . ReadULong (), Quote = reader . ReadVarString () }; } } The logic is similar to message serializer, we have to implement the interface IProtocolTypeSerializer<TComplextype> that requires us to implement the Serialize and Deserialize method. In this specific example we can see how an unsigned long and a nullable string are serialized in our protocol implementaiton. Tip IProtocolTypeSerializer implementations can inject other IProtocolTypeSerializer implementations if they include other complex types.", "title": "Protocol Types Serializers"}, {"location": "example-projects/mithril-shards-example/#processors", "text": "Processors are fundamental classes that allow us to react to incoming messages. Mithril Shards has a clever way to handle messages: whenever a stream of data arrives, it gets read to see if it represents a known messages and if it's the case, all the processors that are registered as interested in that particular message are activated. Technically it's like a publish-subscribe pattern but it's transparent for the developer, everything it's handled by following conventions and implementing specific classes. Processors are attached to a peer context by the Mithril Shards core class NetworkMessageProcessorFactory, their lifetime scope is defined as Transient, this mean that each peer context has its own processor instance attached (processors aren't mean to natively share data between peers but you can anyway create a singleton service that inject in the processor to do so). In our example, an abstract BaseProcessor class implements the code to deal with common needs, it has a lot of helper methods that allow you to subscribe and unsubscribe to event bus messages, react to peer handshake, send messages, execute conditional statement asynchronously and much more (check out the BaseProcess.cs file). Processors can be quite complex, in this example PingPongProcessor is quite simple but still contains useful snippets that you can learn and use.", "title": "Processors"}, {"location": "example-projects/mithril-shards-example/#pingpongprocessor", "text": "To shed some light on this, let's inspect the PingPongProcessor, whose goal is to process incoming ping requests and reply with pong messages, or generate ping messages after a certain period of time that has elapsed (it's not meant to be an optimized protocol, in such case you'd want to ping only if you don't receive data from the peer for a certain time, but the goal is to keep the example simple in logic but exhaustive as implementation).", "title": "PingPongProcessor"}, {"location": "example-projects/mithril-shards-example/#declaration", "text": "This time I'm not including the full class source code but just meaningful snippets, let's start from the declaration: 1 2 3 public partial class PingPongProcessor : BaseProcessor , INetworkMessageHandler < PingMessage >, INetworkMessageHandler < PongMessage > PingPongProcessor inherits from BaseProcessor and is declared as a partial class, because its internal status is declared as an inner class and defined into a nested file PingProcessor.Status.cs. This allow us to restrict Status scope while keeping our source more compact. In visual studio the inner file is shown as a child of the PingProngProcessor.cs as you can see. It also implements two interfaces: INetworkMessageHandler<PingMessage> and INetworkMessageHandler<PongMessage> . Implementing INetworkMessageHandler generic interface is a way to instruct the Mithril Shards framework that this processor is interested in handling incoming PingMessage and PongMessage. Declarative syntax like this allow us to maintain better our code when we have several processors and allow us to have a better control over which process elaborates which messages without much effort.", "title": "Declaration"}, {"location": "example-projects/mithril-shards-example/#constructor", "text": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 public PingPongProcessor ( ILogger < PingPongProcessor > logger , IEventBus eventBus , IPeerBehaviorManager peerBehaviorManager , IRandomNumberGenerator randomNumberGenerator , IDateTimeProvider dateTimeProvider , IPeriodicWork periodicPing , IQuoteService quoteService ) : base ( logger , eventBus , peerBehaviorManager , isHandshakeAware : true , receiveMessagesOnlyIfHandshaked : true ) { _randomNumberGenerator = randomNumberGenerator ; _dateTimeProvider = dateTimeProvider ; _periodicPing = periodicPing ; _quoteService = quoteService ; } The constructor declares which services we need and calls the base constructor passing its needed services. I'd emphasize the last 2 base constructor parameter that I've specified by using named arguments to better show their meaning: isHandshakeAware: true, receiveMessagesOnlyIfHandshaked: true Specifying true to isHandshakeAware means that the processor is handshake aware and when our peer handshake correctly with a remote peer, OnPeerHandshakedAsync method is invoked. In our example we uses this information to start a periodic task that ensures that we send a ping request every PING_INTERVAL amount of time 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 protected override ValueTask OnPeerHandshakedAsync () { _ = _periodicPing . StartAsync ( label : $ \"{nameof(_periodicPing)}-{PeerContext.PeerId}\" , work : PingAsync , interval : TimeSpan . FromSeconds ( PING_INTERVAL ), cancellation : PeerContext . ConnectionCancellationTokenSource . Token ); return default ; } private async Task PingAsync ( CancellationToken cancellationToken ) { var ping = new PingMessage (); ping . Nonce = _randomNumberGenerator . GetUint64 (); await SendMessageAsync ( ping ). ConfigureAwait ( false ); _status . PingSent ( _dateTimeProvider . GetTimeMicros (), ping ); logger . LogDebug ( \"Sent ping request with nonce {PingNonce}\" , _status . PingRequestNonce ); //in case of memory leak, investigate this. _pingCancellationTokenSource = CancellationTokenSource . CreateLinkedTokenSource ( cancellationToken ); // ensures the handshake is performed timely await DisconnectIfAsync (() => { return new ValueTask < bool >( _status . PingResponseTime == 0 ); }, TimeSpan . FromSeconds ( TIMEOUT_INTERVAL ), \"Pong not received in time\" , _pingCancellationTokenSource . Token ). ConfigureAwait ( false ); } The call to DisconnectIfAsync within PingAsync method, ensures that if the other peers doesn't reply to us with a proper pong messages, we disconnect from the remote peer. The action passed to DisconnectIfAsync gets evaluated when the time specified by TimeSpan.FromSeconds(TIMEOUT_INTERVAL) elapses. Current status of our processor is held in the inner Status class, when we call its PingSent we are resetting the PingResponseTime to 0. When we receive a pong message PingResponseTime is set to a value and thus when the timeout elapses we are expected to find a value if the peer replied, or 0 if it didn't (and thus disconnect the peer). Warning This logic to works requires that TIMEOUT_INTERVAL is lower than PING_INTERVAL.", "title": "Constructor"}, {"location": "example-projects/mithril-shards-example/#handling-the-pingmessage", "text": "As we saw earlier, we declared that the class was implementing INetworkMessageHandler , this mean that we have to implement its ProcessMessageAsync where we can put our logic to handle the ping message: 1 2 3 4 5 6 7 8 9 10 11 12 13 async ValueTask < bool > INetworkMessageHandler < PingMessage >. ProcessMessageAsync ( PingMessage message , CancellationToken cancellation ) { await SendMessageAsync ( new PongMessage { PongFancyResponse = new PongFancyResponse { Nonce = message . Nonce , Quote = _quoteService . GetRandomQuote () } }). ConfigureAwait ( false ); return true ; } This method is pretty simple, it just sends an async PongMessage, returning the original ping Nonce and a random quote picked from the IQuoteService implementation. Note In this example, ProcessMessageAsync has been implemented as an explicit implementation of the interface , this allows us to hide these methods from the publicly available methods of the type.", "title": "Handling the PingMessage"}, {"location": "example-projects/mithril-shards-example/#handling-the-pongmessage", "text": "Similarly to the PingMessage handler, we implements PongMessage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ValueTask < bool > INetworkMessageHandler < PongMessage >. ProcessMessageAsync ( PongMessage message , CancellationToken cancellation ) { if ( _status . PingRequestNonce != 0 && message . PongFancyResponse ?. Nonce == _status . PingRequestNonce ) { ( ulong Nonce , long RoundTrip ) = _status . PongReceived ( _dateTimeProvider . GetTimeMicros ()); logger . LogDebug ( \"Received pong with nonce {PingNonce} in {PingRoundTrip} usec. {Quote}\" , Nonce , RoundTrip , message . PongFancyResponse . Quote ); _pingCancellationTokenSource . Cancel (); } else { logger . LogDebug ( \"Received pong with wrong nonce: {PingNonce}\" , _status . PingRequestNonce ); } return new ValueTask < bool >( true ); } In this method we check that the returned Nonce is the same of our last ping request, if so we update our internal status to signal that we received the pong message.", "title": "Handling the PongMessage"}, {"location": "example-projects/mithril-shards-example/#add-the-shard-into-the-forge", "text": "To add the shard to the forge, the [IForgeBuilder] extension UseExample in ForgeBuilderExtensions class has to be used, here what it does: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /// <summary> /// Inject the Example shard. /// </summary> /// <param name=\"forgeBuilder\">The forge builder.</param> /// <param name=\"minimumSupportedVersion\">The minimum version local nodes requires in order to connect to other peers.</param> /// <param name=\"currentVersion\">The current version local peer aim to use with connected peers.</param> /// <returns></returns> public static IForgeBuilder UseExample ( this IForgeBuilder forgeBuilder , int minimumSupportedVersion , int currentVersion ) { if ( forgeBuilder is null ) throw new ArgumentNullException ( nameof ( forgeBuilder )); forgeBuilder . AddShard < ExampleShard , ExampleSettings >( ( hostBuildContext , services ) => { services . AddSingleton ( new NodeImplementation ( minimumSupportedVersion , currentVersion )) . AddSingleton < IDateTimeProvider , DateTimeProvider >() . AddSingleton < IQuoteService , QuoteService >() . AddPeerGuards () . AddMessageSerializers () . AddProtocolTypeSerializers () . AddMessageProcessors () . ReplaceServices (); }); return forgeBuilder ; } As you can see it makes use of AddShard method to register the ExampleShard and specify its settings ( ExampleSettings ). AddShards exposes an action where you can leverage to register custom services, like in this case IDateTimeProvider, IQuoteService and a lot more. This is a very important aspect because allows you Tip While it's possible to add all service within the AddShard action parameter, I encourage you to split registrations based on their scope and responsibility, like in the example above, it allows you to have a better code base that's easier to manage. You can check the ForgeBuilderExtensions.cs file in MithrilShards.Example project to see all services registered, for example AddPeerGuards is a method in the same file that adds some [IServerPeerConnectionGuard]). AddMessageSerializers and AddProtocolTypeSerializers are two interesting methods that use reflection to automatically register all [INetworkMessageSerializer] and [IProtocolTypeSerializer] defined in this class without having to manually register each one.", "title": "Add the shard into the forge"}, {"location": "example-projects/running-example/", "text": "Running the example Running just an instance doesn't fully show you how the program behave, it needs at least 2 peers to connect to each other, that's why there are already multiple configuration files configured differently to let you connect two instances together. You can run one instance by setting MithrilShards.Example.Node as the startup project and run the launchSettings profile \"node1\" . Then open a shell at the MithrilShards.Example.Node project path and run the command below 1 dotnet run --no-build --settings forge-settings2.json This would cause you to have a debuggable instance running with the configuration defined in forge-settings.json file and another run running on the forge-settings2.json configuration. Alternatively you can run both instances, without a debugger (but you can attach later the process to Visual Studio) by running on two different shells: 1 2 dotnet run --no-build --settings forge-settings.json dotnet run --no-build --settings forge-settings2.json The program running forge-settings.json contains the most verbose log level and you'll have the best experience if you install (or use a docker image) of Seq configured on the port specified in your configuration file (e.g. localhost:5341). See SerilogShard for more details. Here an example of the configuration file (forge-settings.json) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 { \"ForgeConnectivity\" : { \"ForceShutdownAfter\" : 300 , \"MaxInboundConnections\" : 25 , \"AllowLoopbackConnection\" : false , \"Listeners\" : [ { \"IsWhitelistingEndpoint\" : true , \"Endpoint\" : \"0.0.0.0:45051\" }, { \"IsWhitelistingEndpoint\" : true , \"Endpoint\" : \"127.0.0.1:45052\" , \"PublicEndpoint\" : \"98.0.0.1:45011\" } ] }, \"Example\" : { \"MaxTimeAdjustment\" : 4200 , \"Connections\" : [ { \"Endpoint\" : \"127.0.0.1:45061\" , \"AdditionalInformation\" : \"I'm cool!\" } ] }, \"StatisticsCollector\" : { \"ContinuousConsoleDisplay\" : false , \"ContinuousConsoleDisplayRate\" : 5 }, \"DevController\" : { \"Enabled\" : true }, \"WebApi\" : { \"EndPoint\" : \"127.0.0.1:45020\" , \"Enabled\" : true , \"Https\" : false }, \"Serilog\" : { \"Using\" : [ \"Serilog.Sinks.Console\" , \"Serilog.Sinks.Seq\" ], \"Enrich\" : [ \"FromLogContext\" , \"WithMachineName\" , \"WithThreadId\" ], \"WriteTo\" : [ { \"Name\" : \"Console\" , \"Args\" : { \"IncludeScopes\" : true , \"theme\" : \"Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console\" } }, { \"Name\" : \"Seq\" , \"Args\" : { \"serverUrl\" : \"http://localhost:5341\" } } ], \"MinimumLevel\" : { \"Default\" : \"Debug\" , \"Override\" : { \"Bedrock.Framework\" : \"Warning\" , \"Microsoft\" : \"Warning\" , \"System\" : \"Warning\" } } } } Some Screenshots Here a screenshot that shows the content of the shell when running the node with settings = forge-settings.json You can access the Swagger UI by opening the address https://127.0.0.1:45020/docs/index.html Here you can manipulate quotes using the Web API , or even manually attempt to connect to other peers using PeerManagement Connect action in the DEV area. If you installed Seq, you can access the logs in a better way like shown here:", "title": "Running the example"}, {"location": "example-projects/running-example/#running-the-example", "text": "Running just an instance doesn't fully show you how the program behave, it needs at least 2 peers to connect to each other, that's why there are already multiple configuration files configured differently to let you connect two instances together. You can run one instance by setting MithrilShards.Example.Node as the startup project and run the launchSettings profile \"node1\" . Then open a shell at the MithrilShards.Example.Node project path and run the command below 1 dotnet run --no-build --settings forge-settings2.json This would cause you to have a debuggable instance running with the configuration defined in forge-settings.json file and another run running on the forge-settings2.json configuration. Alternatively you can run both instances, without a debugger (but you can attach later the process to Visual Studio) by running on two different shells: 1 2 dotnet run --no-build --settings forge-settings.json dotnet run --no-build --settings forge-settings2.json The program running forge-settings.json contains the most verbose log level and you'll have the best experience if you install (or use a docker image) of Seq configured on the port specified in your configuration file (e.g. localhost:5341). See SerilogShard for more details. Here an example of the configuration file (forge-settings.json) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 { \"ForgeConnectivity\" : { \"ForceShutdownAfter\" : 300 , \"MaxInboundConnections\" : 25 , \"AllowLoopbackConnection\" : false , \"Listeners\" : [ { \"IsWhitelistingEndpoint\" : true , \"Endpoint\" : \"0.0.0.0:45051\" }, { \"IsWhitelistingEndpoint\" : true , \"Endpoint\" : \"127.0.0.1:45052\" , \"PublicEndpoint\" : \"98.0.0.1:45011\" } ] }, \"Example\" : { \"MaxTimeAdjustment\" : 4200 , \"Connections\" : [ { \"Endpoint\" : \"127.0.0.1:45061\" , \"AdditionalInformation\" : \"I'm cool!\" } ] }, \"StatisticsCollector\" : { \"ContinuousConsoleDisplay\" : false , \"ContinuousConsoleDisplayRate\" : 5 }, \"DevController\" : { \"Enabled\" : true }, \"WebApi\" : { \"EndPoint\" : \"127.0.0.1:45020\" , \"Enabled\" : true , \"Https\" : false }, \"Serilog\" : { \"Using\" : [ \"Serilog.Sinks.Console\" , \"Serilog.Sinks.Seq\" ], \"Enrich\" : [ \"FromLogContext\" , \"WithMachineName\" , \"WithThreadId\" ], \"WriteTo\" : [ { \"Name\" : \"Console\" , \"Args\" : { \"IncludeScopes\" : true , \"theme\" : \"Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console\" } }, { \"Name\" : \"Seq\" , \"Args\" : { \"serverUrl\" : \"http://localhost:5341\" } } ], \"MinimumLevel\" : { \"Default\" : \"Debug\" , \"Override\" : { \"Bedrock.Framework\" : \"Warning\" , \"Microsoft\" : \"Warning\" , \"System\" : \"Warning\" } } } }", "title": "Running the example"}, {"location": "example-projects/running-example/#some-screenshots", "text": "Here a screenshot that shows the content of the shell when running the node with settings = forge-settings.json You can access the Swagger UI by opening the address https://127.0.0.1:45020/docs/index.html Here you can manipulate quotes using the Web API , or even manually attempt to connect to other peers using PeerManagement Connect action in the DEV area. If you installed Seq, you can access the logs in a better way like shown here:", "title": "Some Screenshots"}, {"location": "mithril-shards/", "text": "Architecture Overview Mithril Shards is a modular framework for building P2P Applications that can be expanded by additional features like Web API endpoints, MQ based services, SignalR hubs, cross platform UI and much more. Pretending to be into a Tolkien universe, I thought of defining features as shards , where each shard of mithril can be put into a forge and fused together with other mithril shards, to create a final artifact. To find analogies with .net naming conventions: Forge (to be more precise, ForgeBuilder ) is a HostBuilder on steroids (actually it encapsulate a HostBuilder instance). Shard is an application part that gets merged into the hostbuilder, using dependency injection, extending its functionality Artifact is just an allegoric view of the result of forgeBuilderInstance.RunConsoleAsync() . Note Current naming may be subject to changes. To build an application using these concepts, we have to create a ForgeBuilder, specify which Forge type to use and then we can put into the forge all the shards we need by calling AddShard method. Since a shard may require complex configurations and inject service implementations it may need, usually you don't want to call that method directly but instead you'd want to have a IForgeBuilder extension that you can put in a class in your shard project, where your initialization logic happens. That's how .Net core features and services are injected into the host builder and I think it's a good thing to use a similar approach because would be more friendly to devs used to .Net conventions. Each shard may be configured by a strong typed setting class that supports eager validation (would throw if the setting files contains invalid data) and each shard is responsible to register services it needs that would cooperate with the IForge implementation to perform needed tasks, more on this in the specific documentation sections. After all shards are added and ForgeBuilder is started by RunConsoleAsync , the forge will take care of all the plumbing stuff, initializing all the shards. For a detailed description of the components composing the Mithril Shards framework, refers to specific documentation pages. The entry point of a Mithril Shards application is the ForgeBuilder class.", "title": "Overview"}, {"location": "mithril-shards/#architecture-overview", "text": "Mithril Shards is a modular framework for building P2P Applications that can be expanded by additional features like Web API endpoints, MQ based services, SignalR hubs, cross platform UI and much more. Pretending to be into a Tolkien universe, I thought of defining features as shards , where each shard of mithril can be put into a forge and fused together with other mithril shards, to create a final artifact. To find analogies with .net naming conventions: Forge (to be more precise, ForgeBuilder ) is a HostBuilder on steroids (actually it encapsulate a HostBuilder instance). Shard is an application part that gets merged into the hostbuilder, using dependency injection, extending its functionality Artifact is just an allegoric view of the result of forgeBuilderInstance.RunConsoleAsync() . Note Current naming may be subject to changes. To build an application using these concepts, we have to create a ForgeBuilder, specify which Forge type to use and then we can put into the forge all the shards we need by calling AddShard method. Since a shard may require complex configurations and inject service implementations it may need, usually you don't want to call that method directly but instead you'd want to have a IForgeBuilder extension that you can put in a class in your shard project, where your initialization logic happens. That's how .Net core features and services are injected into the host builder and I think it's a good thing to use a similar approach because would be more friendly to devs used to .Net conventions. Each shard may be configured by a strong typed setting class that supports eager validation (would throw if the setting files contains invalid data) and each shard is responsible to register services it needs that would cooperate with the IForge implementation to perform needed tasks, more on this in the specific documentation sections. After all shards are added and ForgeBuilder is started by RunConsoleAsync , the forge will take care of all the plumbing stuff, initializing all the shards. For a detailed description of the components composing the Mithril Shards framework, refers to specific documentation pages. The entry point of a Mithril Shards application is the ForgeBuilder class.", "title": "Architecture Overview"}, {"location": "mithril-shards/default-forge/", "text": "The entry point is our forge builder class. After declaring an instance we have to specify which implementation of Forge we want to use. Actually the only available implementation is DefaultForge. DefaultForge is a simple class, it's implemented as a BackgroundService , when the forge is built and ran by the ForgeBuilder, it automatically starts and its ExecuteAsync method is invoked. In this method a default configuration file is generated in case it doesn't exists yet and all registered shards are started (their InitializeAsync method is invoked). After all shards are initialized, they are started by invoking their StartAsync (non awaited) method. From this moment, the forge is running. When the application lifetime runs out (in the default scenario by pressing CTRL+C when running in console) StopAsync method is called and it calls StopAsync on all running shards allowing them to close properly.", "title": "DefaultForge"}, {"location": "mithril-shards/forge-builder/", "text": "ForgeBuilder class represents the entry point of a Mithril Shards application, it allows to add a shard by calling the generic AddShard method, with different overloads that accept an optional strongly typed shard setting file with an optional setting file validator. By using ConfigureLogging it's possible to configure logging, it's basically a wrapper on the inner hostbiulder ConfigureLogging method, you could use it to have a finer control over logging configuration and available providers, but the easier way to log is by using the available SerilogShard that uses Serilog to configure the logging and relies on a configurable setting file where you can specify which sink to use. You can find more details on its specific documentation page and an example of its usage in the example project After declaring an instance we have to specify which implementation of Forge we want to use. Actually the only available implementation is DefaultForge class.", "title": "ForgeBuilder"}, {"location": "mithril-shards/shards/", "text": "What is a shard When you think about a Mithril Shard, you have to think of it as a set of services that extend the capabilities of the application you are building. In layman's terms shards can augment the final application with additional functionality (features) and this is the core concept of a modular application framework. When you build an application using Mithril Shards you are like a blacksmith in an epic fantasy novel: you chose which shards of mithril to use, put them into the forge, melt them together and finally shape the final: your powerful artifact! I'd like to know the artist to give him credits for the image above. But we are not living in a Tolkien novel, so what we do is : choose the shards we need (either by creating them, forking their code or referencing their nuget package) add them to the ForgeBuilder using some extension method that the shard developer has created for us and that may contains some optional parameters configure shards based on their available settings and our needs in the application configuration file (by default it's forge-settings.json but can be changed when the IForge implementation is chosen by calling ForgeBuilder UseForge method) execute the forge builder to run the program. The example project contains code to show how to achieve this.", "title": "Understanding Shards"}, {"location": "mithril-shards/shards/#what-is-a-shard", "text": "When you think about a Mithril Shard, you have to think of it as a set of services that extend the capabilities of the application you are building. In layman's terms shards can augment the final application with additional functionality (features) and this is the core concept of a modular application framework. When you build an application using Mithril Shards you are like a blacksmith in an epic fantasy novel: you chose which shards of mithril to use, put them into the forge, melt them together and finally shape the final: your powerful artifact! I'd like to know the artist to give him credits for the image above. But we are not living in a Tolkien novel, so what we do is : choose the shards we need (either by creating them, forking their code or referencing their nuget package) add them to the ForgeBuilder using some extension method that the shard developer has created for us and that may contains some optional parameters configure shards based on their available settings and our needs in the application configuration file (by default it's forge-settings.json but can be changed when the IForge implementation is chosen by calling ForgeBuilder UseForge method) execute the forge builder to run the program. The example project contains code to show how to achieve this.", "title": "What is a shard"}, {"location": "shards/bedrock-network/", "text": "BedrockNetworkShard is a very important shard that provides to the forge the required connectivity implementation used to connects to other peers and accept peers connection requests. It implements the connectivity interfaces", "title": "Overview"}, {"location": "shards/bitcoin/", "text": "Premise This folder contains technical documentation that helps to understand the choices behind the implementation and design of current project. Personally I'm not a fan of bitcoin core code base: even if it improved since early days, it's confusing, it lacks of an homogeneous design and architecture and suffers from old bad choices and above all lacks of proper technical documentation, following the mantra \"source code is the documentation\". To be clear, I don't blame who contributes on bitcoin core, I'm just stating objective facts and I hope to fix some of these issues with my project. I don't pretend to have all the documentation always in sync with latest changes because it's a huge effort and I agree at a large extent that source code is the final judge and I encourage you to dig into it if you want to go deeper in implementation details or verify that an information written here is correct. Please, if you find any issue about documentation, feel free to open an issue and I'll be happy to fix it (even a PR with your corrections can be valuable!). To me a proper documentation doesn't have to explain the source code (source code should be as much readable as possible) but it should give insights about the process that leads toward specific implementations and have indications about good practice to work within the built library. Beside this premise, I'm writing this documentation as if I were the target, in order to have a maintainable and easy to follow repository and of course be able to give good understanding about how to extend this project further with custom features (shards) to people that may be interested. Nevertheless I would be happy to know that it could be useful to someone who may find it interesting and help in understanding why an approach has been chosen over another! Also if you have question or want to discuss about technical details, you can use the repository Discussion section . Project Overview Bitcoin Mithril Shard has been built on top of Mithril Shards framework. Mithril Shards goal is to be a framework and toolkit to build modular and distributed/ P2P applications using .Net 5 stack, focusing both on good design, good practices and performance. Core functionalities can be glued togheter to compose the needed application, ranging from a P2P network layer, Web Api layer, Diagnostic tools, cross platform UI based on blazor, distributed eventing using SignalR, MQ brokers like RabbitMq or any kind of other useful libraries. Thanks to its design, anyone can build it's own Shard to create other features that can be used by Mithril Shards community. More details about Mithril Shards can be found on the main documentation (TODO). Bitcoin shard is a very good example about how to build a fully functional full node for bitcoin, leveraging all the juicy features that Mithril Shards exposes. Network layer is implemented by leveraging Bedrock Framework for the TCP implementation using both Client and Server connections. Data is serialized thanks to an well defined set of interfaces and classes that allows to implement an easy to read and maintain code. Incoming messages are dispatched to \"Message Processors\" that allow to handle the application logic following a good practice of separation of concerns. Meaningful events are dispatched using a message bus implementation that can reach any component in any application layer. A Web API infrastructure allow to create Web API endpoint easily and each feature can have its set of API published on different document specifications. Swagger is used as a UI to expose these API documents and allows to execute these APIs straight from that interface. For development/debugging purpose, a Shard inject some useful endpoint to inspect internal details of the running application. Logging is done using structured logging, makes use of Serilog to persist them and a configuration example shows how to use Seq to have a very good UI to view logs, filter them, etc... Blazor is used to implement a cross platform UI as a companion for the full node.", "title": "Overview"}, {"location": "shards/bitcoin/#premise", "text": "This folder contains technical documentation that helps to understand the choices behind the implementation and design of current project. Personally I'm not a fan of bitcoin core code base: even if it improved since early days, it's confusing, it lacks of an homogeneous design and architecture and suffers from old bad choices and above all lacks of proper technical documentation, following the mantra \"source code is the documentation\". To be clear, I don't blame who contributes on bitcoin core, I'm just stating objective facts and I hope to fix some of these issues with my project. I don't pretend to have all the documentation always in sync with latest changes because it's a huge effort and I agree at a large extent that source code is the final judge and I encourage you to dig into it if you want to go deeper in implementation details or verify that an information written here is correct. Please, if you find any issue about documentation, feel free to open an issue and I'll be happy to fix it (even a PR with your corrections can be valuable!). To me a proper documentation doesn't have to explain the source code (source code should be as much readable as possible) but it should give insights about the process that leads toward specific implementations and have indications about good practice to work within the built library. Beside this premise, I'm writing this documentation as if I were the target, in order to have a maintainable and easy to follow repository and of course be able to give good understanding about how to extend this project further with custom features (shards) to people that may be interested. Nevertheless I would be happy to know that it could be useful to someone who may find it interesting and help in understanding why an approach has been chosen over another! Also if you have question or want to discuss about technical details, you can use the repository Discussion section .", "title": "Premise"}, {"location": "shards/bitcoin/#project-overview", "text": "Bitcoin Mithril Shard has been built on top of Mithril Shards framework. Mithril Shards goal is to be a framework and toolkit to build modular and distributed/ P2P applications using .Net 5 stack, focusing both on good design, good practices and performance. Core functionalities can be glued togheter to compose the needed application, ranging from a P2P network layer, Web Api layer, Diagnostic tools, cross platform UI based on blazor, distributed eventing using SignalR, MQ brokers like RabbitMq or any kind of other useful libraries. Thanks to its design, anyone can build it's own Shard to create other features that can be used by Mithril Shards community. More details about Mithril Shards can be found on the main documentation (TODO). Bitcoin shard is a very good example about how to build a fully functional full node for bitcoin, leveraging all the juicy features that Mithril Shards exposes. Network layer is implemented by leveraging Bedrock Framework for the TCP implementation using both Client and Server connections. Data is serialized thanks to an well defined set of interfaces and classes that allows to implement an easy to read and maintain code. Incoming messages are dispatched to \"Message Processors\" that allow to handle the application logic following a good practice of separation of concerns. Meaningful events are dispatched using a message bus implementation that can reach any component in any application layer. A Web API infrastructure allow to create Web API endpoint easily and each feature can have its set of API published on different document specifications. Swagger is used as a UI to expose these API documents and allows to execute these APIs straight from that interface. For development/debugging purpose, a Shard inject some useful endpoint to inspect internal details of the running application. Logging is done using structured logging, makes use of Serilog to persist them and a configuration example shows how to use Seq to have a very good UI to view logs, filter them, etc... Blazor is used to implement a cross platform UI as a companion for the full node.", "title": "Project Overview"}, {"location": "shards/bitcoin/network/", "text": "Network Protocol The Bitcoin network protocol is a TCP protocol that serializes messages starting from a special 4 bytes constant data called Magic bytes , followed by 12 bytes representing the command name , 4 bytes representing the payload size and 4 bytes with the checksum of the payload. More specific information about bitcoin protocol can be found here. Mithril Shards implements a low level stack of interfaces and implementations that allow to focus on the application logic instead on low level details. A default implementation uses Bedrock Framework to leverage the low level communication between peers and this is what's used in the Bitcoin shard to provide P2P connectivity. A typical Bitcoin full node (henceforth called FN ) is able to connect to other nodes and accept incoming connections. Before two peers can exchange information, they have to perform an handshake to prove that they can understand each other (more details on the the bitcoin network protocol can be found on this bitcoin developer resource ). Before being able to handshake, whenever a connection has been established between two peers the FN stores some metadata about the remote peer. This data is stored into a class that implements IPeerContext interface and its implementation represents our next section. Peer Context Default Mithril Shards implementation uses PeerContext class to store, among other things, information like peer unique identification, direction (inbound/outbound) remote and local endpoints, user agent identification, negotiated protocol version and other attachable properties leveraging the .Net IFeatureCollection interface. Bitcoin needs some additional information and some of the properties that are ubiquitous needed among all optional Bitcoin features (shards) like wallet, APIs, indexer, etc... have been defined directly into BitcoinPeerContext that extends the default PeerContext . Some of the additional properties are Permissions (that may change the FN behavior based on its set) and TimeOffset, that's an important aspect for the consensus logic. Another important property exposed by peer context is the ConnectionCancellationTokenSource property, that's a CancellationTokenSource that can be used to trigger the disconnection from a peer. It's internally used to know when the connection has been closed, to stop the execution of async methods that rely on an active connection to a remote peer. As per IPeerContext interface, ConnectionCancellationTokenSource can only be read so it's important that custom implementation of IPeerContext don't change it's value out of constructor. This property is actively used within message processors (more about it in a later section). The cancellation of ConnectionCancellationTokenSource shouldn't be canceled directly, to force a peer disconnection an event of type PeerDisconnectionRequired has to be published on the event bus, but for simplicity BitcoinPeerContext implements a Disconnect method that does that. So anytime you have a need to disconnect a peer, just call thePeerContext.Disconnect(\"My Disconnection reason!\") . You can find already usage of it in message processor classes. The peer context creation is handled by the core Mithril Shard network implementation and since it can't know about the BitcoinPeerContext properties, it relies on a peer context factory, in this case we are talking about BitcoinPeerContextFactory class. It leverages the generic class PeerContextFactory<> and its implementation is bare bone, no need to override anything. 1 public class PeerContextFactory < TPeerContext > : IPeerContextFactory where TPeerContext : IPeerContext Accepting a connection Once the peer context has been created, a sanity check is performed to see if the two peers can connect to each other before trying to handshake and the behavior is very similar to both inbound and outbound connections. The only difference is that actually for outgoing connection the check is done before trying to connect but very likely it would be done as per incoming connection soon. What happens when an incoming connection has been accepted is that the connection has to pass all registered (in the DI containers) implementations of IServerPeerConnectionGuard interface. ServerPeerConnectionGuardBase In Bitcoin shard all guard rules are extending ServerPeerConnectionGuardBase implementation that's a simple class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public abstract class ServerPeerConnectionGuardBase : IServerPeerConnectionGuard { protected readonly ILogger logger ; protected readonly ForgeConnectivitySettings settings ; public ServerPeerConnectionGuardBase ( ILogger logger , IOptions < ForgeConnectivitySettings > options ) { this . logger = logger ; settings = options . Value ; } public ServerPeerConnectionGuardResult Check ( IPeerContext peerContext ) { string? denyReason = TryGetDenyReason ( peerContext ); if (! string . IsNullOrEmpty ( denyReason )) { logger . LogDebug ( \"Peer connection guard not passed: {denyReason}\" , denyReason ); return ServerPeerConnectionGuardResult . Deny ( denyReason ); } return ServerPeerConnectionGuardResult . Allow (); } internal abstract string? TryGetDenyReason ( IPeerContext peerContext ); } This class implements the plumbing code required to run (and log in case of rule check not passed) the guard rule, so a guard rule implementation has just to focus on its guarding logic. A simple example is the MaxConnectionThresholdGuard rule that ensure that an incoming transaction doesn't exceed the maximum allowed number of inbound connections: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MaxConnectionThresholdGuard : ServerPeerConnectionGuardBase { readonly IConnectivityPeerStats _peerStats ; public MaxConnectionThresholdGuard ( ILogger < MaxConnectionThresholdGuard > logger , IOptions < ForgeConnectivitySettings > settings , IConnectivityPeerStats serverPeerStats ) : base ( logger , settings ) { _peerStats = serverPeerStats ; } internal override string? TryGetDenyReason ( IPeerContext peerContext ) { if ( _peerStats . ConnectedInboundPeersCount >= settings . MaxInboundConnections ) { return \"Inbound connection refused: max connection threshold reached.\" ; } return null ; } } In order to be used during connection check, these guard classes have to be registered in the DI container. MaxConnectionThresholdGuard for example is registered into the extension that register the bitcoin shard by using 1 services.AddSingleton<IServerPeerConnectionGuard, InitialBlockDownloadStateGuard>() This allow the flexibility of having custom guard rule simply by implementing a rule and register in the DI container, any required service will be injected automatically; of course if it relies on a custom service not already available in my implementation, that service has to be registered too. Info These classes have to be registered as singleton and therefor must be stateless Network protocol is implemented through the serialization of classes which implement INetworkMessage interface and are decorated with NetworkMessageAttribute that works in synergy with an implementation of INetworkMessageSerializer to implement network serialization. Handshake Once a connection has been accepted between two nodes, they start exchanging messages in order to handshake and prove each other they are two compatible nodes that can exchange informations. Info Bitcoin protocol doesn't punish nodes that send unknown messages. I think however that a node has to monitor its connected peer activities and punish them if they send too many unknown messages causing our node to waste resources. Without going too deeper into bitcoin handshake process, the exchanges messages are summarized by this sequence diagram: sequenceDiagram participant L as Local participant R as Remote L-->>+R:Connects to L->>+R:Version R->>L:Version R->>L:Verack L->>R:Verack Info Bitcoin protocol doesn't define a specific order for the Remote node to send its Verack and Version message so Local node has to account that and accept these messages in any order.", "title": "Network implementation"}, {"location": "shards/bitcoin/network/#network-protocol", "text": "The Bitcoin network protocol is a TCP protocol that serializes messages starting from a special 4 bytes constant data called Magic bytes , followed by 12 bytes representing the command name , 4 bytes representing the payload size and 4 bytes with the checksum of the payload. More specific information about bitcoin protocol can be found here. Mithril Shards implements a low level stack of interfaces and implementations that allow to focus on the application logic instead on low level details. A default implementation uses Bedrock Framework to leverage the low level communication between peers and this is what's used in the Bitcoin shard to provide P2P connectivity. A typical Bitcoin full node (henceforth called FN ) is able to connect to other nodes and accept incoming connections. Before two peers can exchange information, they have to perform an handshake to prove that they can understand each other (more details on the the bitcoin network protocol can be found on this bitcoin developer resource ). Before being able to handshake, whenever a connection has been established between two peers the FN stores some metadata about the remote peer. This data is stored into a class that implements IPeerContext interface and its implementation represents our next section.", "title": "Network Protocol"}, {"location": "shards/bitcoin/network/#peer-context", "text": "Default Mithril Shards implementation uses PeerContext class to store, among other things, information like peer unique identification, direction (inbound/outbound) remote and local endpoints, user agent identification, negotiated protocol version and other attachable properties leveraging the .Net IFeatureCollection interface. Bitcoin needs some additional information and some of the properties that are ubiquitous needed among all optional Bitcoin features (shards) like wallet, APIs, indexer, etc... have been defined directly into BitcoinPeerContext that extends the default PeerContext . Some of the additional properties are Permissions (that may change the FN behavior based on its set) and TimeOffset, that's an important aspect for the consensus logic. Another important property exposed by peer context is the ConnectionCancellationTokenSource property, that's a CancellationTokenSource that can be used to trigger the disconnection from a peer. It's internally used to know when the connection has been closed, to stop the execution of async methods that rely on an active connection to a remote peer. As per IPeerContext interface, ConnectionCancellationTokenSource can only be read so it's important that custom implementation of IPeerContext don't change it's value out of constructor. This property is actively used within message processors (more about it in a later section). The cancellation of ConnectionCancellationTokenSource shouldn't be canceled directly, to force a peer disconnection an event of type PeerDisconnectionRequired has to be published on the event bus, but for simplicity BitcoinPeerContext implements a Disconnect method that does that. So anytime you have a need to disconnect a peer, just call thePeerContext.Disconnect(\"My Disconnection reason!\") . You can find already usage of it in message processor classes. The peer context creation is handled by the core Mithril Shard network implementation and since it can't know about the BitcoinPeerContext properties, it relies on a peer context factory, in this case we are talking about BitcoinPeerContextFactory class. It leverages the generic class PeerContextFactory<> and its implementation is bare bone, no need to override anything. 1 public class PeerContextFactory < TPeerContext > : IPeerContextFactory where TPeerContext : IPeerContext", "title": "Peer Context"}, {"location": "shards/bitcoin/network/#accepting-a-connection", "text": "Once the peer context has been created, a sanity check is performed to see if the two peers can connect to each other before trying to handshake and the behavior is very similar to both inbound and outbound connections. The only difference is that actually for outgoing connection the check is done before trying to connect but very likely it would be done as per incoming connection soon. What happens when an incoming connection has been accepted is that the connection has to pass all registered (in the DI containers) implementations of IServerPeerConnectionGuard interface.", "title": "Accepting a connection"}, {"location": "shards/bitcoin/network/#serverpeerconnectionguardbase", "text": "In Bitcoin shard all guard rules are extending ServerPeerConnectionGuardBase implementation that's a simple class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public abstract class ServerPeerConnectionGuardBase : IServerPeerConnectionGuard { protected readonly ILogger logger ; protected readonly ForgeConnectivitySettings settings ; public ServerPeerConnectionGuardBase ( ILogger logger , IOptions < ForgeConnectivitySettings > options ) { this . logger = logger ; settings = options . Value ; } public ServerPeerConnectionGuardResult Check ( IPeerContext peerContext ) { string? denyReason = TryGetDenyReason ( peerContext ); if (! string . IsNullOrEmpty ( denyReason )) { logger . LogDebug ( \"Peer connection guard not passed: {denyReason}\" , denyReason ); return ServerPeerConnectionGuardResult . Deny ( denyReason ); } return ServerPeerConnectionGuardResult . Allow (); } internal abstract string? TryGetDenyReason ( IPeerContext peerContext ); } This class implements the plumbing code required to run (and log in case of rule check not passed) the guard rule, so a guard rule implementation has just to focus on its guarding logic. A simple example is the MaxConnectionThresholdGuard rule that ensure that an incoming transaction doesn't exceed the maximum allowed number of inbound connections: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MaxConnectionThresholdGuard : ServerPeerConnectionGuardBase { readonly IConnectivityPeerStats _peerStats ; public MaxConnectionThresholdGuard ( ILogger < MaxConnectionThresholdGuard > logger , IOptions < ForgeConnectivitySettings > settings , IConnectivityPeerStats serverPeerStats ) : base ( logger , settings ) { _peerStats = serverPeerStats ; } internal override string? TryGetDenyReason ( IPeerContext peerContext ) { if ( _peerStats . ConnectedInboundPeersCount >= settings . MaxInboundConnections ) { return \"Inbound connection refused: max connection threshold reached.\" ; } return null ; } } In order to be used during connection check, these guard classes have to be registered in the DI container. MaxConnectionThresholdGuard for example is registered into the extension that register the bitcoin shard by using 1 services.AddSingleton<IServerPeerConnectionGuard, InitialBlockDownloadStateGuard>() This allow the flexibility of having custom guard rule simply by implementing a rule and register in the DI container, any required service will be injected automatically; of course if it relies on a custom service not already available in my implementation, that service has to be registered too. Info These classes have to be registered as singleton and therefor must be stateless Network protocol is implemented through the serialization of classes which implement INetworkMessage interface and are decorated with NetworkMessageAttribute that works in synergy with an implementation of INetworkMessageSerializer to implement network serialization.", "title": "ServerPeerConnectionGuardBase"}, {"location": "shards/bitcoin/network/#handshake", "text": "Once a connection has been accepted between two nodes, they start exchanging messages in order to handshake and prove each other they are two compatible nodes that can exchange informations. Info Bitcoin protocol doesn't punish nodes that send unknown messages. I think however that a node has to monitor its connected peer activities and punish them if they send too many unknown messages causing our node to waste resources. Without going too deeper into bitcoin handshake process, the exchanges messages are summarized by this sequence diagram: sequenceDiagram participant L as Local participant R as Remote L-->>+R:Connects to L->>+R:Version R->>L:Version R->>L:Verack L->>R:Verack Info Bitcoin protocol doesn't define a specific order for the Remote node to send its Verack and Version message so Local node has to account that and accept these messages in any order.", "title": "Handshake"}, {"location": "shards/bitcoin/testing_node_communication/", "text": "Testing node communication In order to test the Forge implementation, I used the handy bitcoin testnet in a box I used the docker implementation: docker pull freewil/bitcoin-testnet-box then I modified the suggested docker run arguments, in order to open the node port, this way, to run the image with an reachable testnet node, run the image as docker run -t -i -p 19000:19000 -p 19001:19001 -p 19011:19011 freewil/bitcoin-testnet-box after that, in the tty console, write make start to start the node and this way you can connect to the testnet box using the endpoint 127.0.0.1:19000 If everything is going as expected and you ran the Forge within bitcoin-testnet network, you should see something similar to this At the time of the screenshot (2nd of January 2020) only the handshake implementation was ready, this is why of warnings following the successful handshake. Troubleshooting System.Net.Sockets.SocketException (10013) In case you receive this error while trying to open some port for listening, the reason may be your OS is excluding some port ranges for some reason. To check if the port is reserved, you can use the command netsh interface ipv4 show excludedportrange tcp you'll see a list of port ranges that may include the port you are trying to open. To fix that your best bet is to just change the port you want to use in your configuration file, otherwise you need to understand why a specific port range is being reserved and eventually change it. You can delete the excludedportrange if you want and you know what you are doing, using commands like netsh int ipv4 delete excludedportrange protocol=tcp startport=45000 numberofports=100 and add new ones with netsh int ipv4 add excludedportrange protocol=tcp startport=45000 numberofports=100", "title": "Testing node communication"}, {"location": "shards/bitcoin/testing_node_communication/#testing-node-communication", "text": "In order to test the Forge implementation, I used the handy bitcoin testnet in a box I used the docker implementation: docker pull freewil/bitcoin-testnet-box then I modified the suggested docker run arguments, in order to open the node port, this way, to run the image with an reachable testnet node, run the image as docker run -t -i -p 19000:19000 -p 19001:19001 -p 19011:19011 freewil/bitcoin-testnet-box after that, in the tty console, write make start to start the node and this way you can connect to the testnet box using the endpoint 127.0.0.1:19000 If everything is going as expected and you ran the Forge within bitcoin-testnet network, you should see something similar to this At the time of the screenshot (2nd of January 2020) only the handshake implementation was ready, this is why of warnings following the successful handshake.", "title": "Testing node communication"}, {"location": "shards/bitcoin/testing_node_communication/#troubleshooting", "text": "", "title": "Troubleshooting"}, {"location": "shards/bitcoin/testing_node_communication/#systemnetsocketssocketexception-10013", "text": "In case you receive this error while trying to open some port for listening, the reason may be your OS is excluding some port ranges for some reason. To check if the port is reserved, you can use the command netsh interface ipv4 show excludedportrange tcp you'll see a list of port ranges that may include the port you are trying to open. To fix that your best bet is to just change the port you want to use in your configuration file, otherwise you need to understand why a specific port range is being reserved and eventually change it. You can delete the excludedportrange if you want and you know what you are doing, using commands like netsh int ipv4 delete excludedportrange protocol=tcp startport=45000 numberofports=100 and add new ones with netsh int ipv4 add excludedportrange protocol=tcp startport=45000 numberofports=100", "title": "System.Net.Sockets.SocketException (10013)"}, {"location": "shards/dev-controller/", "text": "DevControllerShard is a shard that depends on WebApiShard , it's goal is to inject some useful controllers meant to be used in DEV area. To add DevControllerShard into the forge you can use the IForgeBuilder extension UseDevController . Note This shard register a new ApiServiceDefinition for the dev area, so if you plan implementing a custom feature that aims to add one or more controller to DEV area, remember to add this shard or register yourself the DEV area. Current available controllers are PeerManagementController , ShardsController and StaticsController . PeerManagementController This controller exposes actions useful to connect or disconnect from a specific peer. It leverages RequiredConnection service whose task is to periodically try to connect to a issued list of peers. The list of peers can be issued both by Connect API or by configuration file using the Connect property of ForgeConnectivitySettings settings, used by BedrockNetworkShard .", "title": "Overview"}, {"location": "shards/dev-controller/#peermanagementcontroller", "text": "This controller exposes actions useful to connect or disconnect from a specific peer. It leverages RequiredConnection service whose task is to periodically try to connect to a issued list of peers. The list of peers can be issued both by Connect API or by configuration file using the Connect property of ForgeConnectivitySettings settings, used by BedrockNetworkShard .", "title": "PeerManagementController"}, {"location": "shards/serilog/", "text": "SerilogShard allows to inject Serilog log provider into the forge, allowing every service to leverage it to produce a proper loggin implementation for the application. It can be injected into the forge just by using the IForgeBuilder extension 1 public static IForgeBuilder UseSerilog ( this IForgeBuilder forgeBuilder , string? configurationFile = null ) configurationFile is optional, and can contain the path of a JSON configuration file, refers to Serilog documentation to see how to configure it properly. If no configurationFile is specified, the forge configuration file is used. Note Using an explicit configuration file allows to have more control over the configuration files used during debug and deploy, because allows you to have a file for application configuration, and a different set of configuration files specific for logging, where you can pre-configure a set of filters based on your needs An example of a configuration section is this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 { \"Serilog\" : { \"Using\" : [ \"Serilog.Sinks.Console\" , \"Serilog.Sinks.Seq\" ], \"Enrich\" : [ \"FromLogContext\" , \"WithMachineName\" , \"WithThreadId\" ], \"WriteTo\" : [ { \"Name\" : \"Console\" , \"Args\" : { \"IncludeScopes\" : true , \"theme\" : \"Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console\" } }, { \"Name\" : \"Seq\" , \"Args\" : { \"serverUrl\" : \"http://localhost:5341\" } } ], \"MinimumLevel\" : { \"Default\" : \"Debug\" , \"Override\" : { \"Bedrock.Framework\" : \"Warning\" , \"Microsoft\" : \"Warning\" , \"System\" : \"Warning\" } } } } In this example we are defining two serilog sinks: console and seq sink . MinimulLevel section allows to configure the filter based on logging severity level, in this case the default level is Debug and we have a couple of override to rise the level to warning for all classes belonging to namespace Bedrok.Framework , Microsoft and System Tweaking these settings is important to reduce the noise of unwanted logs of 3rd party libraries and focus our attention on logs that matter to us. Console Sink Console configure the logger to use console output and in the WriteTo section we specify to include scopes and use a theme to colorize the output. An output example is this Seq Sink Seq is an interesting web application that can be configured to receive logs generated by Serilog, it has a free plan for single user and in my case it was a good choice for development purpose because I can host it in my local environment and leverage its feature to be able to investigate problems. It can be both installed locally or be hosted in a docker container. In the example above it has been configured to receive logs on port 5341 1 2 3 4 { \"Name\" : \"Seq\" , \"Args\" : { \"serverUrl\" : \"http://localhost:5341\" } } It shares the same MinimumLevel section to configure which logs will be persisted but can have dynamic overrides. Seq allows you to query, create filters, signals and show structured logs in a friendly way, for further information refers to Seq website. An example of Seq interface with a couple of expanded logs, to show you additional information you can found in these logs", "title": "Overview"}, {"location": "shards/serilog/#console-sink", "text": "Console configure the logger to use console output and in the WriteTo section we specify to include scopes and use a theme to colorize the output. An output example is this", "title": "Console Sink"}, {"location": "shards/serilog/#seq-sink", "text": "Seq is an interesting web application that can be configured to receive logs generated by Serilog, it has a free plan for single user and in my case it was a good choice for development purpose because I can host it in my local environment and leverage its feature to be able to investigate problems. It can be both installed locally or be hosted in a docker container. In the example above it has been configured to receive logs on port 5341 1 2 3 4 { \"Name\" : \"Seq\" , \"Args\" : { \"serverUrl\" : \"http://localhost:5341\" } } It shares the same MinimumLevel section to configure which logs will be persisted but can have dynamic overrides. Seq allows you to query, create filters, signals and show structured logs in a friendly way, for further information refers to Seq website. An example of Seq interface with a couple of expanded logs, to show you additional information you can found in these logs", "title": "Seq Sink"}, {"location": "shards/web-api/", "text": "WebApiShard is an important shard that allows to expose Web API endpoints based on OpeAPI specifications . Swashbuckle is used under the hood and you can find more technical information about OpenAPI, REST APIs and Swagger concepts on microsoft documentation . WebApiShard comes with a WebApiSettings class that holds settings to configure the service. To add the shard to the forge, the IForgeBuilder extension UseApi has to be called, passing optional options to further configure the service 1 public static IForgeBuilder UseApi ( this IForgeBuilder forgeBuilder , Action < WebApiOptions >? options = null ) WebApiShard implements the Web API controllers using the standard aspnet ControllerBase class but decorates it with a set of default attributes needed to expose these controllers in the right context. To create a proper WebApiShard controller, an abstract base class MithrilControllerBase exists that applies already the required attributes. 1 2 3 4 [ApiController] [Produces(\"application/json\")] [Route(\"[area] /[ controller ]/[ action ] \")] public abstract class MithrilControllerBase : ControllerBase { } Areas are used to subdivide APIs based on grouping criteria and each area can be enabled or disabled by configuring the corresponding ApiServiceDefinition . By default two areas are defined but custom areas can be created easily. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /// <summary> /// Placeholder to define known core Web API areas. /// This class may be extended to add more const for 3rd party areas. /// </summary> public abstract class WebApiArea { /// <summary> /// The default API area where common actions will be available. /// </summary> public const string AREA_API = \"api\" ; /// <summary> /// The area where Dev controllers has to be placed. /// Dev controllers are controllers useful during debug that can expose internal details /// or are risky to be used in a public environment /// They may be risky to execute by an end user that doesn't have good technical details /// knowledge about the application. /// </summary> public const string AREA_DEV = \"dev\" ; } Note WebApiShard controllers have to belong to a specific area. More information in Creating a Controller section. DisableByEndPointActionFilterAttribute class, that's a registered ActionFilterAttribute , is responsible to enforce proper checks against executing an action on an unspecified, unknown or disabled area. Warning The current implementation may be subject to changes to implement the authentication and authorization layer.", "title": "Overview"}, {"location": "shards/web-api/areas/", "text": "WebApiShard organize controllers assigning them to specific areas. Areas are used to subdivide APIs based on grouping criteria and each area can be enabled or disabled by configuring the corresponding ApiServiceDefinition . By default two areas are defined: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /// <summary> /// Placeholder to define known core Web API areas. /// This class may be extended to add more const for 3rd party areas. /// </summary> public abstract class WebApiArea { /// <summary> /// The default API area where common actions will be available. /// </summary> public const string AREA_API = \"api\" ; /// <summary> /// The area where Dev controllers has to be placed. /// Dev controllers are controllers useful during debug that can expose internal details /// or are risky to be used in a public environment /// They may be risky to execute by an end user that doesn't have good technical details /// knowledge about the application. /// </summary> public const string AREA_DEV = \"dev\" ; } Custom areas can be created easily by defining them using ApiServiceDefinition . DevControllerShard for example defines its own ApiServiceDefinition to group all controllers meant to be used for development / diagnostic purpose. Note Any WebApiShard compliant controller has to belong to a specific area, by specifying an AreaAttribute at controller class level. ApiServiceDefinition ApiServiceDefinition is a class responsible to hold a WEB Api area configuration. It contains an Enabled property used to enable or disable that specific area and its value is usually set by using the configuration file of the shard responsible for the ApiServiceDefinition. DevControllerShard code shows an example of how to register an area during the shard registration: 1 2 3 4 5 6 7 8 9 10 11 12 13 forgeBuilder . AddShard < DevControllerShard , DevControllerSettings >(( context , services ) => { if ( context . GetShardSettings < DevControllerSettings >()!. Enabled ) { services . AddApiServiceDefinition ( new ApiServiceDefinition { Area = WebApiArea . AREA_DEV , Name = \"Dev API\" , Description = \"API useful for debug purpose.\" , Version = \"v1\" , }); } }); In this example you can see that Area is set to WebApiArea.AREA_DEV that's simply a constant string that's the equivalent of set it to \"dev\" and Enabled is set to settings.Enabled , this way it's enabled or disabled based on the DevControllerSettings configuration. Note Each different ApiServiceDefinition generates an OpenAPI document following its specification. Swagger UI allows to select which document to show, see Using Swagger UI section. An OpenAPI document can be used by tools like AutoRest to generate automatically clients for RESTful API , not just for C# but for many other languages (after all OpenAPI is an agnostic specification). Creating custom areas The process to create a custom area is the same as the one shown in the example above, the only difference is the Area value, that can be any string. If we want to create an area named \"area51\" and be available for controllers defined in our shards or a 3rd party shards, we can register such area by creating a new ApiServiceDefinition instance and register it using AddApiServiceDefinition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 forgeBuilder . AddShard < YourShard , YourShardSettings >(( context , services ) => { if ( context . GetShardSettings < YourShardSettings >()!. Enabled ) { services . AddApiServiceDefinition ( new ApiServiceDefinition { Enabled = true , Area = \"area51\" , Name = \"Area 51 - trust no one!\" , Description = \"Nothing to see here...\" , Version = \"v1\" , }); } }); The example above implies that YourShardSettings has a Enabled boolean property that describes if the shard has to generate or not an ApiServiceDefinition. You are free to skip that check if you want to have an area always defined and/or want to tweak the ApiServiceDefinition Enabled property at runtime based on some custom conditions. Note An ApiServiceDefinition can be enabled or disabled at runtime by changing its Enabled property. Registering an area implicitly generates its OpenAPI document, but access to its API are controlled by its Enabled property. In order to have controllers assigned to such area, a controller has to be decorated with an Area attribute like in this example: 1 2 [Area(\"area51\")] public class YourAreaController : MithrilControllerBase You can find more information on controller creation in the Creating a Controller section.", "title": "Web API Areas"}, {"location": "shards/web-api/areas/#apiservicedefinition", "text": "ApiServiceDefinition is a class responsible to hold a WEB Api area configuration. It contains an Enabled property used to enable or disable that specific area and its value is usually set by using the configuration file of the shard responsible for the ApiServiceDefinition. DevControllerShard code shows an example of how to register an area during the shard registration: 1 2 3 4 5 6 7 8 9 10 11 12 13 forgeBuilder . AddShard < DevControllerShard , DevControllerSettings >(( context , services ) => { if ( context . GetShardSettings < DevControllerSettings >()!. Enabled ) { services . AddApiServiceDefinition ( new ApiServiceDefinition { Area = WebApiArea . AREA_DEV , Name = \"Dev API\" , Description = \"API useful for debug purpose.\" , Version = \"v1\" , }); } }); In this example you can see that Area is set to WebApiArea.AREA_DEV that's simply a constant string that's the equivalent of set it to \"dev\" and Enabled is set to settings.Enabled , this way it's enabled or disabled based on the DevControllerSettings configuration. Note Each different ApiServiceDefinition generates an OpenAPI document following its specification. Swagger UI allows to select which document to show, see Using Swagger UI section. An OpenAPI document can be used by tools like AutoRest to generate automatically clients for RESTful API , not just for C# but for many other languages (after all OpenAPI is an agnostic specification).", "title": "ApiServiceDefinition"}, {"location": "shards/web-api/areas/#creating-custom-areas", "text": "The process to create a custom area is the same as the one shown in the example above, the only difference is the Area value, that can be any string. If we want to create an area named \"area51\" and be available for controllers defined in our shards or a 3rd party shards, we can register such area by creating a new ApiServiceDefinition instance and register it using AddApiServiceDefinition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 forgeBuilder . AddShard < YourShard , YourShardSettings >(( context , services ) => { if ( context . GetShardSettings < YourShardSettings >()!. Enabled ) { services . AddApiServiceDefinition ( new ApiServiceDefinition { Enabled = true , Area = \"area51\" , Name = \"Area 51 - trust no one!\" , Description = \"Nothing to see here...\" , Version = \"v1\" , }); } }); The example above implies that YourShardSettings has a Enabled boolean property that describes if the shard has to generate or not an ApiServiceDefinition. You are free to skip that check if you want to have an area always defined and/or want to tweak the ApiServiceDefinition Enabled property at runtime based on some custom conditions. Note An ApiServiceDefinition can be enabled or disabled at runtime by changing its Enabled property. Registering an area implicitly generates its OpenAPI document, but access to its API are controlled by its Enabled property. In order to have controllers assigned to such area, a controller has to be decorated with an Area attribute like in this example: 1 2 [Area(\"area51\")] public class YourAreaController : MithrilControllerBase You can find more information on controller creation in the Creating a Controller section.", "title": "Creating custom areas"}, {"location": "shards/web-api/creating-a-controller/", "text": "To create a controller that can be exposed by the WebApiShard we can take advantage of the MithrilControllerBase class. We can take a look at the controller implemented in the example project , to dissect it and discuss about its implementation. Let's take a meaningful part of that class and let's dissect it by highlighting some code part: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [Area(WebApiArea.AREA_API)] public class ExampleController : MithrilControllerBase { private readonly ILogger < ExampleController > _logger ; readonly IQuoteService _quoteService ; public ExampleController ( ILogger < ExampleController > logger , IQuoteService quoteService ) { _logger = logger ; _quoteService = quoteService ; } [HttpGet] [ProducesResponseType(StatusCodes.Status200OK)] public ActionResult GetQuotes () { return Ok ( _quoteService . Quotes ); } Define the area Line 1 describes, using AreaAttribute , the area we want this controller to be included. WebApiArea is an helper class that just contains a bounch of constant string of known areas: \"api\" and \"dev\". \"api\" ( WebApiArea.AREA_API ) is the area where generic purpose controller should be placed. They are meant to be used by end users or 3rd party integration, to interact with our application. \"dev\" ( WebApiArea.AREA_DEV ) is the area where Dev controllers should be placed. Dev controllers are controllers useful during debug that can expose internal details or are risky to be used in a public environment. They may be risky to execute by an end user that doesn't have good technical details knowledge about the application and generally you want to enable them when you are developing or you need to collect more information on a running instance of your application. There are some Controllers that are available out of the box when you use Mithril Shards features, an example is SerilogShard that includes SeriLogController that allows to control Log filters at runtime and it's exposed in the \"api\" area, while many more Controllers are exposed in \"dev\" area like the ones included by DevControllerShard . Tip You can create custom areas, for more information see Web API Areas documentation. Declare controller Type Line 2 is the Controller class definition and it just declare our ExampleController class that inherit from MithrilControllerBase. The name of the controller class is important because by default the actions implemented in the controller will have a route like the one defined by RouteAttribute that decorates the MithrilControllerBase 1 [Route(\"[area] /[ controller ]/[ action ] \")] area will be replaced by the are we declared our controller belongs to (e.g. \"api\"). controller is the name of the Controller class, stripping out \"Controller\" part, e.g. ExampleController will become \"Example\" action is the name of the action we can invoke ExampleController action GetQuotes URL will then become api/Example/GetQuotes . This represents the part of the URL to append to the WebApiShard configured Endpoint, so if we configured it to 127.0.0.1:45030 the complete URL will be http://127.0.0.1:45020/api/Example/GetQuotes (or https if we enabled Https). Inject services into constructor Line 7-10 is the Controller constructor. A controller is created automatically at each web request and the parameters declared in the constructor will be populated by using DI In this example, ILogger<ExampleController> logger gets populated with strongly typed instance of our logger and IQuoteService quoteService with the instance of the concrete implementation of our IQuoteService that in our example project we registered as a singleton 1 . AddSingleton < IQuoteService , QuoteService >() Note It's important to know the life cycle of our injected service because they may impact performance. If the constructor of a service is slow and that service is defined as Transient (or Scoped) every action will have to wait its completion before being able to perform its job. Implement an action Lines 13-18 declare and implement an action. In this case, the action is declared as HttpGet , this mean that it will only respond to GET requests. If you try to access that action with others HTTP verbs, it will return a status error 405 Method Not Allowed [ProducesResponseType(StatusCodes.Status200OK)] declare known action status that can be returned by the action. It's just an helpful attribute useful to produce a better documentation on swagger interface and document definition but the action itself may even generate different statuses. This documentation however don't cover canonical Web API implementation, so refer to .Net documentation . to read more about it. To return an action result, the method Ok is invoked, passing the payload (that will be serialized in JSON ) as a response. To document better the result type, we could specify in ProduceResponseTypeAttribute the returned type, it could be helpful for the consumer to know which type of object to receive back and which properties it exposes. In this example it's a simple list of string but it can be any JSON serializable type: 1 [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(List<string>))] As an additional example, this is the code of a DEV controller action that generates different status based on internal state of the node 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 [HttpPost] [ProducesResponseType(StatusCodes.Status200OK)] [ProducesResponseType(StatusCodes.Status404NotFound)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public IActionResult Connect ( PeerManagementConnectRequest request ) { if ( _requiredConnection == null ) { return NotFound ( $ \"Cannot produce output because {nameof(RequiredConnection)} is not available\" ); } if (! IPEndPoint . TryParse ( request . EndPoint , out IPEndPoint ? ipEndPoint )) { return ValidationProblem ( \"Incorrect endpoint\" ); } _requiredConnection . TryAddEndPoint ( ipEndPoint ); return Ok (); } In this example, this action will return 404 (not found) if the member variables _requiredConnection isn't set, or 400 (bad request) if the input peer isn't formatted properly as a valid endpoint. If everything goes fine it will instead return 200 (ok). Tip In case of action problems, instead of calling BadRequest or Problem method extensions, use ValidationProblem , it uses a ValidationProblemDetails response that's consistent with automatic validation error responses, as stated here . In the example above, NotFound could be replaced with ValidationProblem too for a consistent behavior. Producing documentation for Swagger UI In order to produce proper documentation to be shown on Swagger UI , XML comments within C# source can be used but the build process has to generate a documentation file. The easier way is to edit your project file adding this snippet: 1 2 3 <PropertyGroup> <GenerateDocumentationFile> true </GenerateDocumentationFile> </PropertyGroup> For Mithril Shards project defined within the Mithril Shard solution folder this is not necessary because that snippet is already defined in Directory.Build.props file. Note WebApiShard already take care of including documentation files by looking at files with the name of the assembly that contains the controller, with an .xml extension. var xmlFile = $\"{assembly.GetName().Name}.xml\"; Tip Directory.Build.props file is a powerful way to set common project configurations for complex solutions with multiple projects, you can read more about it here .", "title": "Creating a Controller"}, {"location": "shards/web-api/creating-a-controller/#define-the-area", "text": "Line 1 describes, using AreaAttribute , the area we want this controller to be included. WebApiArea is an helper class that just contains a bounch of constant string of known areas: \"api\" and \"dev\". \"api\" ( WebApiArea.AREA_API ) is the area where generic purpose controller should be placed. They are meant to be used by end users or 3rd party integration, to interact with our application. \"dev\" ( WebApiArea.AREA_DEV ) is the area where Dev controllers should be placed. Dev controllers are controllers useful during debug that can expose internal details or are risky to be used in a public environment. They may be risky to execute by an end user that doesn't have good technical details knowledge about the application and generally you want to enable them when you are developing or you need to collect more information on a running instance of your application. There are some Controllers that are available out of the box when you use Mithril Shards features, an example is SerilogShard that includes SeriLogController that allows to control Log filters at runtime and it's exposed in the \"api\" area, while many more Controllers are exposed in \"dev\" area like the ones included by DevControllerShard . Tip You can create custom areas, for more information see Web API Areas documentation.", "title": "Define the area"}, {"location": "shards/web-api/creating-a-controller/#declare-controller-type", "text": "Line 2 is the Controller class definition and it just declare our ExampleController class that inherit from MithrilControllerBase. The name of the controller class is important because by default the actions implemented in the controller will have a route like the one defined by RouteAttribute that decorates the MithrilControllerBase 1 [Route(\"[area] /[ controller ]/[ action ] \")] area will be replaced by the are we declared our controller belongs to (e.g. \"api\"). controller is the name of the Controller class, stripping out \"Controller\" part, e.g. ExampleController will become \"Example\" action is the name of the action we can invoke ExampleController action GetQuotes URL will then become api/Example/GetQuotes . This represents the part of the URL to append to the WebApiShard configured Endpoint, so if we configured it to 127.0.0.1:45030 the complete URL will be http://127.0.0.1:45020/api/Example/GetQuotes (or https if we enabled Https).", "title": "Declare controller Type"}, {"location": "shards/web-api/creating-a-controller/#inject-services-into-constructor", "text": "Line 7-10 is the Controller constructor. A controller is created automatically at each web request and the parameters declared in the constructor will be populated by using DI In this example, ILogger<ExampleController> logger gets populated with strongly typed instance of our logger and IQuoteService quoteService with the instance of the concrete implementation of our IQuoteService that in our example project we registered as a singleton 1 . AddSingleton < IQuoteService , QuoteService >() Note It's important to know the life cycle of our injected service because they may impact performance. If the constructor of a service is slow and that service is defined as Transient (or Scoped) every action will have to wait its completion before being able to perform its job.", "title": "Inject services into constructor"}, {"location": "shards/web-api/creating-a-controller/#implement-an-action", "text": "Lines 13-18 declare and implement an action. In this case, the action is declared as HttpGet , this mean that it will only respond to GET requests. If you try to access that action with others HTTP verbs, it will return a status error 405 Method Not Allowed [ProducesResponseType(StatusCodes.Status200OK)] declare known action status that can be returned by the action. It's just an helpful attribute useful to produce a better documentation on swagger interface and document definition but the action itself may even generate different statuses. This documentation however don't cover canonical Web API implementation, so refer to .Net documentation . to read more about it. To return an action result, the method Ok is invoked, passing the payload (that will be serialized in JSON ) as a response. To document better the result type, we could specify in ProduceResponseTypeAttribute the returned type, it could be helpful for the consumer to know which type of object to receive back and which properties it exposes. In this example it's a simple list of string but it can be any JSON serializable type: 1 [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(List<string>))] As an additional example, this is the code of a DEV controller action that generates different status based on internal state of the node 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 [HttpPost] [ProducesResponseType(StatusCodes.Status200OK)] [ProducesResponseType(StatusCodes.Status404NotFound)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public IActionResult Connect ( PeerManagementConnectRequest request ) { if ( _requiredConnection == null ) { return NotFound ( $ \"Cannot produce output because {nameof(RequiredConnection)} is not available\" ); } if (! IPEndPoint . TryParse ( request . EndPoint , out IPEndPoint ? ipEndPoint )) { return ValidationProblem ( \"Incorrect endpoint\" ); } _requiredConnection . TryAddEndPoint ( ipEndPoint ); return Ok (); } In this example, this action will return 404 (not found) if the member variables _requiredConnection isn't set, or 400 (bad request) if the input peer isn't formatted properly as a valid endpoint. If everything goes fine it will instead return 200 (ok). Tip In case of action problems, instead of calling BadRequest or Problem method extensions, use ValidationProblem , it uses a ValidationProblemDetails response that's consistent with automatic validation error responses, as stated here . In the example above, NotFound could be replaced with ValidationProblem too for a consistent behavior.", "title": "Implement an action"}, {"location": "shards/web-api/creating-a-controller/#producing-documentation-for-swagger-ui", "text": "In order to produce proper documentation to be shown on Swagger UI , XML comments within C# source can be used but the build process has to generate a documentation file. The easier way is to edit your project file adding this snippet: 1 2 3 <PropertyGroup> <GenerateDocumentationFile> true </GenerateDocumentationFile> </PropertyGroup> For Mithril Shards project defined within the Mithril Shard solution folder this is not necessary because that snippet is already defined in Directory.Build.props file. Note WebApiShard already take care of including documentation files by looking at files with the name of the assembly that contains the controller, with an .xml extension. var xmlFile = $\"{assembly.GetName().Name}.xml\"; Tip Directory.Build.props file is a powerful way to set common project configurations for complex solutions with multiple projects, you can read more about it here .", "title": "Producing documentation for Swagger UI"}, {"location": "shards/web-api/swagger-ui/", "text": "Swagger UI allows to visualize and interact with the Web API resources generated from OpenAPI toolset. WebApiShard makes use of it and thus we can have a nice UI to test and document our API . As stated in ApiServiceDefinition section, each area generates a different OpenAPI document and we can use tool like Swagger UI to convert that specification to turn that document into an UI that allows us to test and read documentation about our exposed API resources. An OpenAPI document can even be used by tools like AutoRest to generate automatically clients (in different programming languages) for RESTful API ! Note Mithril Shards customizes a bit the look of Swagger UI but it will be familiar to who is already used to work with it. The address to access swagger UI depends on WebApiSettings EndPoint parameter. If we consider the default EndPoint 127.0.0.1:45020 , a WebApiShard enabled application exposes Swagger at the url Swagger UI Elements Without going too deeper into documenting the UI (there are a lot of resources on the web about Swagger UI and anyway it's pretty straightforward) I want to highlight a couple of sections Document Selection It's a combo box that allows you to select one of the ApiServiceDefinition defined area that are currently enabled. In this example we have selected API that corresponds to our WebApiArea.API (or simply \"api\") area defined by WebApiShard itself. You can see another option, DEV API , that corresponds to the WebApiArea.DEV (or simply \"dev\") area defined by DevControllerShard . Note The displayed name corresponds to ApiServiceDefinition Name property. OpenAPI document URL It's the URL of the selected OpenAPI document. It can be used to generate RESTful clients with tools like AutoRest . Search Box Allows to filter Web API resources by their name or description. Performing an API request By clicking on an API entry, it's possible to execute it by clicking on Try it out button, filling the required data (in this example the field quote ) and then pressing the \"Execute\" button that will be displayed Note It is possible to provide examples and more documentation by using C# XML comments, you can find more information in the section Include Descriptions from XML Comments on Swashbuckle.AspNetCore repository or by looking at the ExampleController source code in the MithrilShards.Example.Dev project. The screenshot above shows the AddQuote action in the example project and it has been fully documented: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /// <summary> /// Adds a quote. /// </summary> /// <param name=\"quote\" example=\"Tu quoque, Brute, fili mi!\">The quote to add.</param> /// <response code=\"200\">The quote that has been added.</response> /// <remarks> /// Adds a quote to the quotes list. /// </remarks> [HttpPost] [ProducesResponseType(StatusCodes.Status200OK)] public ActionResult AddQuote ( string quote ) { _quoteService . Quotes . Add ( quote ); _logger . LogDebug ( \"A new quote has been added: `{Quote}`\" , quote ); return Ok ( quote ); }", "title": "Using Swagger UI"}, {"location": "shards/web-api/swagger-ui/#swagger-ui-elements", "text": "Without going too deeper into documenting the UI (there are a lot of resources on the web about Swagger UI and anyway it's pretty straightforward) I want to highlight a couple of sections", "title": "Swagger UI Elements"}, {"location": "shards/web-api/swagger-ui/#document-selection", "text": "It's a combo box that allows you to select one of the ApiServiceDefinition defined area that are currently enabled. In this example we have selected API that corresponds to our WebApiArea.API (or simply \"api\") area defined by WebApiShard itself. You can see another option, DEV API , that corresponds to the WebApiArea.DEV (or simply \"dev\") area defined by DevControllerShard . Note The displayed name corresponds to ApiServiceDefinition Name property.", "title": "Document Selection"}, {"location": "shards/web-api/swagger-ui/#openapi-document-url", "text": "It's the URL of the selected OpenAPI document. It can be used to generate RESTful clients with tools like AutoRest .", "title": "OpenAPI document URL"}, {"location": "shards/web-api/swagger-ui/#search-box", "text": "Allows to filter Web API resources by their name or description.", "title": "Search Box"}, {"location": "shards/web-api/swagger-ui/#performing-an-api-request", "text": "By clicking on an API entry, it's possible to execute it by clicking on Try it out button, filling the required data (in this example the field quote ) and then pressing the \"Execute\" button that will be displayed Note It is possible to provide examples and more documentation by using C# XML comments, you can find more information in the section Include Descriptions from XML Comments on Swashbuckle.AspNetCore repository or by looking at the ExampleController source code in the MithrilShards.Example.Dev project. The screenshot above shows the AddQuote action in the example project and it has been fully documented: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /// <summary> /// Adds a quote. /// </summary> /// <param name=\"quote\" example=\"Tu quoque, Brute, fili mi!\">The quote to add.</param> /// <response code=\"200\">The quote that has been added.</response> /// <remarks> /// Adds a quote to the quotes list. /// </remarks> [HttpPost] [ProducesResponseType(StatusCodes.Status200OK)] public ActionResult AddQuote ( string quote ) { _quoteService . Quotes . Add ( quote ); _logger . LogDebug ( \"A new quote has been added: `{Quote}`\" , quote ); return Ok ( quote ); }", "title": "Performing an API request"}, {"location": "shards/web-api/using-webapishard/", "text": "Add WebApiService to the forge To add the shard to the forge, the IForgeBuilder extension UseApi has to be called, passing optional options to further configure the service 1 public static IForgeBuilder UseApi ( this IForgeBuilder forgeBuilder , Action < WebApiOptions >? options = null ) WebApiOptions WebApiOptions class allows to customize the discovery process that's responsible to find and register Web API controllers end include them into a specific ApiServiceDefinition . The discovery process happens during WebApiShard initialization: it generates an ApplicationPart for each registered shard that will include all discovered MithrilControllerBase (ControllerBase) types defined in the shard assembly. ControllersSeeker Sometimes you may have a project that just holds Controllers but isn't exposed as a shard, in this scenario you can use WebApiOptions during the call of UseApi, to explicitly add an assembly to inspect for controllers. The example project makes use of this when it builds the forge: 1 2 3 4 5 /// we are injecting ExampleDev type to allow <see cref=\"WebApi.WebApiShard\"/> to find all the controllers /// defined there because only controllers defined in an included shard assemblies are discovered automatically. /// Passing ExampleDev will cause dotnet runtime to load the assembly where ExampleDev Type is defined and every /// controllers defined there will be found later during <see cref=\"WebApi.WebApiShard\"/> initialization. . UseApi ( options => options . ControllersSeeker = ( seeker ) => seeker . LoadAssemblyFromType < ExampleDev >()) By doing this WebApiOptions will create an Application part for each explicitly added assembly and all Controller types defined in that assembly will be found and added to the available controllers in their specific area. EnablePublicApi This settings enables or disables the public API area . The public area corresponds to the ApiServiceDefinition that's responsible to enable all controllers assigned to the area WebApiArea.AREA_API . If you are creating an application where a public area is never needed, you may want to use this property rather than relying on external configuration file that may be missing or edited. PublicApiDescription This settings allow to customize the description used to describe public API . Defaults to Mithril Shards public API . Title Configures the Swagger UI page title, useful for branding. Defaults to Mithril Shards Web API . WebApiSettings WebApiSettings is the class that holds configuration settings required by the shard to works. It contains few properties to configure the endpoint used to listen to API requests and its behavior: Property Type Description Default EndPoint string IP address and port number on which the shard will serve its Web API endpoint, in the form of ip_address:port . \"127.0.0.1:45020\" Https bool Whether WEB API should be exposed on HTTPS. false Enabled bool Whether WebApiShard is enabled or not. Disabling it would cause any shard depending on WebApiShard, such as custom controllers or custom areas, to be unable to be served. true Configuration properties can be set in the application configuration file, within its root section, under the name of WebApi Note every shard configuration section is mapped by default to the name of the configuration setting class, stripping out the Settings part example: 1 2 3 4 5 \"WebApi\" : { \"EndPoint\" : \"127.0.0.1:45030\" , \"Enabled\" : false , \"Https\" : false }", "title": "Using WebApiShard"}, {"location": "shards/web-api/using-webapishard/#add-webapiservice-to-the-forge", "text": "To add the shard to the forge, the IForgeBuilder extension UseApi has to be called, passing optional options to further configure the service 1 public static IForgeBuilder UseApi ( this IForgeBuilder forgeBuilder , Action < WebApiOptions >? options = null )", "title": "Add WebApiService to the forge"}, {"location": "shards/web-api/using-webapishard/#webapioptions", "text": "WebApiOptions class allows to customize the discovery process that's responsible to find and register Web API controllers end include them into a specific ApiServiceDefinition . The discovery process happens during WebApiShard initialization: it generates an ApplicationPart for each registered shard that will include all discovered MithrilControllerBase (ControllerBase) types defined in the shard assembly.", "title": "WebApiOptions"}, {"location": "shards/web-api/using-webapishard/#controllersseeker", "text": "Sometimes you may have a project that just holds Controllers but isn't exposed as a shard, in this scenario you can use WebApiOptions during the call of UseApi, to explicitly add an assembly to inspect for controllers. The example project makes use of this when it builds the forge: 1 2 3 4 5 /// we are injecting ExampleDev type to allow <see cref=\"WebApi.WebApiShard\"/> to find all the controllers /// defined there because only controllers defined in an included shard assemblies are discovered automatically. /// Passing ExampleDev will cause dotnet runtime to load the assembly where ExampleDev Type is defined and every /// controllers defined there will be found later during <see cref=\"WebApi.WebApiShard\"/> initialization. . UseApi ( options => options . ControllersSeeker = ( seeker ) => seeker . LoadAssemblyFromType < ExampleDev >()) By doing this WebApiOptions will create an Application part for each explicitly added assembly and all Controller types defined in that assembly will be found and added to the available controllers in their specific area.", "title": "ControllersSeeker"}, {"location": "shards/web-api/using-webapishard/#enablepublicapi", "text": "This settings enables or disables the public API area . The public area corresponds to the ApiServiceDefinition that's responsible to enable all controllers assigned to the area WebApiArea.AREA_API . If you are creating an application where a public area is never needed, you may want to use this property rather than relying on external configuration file that may be missing or edited.", "title": "EnablePublicApi"}, {"location": "shards/web-api/using-webapishard/#publicapidescription", "text": "This settings allow to customize the description used to describe public API . Defaults to Mithril Shards public API .", "title": "PublicApiDescription"}, {"location": "shards/web-api/using-webapishard/#title", "text": "Configures the Swagger UI page title, useful for branding. Defaults to Mithril Shards Web API .", "title": "Title"}, {"location": "shards/web-api/using-webapishard/#webapisettings", "text": "WebApiSettings is the class that holds configuration settings required by the shard to works. It contains few properties to configure the endpoint used to listen to API requests and its behavior: Property Type Description Default EndPoint string IP address and port number on which the shard will serve its Web API endpoint, in the form of ip_address:port . \"127.0.0.1:45020\" Https bool Whether WEB API should be exposed on HTTPS. false Enabled bool Whether WebApiShard is enabled or not. Disabling it would cause any shard depending on WebApiShard, such as custom controllers or custom areas, to be unable to be served. true Configuration properties can be set in the application configuration file, within its root section, under the name of WebApi Note every shard configuration section is mapped by default to the name of the configuration setting class, stripping out the Settings part example: 1 2 3 4 5 \"WebApi\" : { \"EndPoint\" : \"127.0.0.1:45030\" , \"Enabled\" : false , \"Https\" : false }", "title": "WebApiSettings"}]}