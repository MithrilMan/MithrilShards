{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Welcome!", "text": ""}, {"location": "#goal", "title": "Goal", "text": "<p>Mithril Shards goal is to implement a .NET 8 extensible P2P network &amp; distributed services library from scratch with focus on architecture and performance.</p> <p>Allows you to define custom network serialization protocol, easily handle payload messages and interact with the software leveraging any available features (named Shards) like Web API endpoints, cross platform Blazor UI,  and a lot of other exciting stuffs that community can implement and release to the public too!</p> <p>The project is very ambitious and it's currently developed just by me as a pet project but a huge effort has already been made and some part of this unique code base has been reused in other blockchain technologies to improve their performance.</p>"}, {"location": "#current-tech", "title": "Current Tech", "text": "<p>A random list of available tech used within Mithril Shards.</p> <ul> <li>.Net 8 - ... for everything.</li> <li>Bedrock Framework - TCP/IP default connectivity implementation.</li> <li>Swashbuckle - to handle Web API in a configurable, multi-area environment and have a playground to test APIs with swagger.</li> <li>Serilog - default logging implementation.</li> <li>BenchmarkDotNet - a benchmark framework, very handy to benchmark different approach during implementation phases.</li> </ul>"}, {"location": "#how-things-started", "title": "How things started", "text": "<p>I have DLT experience in the past years and one of my previous experience has been working for a blockchain tech firm that had a FN implementation in C#. I really love C# and .Net core has improved a lot performance too.</p> <p>Working on their codebase I saw lot of things that could have been improved, both in design and in performance. Their implementation started as a kind of 1-1 porting of bitcoin core source with all the cons that it brings.</p> <p>So I thought about diving into this titanic effort of creating a full node in C# starting from scratch, mainly to go as deeper as possible into technical details, trying to focus both on a proper architecture design and performance improvements.</p> <p>One of the first thing I implemented was of course the basic handshake process between two nodes and to achieve that, I started by following bitcoin core source because unluckily that's the only part that contains kind of specifications: it's hard to find a detailed updated technical documentations, even this protocol documentation page contains wrong information, even if it's still useful.</p> <p>I started using .Net TCP classes, using an internal state machine to handle peer connection statuses, then I found Bedrock Framework, that allowed me to abstract better my code and rely on it for the low level connection stuff (at the time of writing this documentation, that library is still in alpha and my concern about that project activity has been appeased ).</p> <p>As soon as I started defining properly my design, I found it interesting to abstract most of the stuff into an agnostic library that would allows me to create a P2P application in a modular way and attach additional features when needed, and this is how Mithril Shards started.</p> <p>Since then I added more and more stuff, both for generic Mithril Shards project and for specific Bitcoin needs.</p> <p>The multi project Example Shard showcases how you can create a custom P2P software leveraging networking, custom messages, Web API endpoints Diagnostic tools, everything with a proper logging system.</p>"}, {"location": "#why-the-mithril-shards-name", "title": "Why the Mithril Shards name?", "text": "<p>Well... let's bullet some facts</p> <ul> <li>I like fantasy a lot, J.R.R. Tolkien of course has been one of my reads and mithril is a fictional metal in his universe.</li> <li>The main properties of mithri are: being very strong, light and in its pure form very malleable to work with.</li> <li>I'm a developer who likes to engineer my software to be extensible and solid.</li> <li>My github handle is MithrilMan, guess what?</li> </ul> <p>Now take these information, mix them up, and you'll see that to I aim to have a robust, fast and flexible project! So this explain mithril, while about Shards, is because I see this project as a mix of shards that can be assembled together to give you a precious artifact!</p> <p>In fact you shouldn't be surprised that the root class is called Forge... who says we can't have a bit of fun while designing a software?</p>"}, {"location": "#call-to-action", "title": "Call to Action!", "text": "<p>Join to give feedback, ask for features, support, etc.</p> <p>Discord server: https://discord.gg/T9kyKz4bAu </p>"}, {"location": "#ci", "title": "CI", "text": "Current status"}, {"location": "example-projects/", "title": "Example Projects Overview", "text": "<p>The best way to see it in action is by inspecting the Example projects I've created. It's a multi-project example where each project plays its role into the modular application architecture.</p> <p>Its goal is to show how to make use of Mithril Shards to implement a P2P application that implements a custom Web API controller, a custom network implementation and its own protocol with custom messages and serializators.</p> <p>It reuses some other standard shards like :</p> <ul> <li> BedrockNetworkShard</li> <li> [StatisticCollectorShard]</li> <li> SerilogShard</li> <li> WebApiShard</li> <li> DevControllerShard</li> </ul> <p>What it does is quite simple:</p> <p>You can run two instance of this project to connect to each other and every 10 seconds a ping message will be sent to the other peer, with a random quote message.</p> <p>The quote message is randomly picked by the QuoteService and quotes can be manipulated by using the ExampleController exposed by the Web API.</p>"}, {"location": "example-projects/#example-projects", "title": "Example Projects", "text": "<p>The example is composed by several projects, each one with their own scope, to mimic a (simple) typical modular application:</p> <ul> <li>MithrilShards.Example</li> <li>MithrilShards.Example.Network.Bedrock</li> <li>MithrilShards.Example.Dev</li> <li>MithrilShards.Example.Node</li> </ul> <p>Each project has its own documentation page to present its purpose and to explain some implementation details, however all the code is well commented so you shouldn't have any problems understanding it, in any case the Discussions on my repository is open for you.</p>"}, {"location": "example-projects/mithril-shards-example-dev/", "title": "MithrilShards.Example.Dev", "text": ""}, {"location": "example-projects/mithril-shards-example-dev/#mithrilshardsexampledev", "title": "MithrilShards.Example.Dev", "text": "<p>Contains just a Controller that expose a couple of Web API actions to manipulate the QuoteService and list, add and remove quotes.</p> <p>In order to show an alternative way to register controllers, this project doesn't implement a shard and doesn't have any <code>Add*</code> / <code>Use*</code> extension method to add its share, instead its controller is discovered using the <code>ControllersSeeker</code> property of WebApiShard in its UseApi extension method..</p>"}, {"location": "example-projects/mithril-shards-example-network-bedrock/", "title": "MithrilShards.Example.Network.Bedrock", "text": ""}, {"location": "example-projects/mithril-shards-example-network-bedrock/#mithrilshardsexamplenetworkbedrock", "title": "MithrilShards.Example.Network.Bedrock", "text": "<p>Contains few classes that are implementing the <code>INetworkProtocolMessageSerializer</code> interface needed by the BedrockNetworkShard shard to perform message serialization. In this example we are mimicking bitcoin protocol that uses a magic word (4 bytes) that mark the start of a new message and it's message layout to define the rule to decode and encode messages over the network (see ProtocolDefinition.cs file).</p> <p>Note how the code is really small and how it's easy to define custom network serialization of messages. Current implementation relies on Bedrock framework shard, but if you want to create another lol level network implementation you are free to do so, you don't have to change anything else except this project to make use of your new low level network protocol, everything is abstracted out in the Mithril Shards Core project!!</p>"}, {"location": "example-projects/mithril-shards-example-node/", "title": "MithrilShards.Example.Node", "text": ""}, {"location": "example-projects/mithril-shards-example-node/#mithrilshardsexamplenode", "title": "MithrilShards.Example.Node", "text": "<p>It makes use of System.CommandLine to have implement the application as a CLI.</p> <p>While all other projects were C# Class Library projects, this one produces an executable that's the actual, assembled application.</p> <p>It contains the Program.cs file that melt the shards into the forge and run it, plus a couple of configuration files that you can inspect to see different configuration combinations.</p> <p>Program.cs file is quote short and easy to read:</p> <pre><code>using System.CommandLine;\nusing System.CommandLine.Invocation;\nusing System.Threading.Tasks;\nusing MithrilShards.Core.Forge;\nusing MithrilShards.Dev.Controller;\nusing MithrilShards.Diagnostic.StatisticsCollector;\nusing MithrilShards.Example.Dev;\nusing MithrilShards.Example.Network.Bedrock;\nusing MithrilShards.Example.Protocol;\nusing MithrilShards.Logging.Serilog;\nusing MithrilShards.Network.Bedrock;\nusing Serilog;\n\nnamespace MithrilShards.Example.Node\n{\nstatic class Program\n{\nstatic async Task Main(string[] args)\n{\n// Create a root command with some options\nvar rootCommand = new RootCommand {\nnew Option&lt;string&gt;(\n\"--settings\",\ngetDefaultValue: () =&gt; \"forge-settings.json\",\ndescription: \"Specify the path to the forge settings file.\"),\nnew Option&lt;string?&gt;(\n\"--log-settings\",\ngetDefaultValue: () =&gt; null,\ndescription: \"Specify the path to the forge log settings file. If not specified, try to get logging information from the main forge settings file.\"),\nnew Option&lt;int&gt;(\n\"--protocol-version\",\ngetDefaultValue: () =&gt; KnownVersion.CurrentVersion,\ndescription: \"Specify the path to the forge settings file.\")\n};\n\nrootCommand.Description = \"Example App\";\nrootCommand.TreatUnmatchedTokensAsErrors = false;\n\n// Note that the parameters of the handler method are matched according to the names of the options\nrootCommand.Handler = CommandHandler.Create&lt;string, string, int&gt;(async (settings, logSettings, protocolVersion) =&gt;\n{\nawait new ForgeBuilder()\n.UseForge&lt;DefaultForge&gt;(args, settings)\n.UseSerilog(logSettings)\n.UseBedrockNetwork&lt;ExampleNetworkProtocolMessageSerializer&gt;()\n.UseStatisticsCollector(options =&gt; options.DumpOnConsoleOnKeyPress = true)\n/// we are injecting ExampleDev type to allow &lt;see cref=\"MithrilShards.WebApi.WebApiShard\"/&gt; to find all the controllers\n/// defined there because only controllers defined in an included shard assemblies are discovered automatically.\n/// Passing ExampleDev will cause dotnet runtime to load the assembly where ExampleDev Type is defined and every\n/// controllers defined there will be found later during &lt;see cref=\"MithrilShards.WebApi.WebApiShard\"/&gt; initialization.\n.UseApi(options =&gt; options.ControllersSeeker = (seeker) =&gt; seeker.LoadAssemblyFromType&lt;ExampleDev&gt;())\n.UseDevController()\n.UseExample(KnownVersion.V1, protocolVersion)\n.RunConsoleAsync()\n.ConfigureAwait(false);\n});\n\nawait rootCommand.InvokeAsync(args).ConfigureAwait(false);\n}\n}\n}\n</code></pre>"}, {"location": "example-projects/mithril-shards-example/", "title": "MithrilShards.Example", "text": "<p>MithrilShards.Example project represents the core project where most of the fundamental example application classes lies.</p> <p>Most of the custom application code is implemented here:</p> <ul> <li>network classes like</li> <li>a custom IPeerContext implementation and its factory class</li> <li> <p>some custom <code>IServerPeerConnectionGuard</code> implementation to filter incoming connections and a custom ConnectorBase implementation that contains the logic to connect to other peers</p> </li> <li> <p>protocol classes like</p> </li> <li><code>INetworkMessage</code> implementations of custom messages (payloads) and complex types used within their implementation.</li> <li><code>INetworkMessage</code> and type serializators that serialize classes into a byte representation that can be sent through the network.</li> <li><code>INetworkMessage</code> processors that contain the logic to parse incoming messages and send messages to other peers</li> <li>classes like shard class and its setting class that forms the plumbing of our application.</li> <li>custom services used by processors or other internal components like <code>QuoteService</code>.</li> </ul>"}, {"location": "example-projects/mithril-shards-example/#main-classes", "title": "Main classes", "text": "<p>In the following sections we are going to dissect the project to expose and study the main classes implemented in the project.</p>"}, {"location": "example-projects/mithril-shards-example/#exampleshard", "title": "ExampleShard", "text": "<p>This class represents the core Example Shard, actually it doesn't contains any code but you could extend this example to start for example an async task when the shard starts (<code>StartAsync</code> method) and stop it when it stops (<code>StopAsync</code> method).</p> <p>Note that a shard StartAsync is implicitly called when the forge implementation starts, see DefaultForge for more information.</p>"}, {"location": "example-projects/mithril-shards-example/#examplesettings", "title": "ExampleSettings", "text": "<p>Holds configuration settings for the ExampleShard. You can declare everything may be useful to customize the behavior of the shard by configuration, in this simple example we have few properties</p> <pre><code>public class ExampleSettings : MithrilShardSettingsBase\n{\nconst long DEFAULT_MAX_TIME_ADJUSTMENT = 70 * 60;\n\npublic long MaxTimeAdjustment { get; set; } = DEFAULT_MAX_TIME_ADJUSTMENT;\n\npublic List&lt;ExampleClientPeerBinding&gt; Connections { get; } = new List&lt;ExampleClientPeerBinding&gt;();\n}\n</code></pre> <p><code>Connections</code> parameter is a list of ExampleClientPeerBinding instances that has been added to show how to define and use complex classes within a configuration settings class.</p> <pre><code>/// &lt;summary&gt;\n/// Client Peer endpoint the node would like to be connected to.\n/// &lt;/summary&gt;\npublic class ExampleClientPeerBinding\n{\n/// &lt;summary&gt;IP address and port number of the peer we wants to connect to.&lt;/summary&gt;\n[IPEndPointValidator]\n[Required]\npublic string? EndPoint { get; set; }\n\npublic string? AdditionalInformation { get; set; }\n\npublic bool TryGetExampleEndPoint([MaybeNullWhen(false)] out ExampleEndPoint endPoint)\n{\nendPoint = null;\n\nif (!IPEndPoint.TryParse(EndPoint ?? string.Empty, out IPEndPoint? ipEndPoint))\n{\nreturn false;\n}\n\nif (AdditionalInformation == null)\n{\nreturn false;\n}\n\nendPoint = new ExampleEndPoint(ipEndPoint.Address, ipEndPoint.Port, AdditionalInformation);\nreturn true;\n}\n}\n</code></pre>"}, {"location": "example-projects/mithril-shards-example/#validating-settings", "title": "Validating settings", "text": "<p>ExampleClientPeerBinding class has an EndPoint property that represents the endpoint (IP:Address) of a remote node we'd like to connect to and it's decorated with attributes that are used to validate the configuration during the initialization of the forge.</p> <p>Validation of the settings make use of System.ComponentModel.DataAnnotations and RequiredAttribute used in the example is one of those attribute that belongs to standard set. A different story is [IPEndPointValidator]:</p> <pre><code>/// &lt;summary&gt;\n/// Ensure the value is a valid IPEndPoint.\n/// Null value is considered valid, use &lt;see cref=\"RequiredAttribute\"/&gt; if you don't want to allow null values.\n/// &lt;/summary&gt;\n/// &lt;seealso cref=\"System.ComponentModel.DataAnnotations.ValidationAttribute\" /&gt;\n[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = true)]\npublic class IPEndPointValidator : ValidationAttribute\n{\nprotected override ValidationResult? IsValid(object? value, ValidationContext validationContext)\n{\nif (value is null) return ValidationResult.Success;\n\nstring instance = value as string ?? string.Empty;\n\nif (!IPEndPoint.TryParse(instance, out IPEndPoint? _))\n{\nreturn new ValidationResult($\"Not a valid EndPoint ({instance})\", new string[] { validationContext.MemberName! });\n}\n\nreturn ValidationResult.Success;\n}\n}\n</code></pre> <p>This is a concrete example about how to perform validation for custom settings when default validation attributes aren't enough.</p> <p>Tip</p> <p>Validating settings is important because would stop the node during the forge build process if some settings aren't properly configured, for example if the settings file is malformed or instead of an expected endpoint like in this case, the user specify an incorrect endpoint string. Having a sanity check during validation, allows you to write simpler code when you make use of the setting file, because you can be assured that the values are correct.</p>"}, {"location": "example-projects/mithril-shards-example/#configuration-file", "title": "Configuration file", "text": "<p>To populate ExampleSettings file by using a json configuration file, we have to add <code>Example</code> section in your application configuration file</p> <pre><code>\"Example\": {\n\"MaxTimeAdjustment\": 4200,\n\"Connections\": [\n{\n\"Endpoint\": \"127.0.0.1:45061\",\n\"AdditionalInformation\": \"I'm cool!\"\n}\n]\n}\n</code></pre> <p>Important</p> <p>By inheriting a setting class from [MithrilShardSettingsBase], the section name to specify in the json file is the name of the setting class without the suffix \"Settings\". ExampleSettings becomes then Example. You can override this behavior by overriding ConfigurationSection property in your settings file.</p>"}, {"location": "example-projects/mithril-shards-example/#iquoteservice", "title": "IQuoteService", "text": "<p>This interface (and its QuoteService implementation) is an example of a service used within the example application to provide a random quote to send as a message to our pong reply.</p> <p>It's definition is purposely simple:</p> <pre><code>public interface IQuoteService\n{\nList&lt;string&gt; Quotes { get; }\n\nstring GetRandomQuote();\n}\n</code></pre> <p>Warning</p> <p>In a proper application you wouldn't want to expose directly a list of quotes but rather expose methods like GetQuotes, AddQuote, RemoveQuote, anyway this example goal is to showcase Mithril Shards library and not to teach about how properly write your services classes.</p> <p>QuoteService implementation simply initialize a list of quotes (from The Lord of the Rings movies and books!), exposes the resulting list as a property that can be updated and a method GetRandomQuote to return a random quote from the available quotes.</p> <p>Tip</p> <p>As a further excercise you could try to implement a persistence layer for QuoteService, or a complete different implementation and then replace default QuoteService registration with your own!</p>"}, {"location": "example-projects/mithril-shards-example/#serverpeerconnectionguardbase", "title": "ServerPeerConnectionGuardBase", "text": "<p>This class implements the interface [IServerPeerConnectionGuard] whose purpose is to validate an incoming connection before we attempt to handshake and exchange information with it. It's an abstract class and its purpose is to implement generic useful code to be used by concrete peer guard implementations in such a way that guard implementation has just to focus on the guarding rule. Currently the example implements two guards: </p> <code>MaxConnectionThresholdGuard</code> makes use of ForgeConnectivitySettings to ensure that the number of incoming transaction doesn't exceeds the <code>MaxInboundConnections</code> settings value. <code>BannedPeerGuard</code> ensures that the connecting node isn't flagged as banned in our IPeerAddressBook. Actually it's not honored because the default IPeerAddressBook implementation (<code>DefaultPeerAddressBook</code>) is a fake implementation that just log messages but does nothing. <p>As a reference, this is the MaxConnectionThresholdGuard implementation:</p> <pre><code>public class MaxConnectionThresholdGuard : ServerPeerConnectionGuardBase\n{\nreadonly IConnectivityPeerStats _peerStats;\n\npublic MaxConnectionThresholdGuard(ILogger&lt;MaxConnectionThresholdGuard&gt; logger,\nIOptions&lt;ForgeConnectivitySettings&gt; settings,\nIConnectivityPeerStats serverPeerStats) : base(logger, settings)\n{\n_peerStats = serverPeerStats;\n}\n\ninternal override string? TryGetDenyReason(IPeerContext peerContext)\n{\nif (_peerStats.ConnectedInboundPeersCount &gt;= settings.MaxInboundConnections)\n{\nreturn \"Inbound connection refused: max connection threshold reached.\";\n}\n\nreturn null;\n}\n}\n</code></pre>"}, {"location": "example-projects/mithril-shards-example/#examplerequiredconnection", "title": "ExampleRequiredConnection", "text": "<p>This class implements [IConnector], extending <code>ConnectorBase</code> abstract class. A RequiredConnection connector is already implemented and added by default when we build a forge, this example shows how you can override default registered services with a custom implementation: ExampleRequiredConnection is meant to replace RequiredConnection.</p> <p>By default, to instruct our node to try to connect to specific remote nodes, we can specify these endpoints in <code>ForgeConnectivitySettings Connections</code> property and the RequiredConnection connector will attempt to connect to the specified nodes automatically but since we have our custom list of remote endpoints defined in our ExampleSettings Connections property, we want to use that list instead.</p> <p>Info</p> <p>Check <code>ReplaceServices</code> method in ForgeBuilderExtensions.cs class to see how service replacement is performed.</p>"}, {"location": "example-projects/mithril-shards-example/#protocol-messages", "title": "Protocol Messages", "text": "<p>Of course in a P2P example application we have to talk with other peers, so we need messages to exchange! In this example we implemented four messages: two for the handshake process (borrowed by bitcoin protocol), namely <code>VerackMessage</code> and <code>VersionMessage</code> and two to implement the ping pong logic: <code>PingMessage</code> and <code>PongMessage</code>.</p> <p>Let's just examine one of them and lets pick the one that contains a <code>complex type</code> that has to be serialized over the network.</p>"}, {"location": "example-projects/mithril-shards-example/#pongmessage", "title": "PongMessage", "text": "<pre><code>[NetworkMessage(COMMAND)]\npublic sealed class PongMessage : INetworkMessage\n{\nprivate const string COMMAND = \"pong\";\nstring INetworkMessage.Command =&gt; COMMAND;\n\npublic PongFancyResponse? PongFancyResponse { get; set; }\n}\n</code></pre> <p>A message has to implement [INetworkMessage] interface and be decorated with the [NetworkMessageAttribute] in order to be serialized by the [NetworkMessageSerializerManager].</p> <p>Since the message name, exposed by the <code>Command</code> property, is used both as the return value of the property and as the parameter passed to the NetworkMessageAttribute, a private const string is used to prevent manual errors when creating a new message: just edit the message name in one place.</p> <p>The PongMessage payload just contains one serialized property, PongFancyResponse, and the PongMessageSerializer will show how to serialize this complex type.</p>"}, {"location": "example-projects/mithril-shards-example/#pongfancyresponse", "title": "PongFancyResponse", "text": "<p>This type represent a complex type that is serialized when we send a PongMessage to a peer. We could have added the property that this type contains, straight into the PongMessage class but since this example project has the goal to showcase Mithril Shards features, having a complex type is useful to describe the process needed to handle such scenarios.</p> <p>The class itself is a simple POCO class (it's POCO by choice but it's not mandatory to be so, you can use any kind of class, as long as you implement a serializer for that specific type)</p> <pre><code>public class PongFancyResponse\n{\n/// &lt;summary&gt;\n/// The nonce received from the ping request.\n/// &lt;/summary&gt;\npublic ulong Nonce { get; set; }\n\npublic string? Quote { get; set; }\n}\n</code></pre> <p>Nonce is a simple unsigned long value that's used to link a pong response to a ping request, just returning back the ping Nonce value, while Quote is a nullable string that contains the Quote generated by the node sending the PongMessage.</p> <p>Note</p> <p>Projects within Mithril Shards solution make use of nullable references types and proper <code>.editorconfig</code> configuration to raise warning and exceptions in multiple scenarios and proudly have a 0 warning build (most of the time ).</p>"}, {"location": "example-projects/mithril-shards-example/#protocol-messages-serializers", "title": "Protocol Messages Serializers", "text": "<p>Like for messages, their serializer has to implement an interface, in this case to follow DRY, a base generic class <code>ExampleNetworkMessageSerializerBase&lt;TMessage&gt;</code> is implemented that acts just as placeholder because it contains no code except an empty method and some comments, that explain how doing so you can expand a serializer by having a custom [IPeerContext] like in this example and some helper methods you may find useful in your implementation.</p> <p>Usually you have one message serializer for each message you have, so in this case we have four message serializers: VersionMessageSerializer, VerackMessageSerializer, PingMessageSerializer and PongMessageSerializer.</p>"}, {"location": "example-projects/mithril-shards-example/#pongmessageserializer", "title": "PongMessageSerializer", "text": "<p>Since we have already described the PongMessage in details, makes sense to explain its serializer:</p> <pre><code>/// &lt;summary&gt;\n/// PongMessage serializer, used to serialize and send through the network a &lt;see cref=\"PongMessage\"/&gt;\n/// &lt;/summary&gt;\n/// &lt;seealso cref=\"ExampleNetworkMessageSerializerBase{PongMessage}\" /&gt;\npublic class PongMessageSerializer : ExampleNetworkMessageSerializerBase&lt;PongMessage&gt;\n{\nreadonly IProtocolTypeSerializer&lt;PongFancyResponse&gt; _pongFancyResponseSerializator;\n\npublic PongMessageSerializer(IProtocolTypeSerializer&lt;PongFancyResponse&gt; pongFancyResponseSerializator)\n{\n/// since the pong message has a complex type that can be reused in other payload (well,\n/// this is specific to pong but you get the idea) we are implementing a custom\n/// type serializer and inject it into this message serializer\n_pongFancyResponseSerializator = pongFancyResponseSerializator;\n}\n\npublic override void Serialize(PongMessage message, int protocolVersion, ExamplePeerContext peerContext, IBufferWriter&lt;byte&gt; output)\n{\noutput.WriteWithSerializer(message.PongFancyResponse!, protocolVersion, _pongFancyResponseSerializator);\n}\n\npublic override PongMessage Deserialize(ref SequenceReader&lt;byte&gt; reader, int protocolVersion, ExamplePeerContext peerContext)\n{\nreturn new PongMessage\n{\nPongFancyResponse = reader.ReadWithSerializer(protocolVersion, _pongFancyResponseSerializator)\n};\n}\n}\n</code></pre> <p>What to highlight in this code is: </p> <ul> <li> PongMessageSerializer declares it's a serializer for the PongMessage by extending <code>ExampleNetworkMessageSerializerBase&lt;PongMessage&gt;</code> (note that the generic type argument is PongMessage)</li> <li> It's constructor accepts a <code>IProtocolTypeSerializer&lt;PongFancyResponse&gt; pongFancyResponseSerializator</code>, this will be injected automatically by the DI container when the serializer is resolved and it will be used to serialize the complex type PongFancyResponse.   Later we'll see the PongFancyResponseSerializer that will be used, note how actually we ask for a IProtocolTypeSerializer and at runtime our serializer PongFancyResponseSerializer will be used, no need to worry about knowing the real implementation of our serializer, we can even change it at runtime or using a custom feature that changes serializers, that's the power of abstraction! <li> We have to implement Serialize and Deserialize methods and in this example we are just relying on the extension <code>WriteWithSerializer</code> and <code>ReadWithSerializer</code>, nothing easier than that.   If we had other primitive types to serialize, like an integer property, we had just to use the proper <code>IBufferWriter&lt;byte&gt;</code> primitive extension WriteInt (to serialize) and <code>SequenceReader&lt;byte&gt;</code> ReadInt primitive extension (to read).</li> <p>Info</p> <p>You are encouraged to check source code: IBufferWriterExtensions.cs and SequenceReaderExtensions.cs classes contains all the primitive extensions to serialize primitive types and helper to leverage the use of IProtocolTypeSerializer used to serialize complex types.</p>"}, {"location": "example-projects/mithril-shards-example/#protocol-types-serializers", "title": "Protocol Types Serializers", "text": "<p>When a message contains a complex type like our PongFancyResponse type, we can make use of <code>IProtocolTypeSerializer</code> implementations.</p> <p>In our example we have the PongFancryResponseSerializer class that we can study</p> <pre><code>public class PongFancyResponseSerializer : IProtocolTypeSerializer&lt;PongFancyResponse&gt;\n{\npublic int Serialize(PongFancyResponse typeInstance, int protocolVersion, IBufferWriter&lt;byte&gt; writer, ProtocolTypeSerializerOptions? options = null)\n{\n\nint size = 0;\nsize += writer.WriteULong(typeInstance.Nonce);\nsize += writer.WriteVarString(typeInstance.Quote);\n\nreturn size;\n}\n\npublic PongFancyResponse Deserialize(ref SequenceReader&lt;byte&gt; reader, int protocolVersion, ProtocolTypeSerializerOptions? options = null)\n{\nreturn new PongFancyResponse\n{\nNonce = reader.ReadULong(),\nQuote = reader.ReadVarString()\n};\n}\n}\n</code></pre> <p>The logic is similar to message serializer, we have to implement the interface <code>IProtocolTypeSerializer&lt;TComplextype&gt;</code> that requires us to implement the Serialize and Deserialize method.</p> <p>In this specific example we can see how an unsigned long and a nullable string are serialized in our protocol implementaiton.</p> <p>Tip</p> <p>IProtocolTypeSerializer implementations can inject other IProtocolTypeSerializer implementations if they include other complex types.</p>"}, {"location": "example-projects/mithril-shards-example/#processors", "title": "Processors", "text": "<p>Processors are fundamental classes that allow us to react to incoming messages. Mithril Shards has a clever way to handle messages: whenever a stream of data arrives, it gets read to see if it represents a known messages and if it's the case, all the processors that are registered as interested in that particular message are activated.</p> <p>Technically it's like a publish-subscribe pattern but it's transparent for the developer, everything it's handled by following conventions and implementing specific classes.</p> <p>Processors are attached to a peer context by the Mithril Shards core class NetworkMessageProcessorFactory, their lifetime scope is defined as Transient, this mean that each peer context has its own processor instance attached (processors aren't mean to natively share data between peers but you can anyway create a singleton service that inject in the processor to do so).</p> <p>In our example, an abstract <code>BaseProcessor</code> class implements the code to deal with common needs, it has a lot of helper methods that allow you to subscribe and unsubscribe to event bus messages, react to peer handshake, send messages, execute conditional statement asynchronously and much more (check out the BaseProcess.cs file).</p> <p>Processors can be quite complex, in this example PingPongProcessor is quite simple but still contains useful snippets that you can learn and use.</p>"}, {"location": "example-projects/mithril-shards-example/#pingpongprocessor", "title": "PingPongProcessor", "text": "<p>To shed some light on this, let's inspect the PingPongProcessor, whose goal is to process incoming ping requests and reply with pong messages, or generate ping messages after a certain period of time that has elapsed (it's not meant to be an optimized protocol, in such case you'd want to ping only if you don't receive data from the peer for a certain time, but the goal is to keep the example simple in logic but exhaustive as implementation).</p>"}, {"location": "example-projects/mithril-shards-example/#declaration", "title": "Declaration", "text": "<p>This time I'm not including the full class source code but just meaningful snippets, let's start from the declaration:</p> <pre><code>public partial class PingPongProcessor : BaseProcessor,\nINetworkMessageHandler&lt;PingMessage&gt;,\nINetworkMessageHandler&lt;PongMessage&gt;\n</code></pre> <p>PingPongProcessor inherits from BaseProcessor and is declared as a partial class, because its internal status is declared as an inner class and defined into a nested file PingProcessor.Status.cs. This allow us to restrict Status scope while keeping our source more compact.</p> <p> <sup>In visual studio the inner file is shown as a child of the PingProngProcessor.cs as you can see.</sup></p> <p>It also implements two interfaces: <code>INetworkMessageHandler&lt;PingMessage&gt;</code> and <code>INetworkMessageHandler&lt;PongMessage&gt;</code>. Implementing INetworkMessageHandler generic interface is a way to instruct the Mithril Shards framework that this processor is interested in handling incoming PingMessage and PongMessage.</p> <p>Declarative syntax like this allow us to maintain better our code when we have several processors and allow us to have a better control over which process elaborates which messages without much effort.</p>"}, {"location": "example-projects/mithril-shards-example/#constructor", "title": "Constructor", "text": "<pre><code>public PingPongProcessor(ILogger&lt;PingPongProcessor&gt; logger,\nIEventBus eventBus,\nIPeerBehaviorManager peerBehaviorManager,\nIRandomNumberGenerator randomNumberGenerator,\nIDateTimeProvider dateTimeProvider,\nIPeriodicWork periodicPing,\nIQuoteService quoteService)\n: base(logger, eventBus, peerBehaviorManager, isHandshakeAware: true, receiveMessagesOnlyIfHandshaked: true)\n{\n_randomNumberGenerator = randomNumberGenerator;\n_dateTimeProvider = dateTimeProvider;\n_periodicPing = periodicPing;\n_quoteService = quoteService;\n}\n</code></pre> <p>The constructor declares which services we need and calls the base constructor passing its needed services. I'd emphasize the last 2 base constructor parameter that I've specified by using named arguments to better show their meaning: <code>isHandshakeAware: true, receiveMessagesOnlyIfHandshaked: true</code></p> <p>Specifying true to isHandshakeAware means that the processor is handshake aware and when our peer handshake correctly with a remote peer, <code>OnPeerHandshakedAsync</code> method is invoked. In our example we uses this information to start a periodic task that ensures that we send a ping request every PING_INTERVAL amount of time</p> <pre><code>protected override ValueTask OnPeerHandshakedAsync()\n{\n_ = _periodicPing.StartAsync(\nlabel: $\"{nameof(_periodicPing)}-{PeerContext.PeerId}\",\nwork: PingAsync,\ninterval: TimeSpan.FromSeconds(PING_INTERVAL),\ncancellation: PeerContext.ConnectionCancellationTokenSource.Token\n);\n\nreturn default;\n}\n\nprivate async Task PingAsync(CancellationToken cancellationToken)\n{\nvar ping = new PingMessage();\nping.Nonce = _randomNumberGenerator.GetUint64();\n\nawait SendMessageAsync(ping).ConfigureAwait(false);\n\n_status.PingSent(_dateTimeProvider.GetTimeMicros(), ping);\nlogger.LogDebug(\"Sent ping request with nonce {PingNonce}\", _status.PingRequestNonce);\n\n//in case of memory leak, investigate this.\n_pingCancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);\n\n// ensures the handshake is performed timely\nawait DisconnectIfAsync(() =&gt;\n{\nreturn new ValueTask&lt;bool&gt;(_status.PingResponseTime == 0);\n}, TimeSpan.FromSeconds(TIMEOUT_INTERVAL), \"Pong not received in time\", _pingCancellationTokenSource.Token).ConfigureAwait(false);\n}\n</code></pre> <p>The call to <code>DisconnectIfAsync</code> within PingAsync method, ensures that if the other peers doesn't reply to us with a proper pong messages, we disconnect from the remote peer. The action passed to DisconnectIfAsync gets evaluated when the time specified by <code>TimeSpan.FromSeconds(TIMEOUT_INTERVAL)</code> elapses. Current status of our processor is held in the inner Status class, when we call its PingSent we are resetting the PingResponseTime to 0. When we receive a pong message PingResponseTime  is set to a value and thus when the timeout elapses we are expected to find a value if the peer replied, or 0 if it didn't (and thus disconnect the peer).</p> <p>Warning</p> <p>This logic to works requires that TIMEOUT_INTERVAL is lower than PING_INTERVAL.</p>"}, {"location": "example-projects/mithril-shards-example/#handling-the-pingmessage", "title": "Handling the PingMessage", "text": "<p>As we saw earlier, we declared that the class was implementing INetworkMessageHandler, this mean that we have to implement its ProcessMessageAsync where we can put our logic to handle the ping message: <pre><code>async ValueTask&lt;bool&gt; INetworkMessageHandler&lt;PingMessage&gt;.ProcessMessageAsync(PingMessage message, CancellationToken cancellation)\n{\nawait SendMessageAsync(new PongMessage\n{\nPongFancyResponse = new PongFancyResponse\n{\nNonce = message.Nonce,\nQuote = _quoteService.GetRandomQuote()\n}\n}).ConfigureAwait(false);\n\nreturn true;\n}\n</code></pre> <p>This method is pretty simple, it just sends an async PongMessage, returning the original ping Nonce and a random quote picked from the IQuoteService implementation.</p> <p>Note</p> <p>In this example, ProcessMessageAsync has been implemented as an explicit implementation of the interface, this allows us to hide these methods from the publicly available methods of the type.</p>"}, {"location": "example-projects/mithril-shards-example/#handling-the-pongmessage", "title": "Handling the PongMessage", "text": "<p>Similarly to the PingMessage handler, we implements PongMessage:</p> <pre><code>ValueTask&lt;bool&gt; INetworkMessageHandler&lt;PongMessage&gt;.ProcessMessageAsync(PongMessage message, CancellationToken cancellation)\n{\nif (_status.PingRequestNonce != 0 &amp;&amp; message.PongFancyResponse?.Nonce == _status.PingRequestNonce)\n{\n(ulong Nonce, long RoundTrip) = _status.PongReceived(_dateTimeProvider.GetTimeMicros());\nlogger.LogDebug(\"Received pong with nonce {PingNonce} in {PingRoundTrip} usec. {Quote}\", Nonce, RoundTrip, message.PongFancyResponse.Quote);\n_pingCancellationTokenSource.Cancel();\n}\nelse\n{\nlogger.LogDebug(\"Received pong with wrong nonce: {PingNonce}\", _status.PingRequestNonce);\n}\n\nreturn new ValueTask&lt;bool&gt;(true);\n}\n</code></pre> <p>In this method we check that the returned Nonce is the same of our last ping request, if so we update our internal status to signal that we received the pong message.</p>"}, {"location": "example-projects/mithril-shards-example/#add-the-shard-into-the-forge", "title": "Add the shard into the forge", "text": "<p>To add the shard to the forge, the [IForgeBuilder] extension <code>UseExample</code> in ForgeBuilderExtensions class has to be used, here what it does:</p> <pre><code>/// &lt;summary&gt;\n/// Inject the Example shard.\n/// &lt;/summary&gt;\n/// &lt;param name=\"forgeBuilder\"&gt;The forge builder.&lt;/param&gt;\n/// &lt;param name=\"minimumSupportedVersion\"&gt;The minimum version local nodes requires in order to connect to other peers.&lt;/param&gt;\n/// &lt;param name=\"currentVersion\"&gt;The current version local peer aim to use with connected peers.&lt;/param&gt;\n/// &lt;returns&gt;&lt;/returns&gt;\npublic static IForgeBuilder UseExample(this IForgeBuilder forgeBuilder, int minimumSupportedVersion, int currentVersion)\n{\nif (forgeBuilder is null) throw new ArgumentNullException(nameof(forgeBuilder));\n\nforgeBuilder.AddShard&lt;ExampleShard, ExampleSettings&gt;(\n(hostBuildContext, services) =&gt;\n{\nservices\n.AddSingleton(new NodeImplementation(minimumSupportedVersion, currentVersion))\n.AddSingleton&lt;IDateTimeProvider, DateTimeProvider&gt;()\n.AddSingleton&lt;IQuoteService, QuoteService&gt;()\n.AddPeerGuards()\n.AddMessageSerializers()\n.AddProtocolTypeSerializers()\n.AddMessageProcessors()\n.ReplaceServices();\n});\n\nreturn forgeBuilder;\n}\n</code></pre> <p>As you can see it makes use of AddShard method to register the ExampleShard and specify its settings (ExampleSettings).</p> <p>AddShards exposes an action where you can leverage to register custom services, like in this case IDateTimeProvider, IQuoteService and a lot more. This is a very important aspect because allows you</p> <p>Tip</p> <p>While it's possible to add all service within the AddShard action parameter, I encourage you to split registrations based on their scope and responsibility, like in the example above, it allows you to have a better code base that's easier to manage. </p> <p>You can check the ForgeBuilderExtensions.cs file in MithrilShards.Example project to see all services registered, for example AddPeerGuards is a method in the same file that adds some [IServerPeerConnectionGuard]). AddMessageSerializers and AddProtocolTypeSerializers are two interesting methods that use reflection to automatically register all [INetworkMessageSerializer] and [IProtocolTypeSerializer] defined in this class without having to manually register each one.</p>"}, {"location": "example-projects/running-example/", "title": "Running the example", "text": ""}, {"location": "example-projects/running-example/#running-the-example", "title": "Running the example", "text": "<p>Running just an instance doesn't fully show you how the program behave, it needs at least 2 peers to connect to each other, that's why there are already multiple configuration files configured differently to let you connect two instances together.</p> <p>You can run one instance by setting <code>MithrilShards.Example.Node</code> as the startup project and run the launchSettings profile \"node1\" .</p> <p>Then open a shell at the MithrilShards.Example.Node project path and run the command below</p> <pre><code>dotnet run --no-build --settings forge-settings2.json\n</code></pre> <p>This would cause you to have a debuggable instance running with the configuration defined in <code>forge-settings.json</code> file and another run running on the <code>forge-settings2.json</code> configuration.</p> <p>Alternatively you can run both instances, without a debugger (but you can attach later the process to Visual Studio) by running on two different shells:</p> <pre><code>dotnet run --no-build --settings forge-settings.json\ndotnet run --no-build --settings forge-settings2.json\n</code></pre> <p>The program running forge-settings.json contains the most verbose log level and you'll have the best experience if you install (or use a docker image) of Seq configured on the port specified in your configuration file (e.g. localhost:5341). See SerilogShard for more details.</p> <p>Here an example of the configuration file (forge-settings.json)</p> <pre><code>{\n\"ForgeConnectivity\": {\n\"ForceShutdownAfter\": 300,\n\"MaxInboundConnections\": 25,\n\"AllowLoopbackConnection\": false,\n\"Listeners\": [\n{\n\"IsWhitelistingEndpoint\": true,\n\"Endpoint\": \"0.0.0.0:45051\"\n},\n{\n\"IsWhitelistingEndpoint\": true,\n\"Endpoint\": \"127.0.0.1:45052\",\n\"PublicEndpoint\": \"98.0.0.1:45011\"\n}\n]\n},\n\"Example\": {\n\"MaxTimeAdjustment\": 4200,\n\"Connections\": [\n{\n\"Endpoint\": \"127.0.0.1:45061\",\n\"AdditionalInformation\": \"I'm cool!\"\n}\n]\n},\n\"StatisticsCollector\": {\n\"ContinuousConsoleDisplay\": false,\n\"ContinuousConsoleDisplayRate\": 5\n},\n\"DevController\": {\n\"Enabled\": true\n},\n\"WebApi\": {\n\"EndPoint\": \"127.0.0.1:45020\",\n\"Enabled\": true,\n\"Https\": false\n},\n\n\"Serilog\": {\n\"Using\": [ \"Serilog.Sinks.Console\", \"Serilog.Sinks.Seq\" ],\n\"Enrich\": [ \"FromLogContext\", \"WithMachineName\", \"WithThreadId\" ],\n\"WriteTo\": [\n{\n\"Name\": \"Console\",\n\"Args\": {\n\"IncludeScopes\": true,\n\"theme\": \"Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console\"\n}\n},\n{\n\"Name\": \"Seq\",\n\"Args\": { \"serverUrl\": \"http://localhost:5341\" }\n}\n],\n\"MinimumLevel\": {\n\"Default\": \"Debug\",\n\"Override\": {\n\"Bedrock.Framework\": \"Warning\",\n\"Microsoft\": \"Warning\",\n\"System\": \"Warning\"\n}\n}\n}\n}\n</code></pre>"}, {"location": "example-projects/running-example/#some-screenshots", "title": "Some Screenshots", "text": "<p>Here a screenshot that shows the content of the shell when running the node with settings = <code>forge-settings.json</code></p> <p></p> <p>You can access the Swagger UI by opening the address https://127.0.0.1:45020/docs/index.html </p> <p>Here you can manipulate quotes using the Web API, or even manually attempt to connect to other peers using PeerManagement Connect action in the DEV area.</p> <p>If you installed Seq, you can access the logs in a better way like shown here: </p>"}, {"location": "mithril-shards/", "title": "Overview", "text": ""}, {"location": "mithril-shards/#architecture-overview", "title": "Architecture Overview", "text": "<p>Mithril Shards is a modular framework for building P2P Applications that can be expanded by additional features like Web API endpoints, MQ based services, SignalR hubs, cross platform UI and much more.</p> <p>Pretending to be into a Tolkien universe, I thought of defining features as shards, where each shard of mithril can be put into a forge and fused together with other mithril shards, to create a final artifact.</p> <p>To find analogies with .net naming conventions:</p> <ul> <li>Forge (to be more precise, ForgeBuilder) is a HostBuilder on steroids (actually it encapsulate a HostBuilder instance).</li> <li>Shard is an application part that gets merged into the hostbuilder, using dependency injection, extending its functionality </li> <li>Artifact is just an allegoric view of the result of <code>forgeBuilderInstance.RunConsoleAsync()</code>.</li> </ul> <p>Note</p> <p>Current naming may be subject to changes.</p> <p>To build an application using these concepts, we have to create a ForgeBuilder, specify which Forge type to use and then we can put into the forge all the shards we need by calling <code>AddShard</code> method.</p> <p>Since a shard may require complex configurations and inject service implementations it may need, usually you don't want to call that method directly but instead you'd want to have a <code>IForgeBuilder</code> extension that you can put in a class in your shard project, where your initialization logic happens. That's how .Net core features and services are injected into the host builder and I think it's a good thing to use a similar approach because would be more friendly to devs used to .Net conventions.</p> <p>Each shard may be configured by a strong typed setting class that supports eager validation (would throw if the setting files contains invalid data) and each shard is responsible to register services it needs that would cooperate with the <code>IForge</code> implementation to perform needed tasks, more on this in the specific documentation sections.</p> <p>After all shards are added and ForgeBuilder is started by <code>RunConsoleAsync</code>, the forge will take care of all the plumbing stuff, initializing all the shards.</p> <p>For a detailed description of the components composing the Mithril Shards framework, refers to specific documentation pages.</p> <p>The entry point of a Mithril Shards application is the ForgeBuilder class.</p>"}, {"location": "mithril-shards/default-forge/", "title": "DefaultForge", "text": "<p>The entry point is our forge builder class. After declaring an instance we have to specify which implementation of Forge we want to use. Actually the only available implementation is DefaultForge.</p> <p>DefaultForge is a simple class, it's implemented as a BackgroundService, when the forge is built and ran by the ForgeBuilder, it automatically starts and its <code>ExecuteAsync</code> method is invoked.</p> <p>In this method a default configuration file is generated in case it doesn't exists yet and all registered shards are started (their <code>InitializeAsync</code> method is invoked).</p> <p>After all shards are initialized, they are started by invoking their <code>StartAsync</code> (non awaited) method.</p> <p>From this moment, the forge is running.</p> <p>When the application lifetime ends (in the default scenario by pressing CTRL+C when running in console) <code>StopAsync</code> method is called, which calls <code>StopAsync</code> on all running shards allowing them to close properly.</p>"}, {"location": "mithril-shards/event-bus/", "title": "Event Bus", "text": "<p>Event Bus is a simple implementation of the publish/subscribe pattern which is a messaging pattern that allows two or more actors to publish messages and handle these messages without having a direct relationship between them.</p> <p>Publishers don't know if the message they are publishing is handled and by whom, while subscribers do not know who was the publisher of a specific event: this means that components among Mithril Shards can be loosely coupled </p>"}, {"location": "mithril-shards/forge-builder/", "title": "ForgeBuilder", "text": "<p>ForgeBuilder class represents the entry point of a Mithril Shards application, it allows to add a shard by calling the generic <code>AddShard</code> method, with different overloads that accept an optional strongly typed shard setting file with an optional setting file validator.</p> <p>By using <code>ConfigureLogging</code> it's possible to configure logging, it's basically a wrapper on  the inner HostBuilder ConfigureLogging method, you could use it to have a finer control over logging configuration and available providers, but the easier way to log is by using the available SerilogShard that uses Serilog to configure the logging and relies on a configurable setting file where you can specify which sink to use. You can find more details on its specific documentation page and an example of its usage in the example project</p> <p>After declaring an instance we have to specify which implementation of Forge we want to use. Actually the only available implementation is DefaultForge class.</p>"}, {"location": "mithril-shards/shards/", "title": "Understanding Shards", "text": ""}, {"location": "mithril-shards/shards/#what-is-a-shard", "title": "What is a shard", "text": "<p>When you think about a Mithril Shard, you have to think of it as a set of services that extend the capabilities of the application you are building. In layman's terms shards can augment the final application with additional functionality (features) and this is the core concept of a modular application framework.</p> <p>When you build an application using Mithril Shards you are like a blacksmith in an epic fantasy novel: you chose which shards of mithril to use, put them into the forge, melt them together and finally shape the final: your powerful artifact!</p> <p> <sup>I'd like to know the artist to give him credits for the image above.</sup></p> <p>But we are not living in a Tolkien novel, so what we do is :</p> <ul> <li> choose the shards we need (either by creating them, forking their code or referencing their nuget package)</li> <li> add them to the ForgeBuilder using some extension method that the shard developer has created for us and that may contains some optional parameters</li> <li> configure shards based on their available settings and our needs in the application configuration file (by default it's <code>forge-settings.json</code> but can be changed when the IForge implementation is chosen by calling ForgeBuilder <code>UseForge</code> method)</li> <li> execute the forge builder to run the program.</li> </ul> <p>The example project contains code to show how to achieve this.</p>"}, {"location": "shards/bedrock-network/", "title": "Overview", "text": "<p>BedrockNetworkShard is a very important shard that provides to the forge the required connectivity implementation used to connects to other peers and accept peers connection requests.</p> <p>It implements the connectivity interfaces</p>"}, {"location": "shards/bitcoin/", "title": "Overview", "text": ""}, {"location": "shards/bitcoin/#premise", "title": "Premise", "text": "<p>This folder contains technical documentation that helps to understand the choices behind the implementation and design of current project.</p> <p>Personally I'm not a fan of bitcoin core code base: even if it improved since early days, it's confusing, it lacks of an homogeneous design and architecture and suffers from old bad choices and above all lacks of proper technical documentation, following the mantra \"source code is the documentation\".</p> <p>To be clear, I don't blame who contributes on bitcoin core, I'm just stating objective facts and I hope to fix some of these issues with my project. I don't pretend to have all the documentation always in sync with latest changes because it's a huge effort and I agree at a large extent that source code is the final judge and I encourage you to dig into it if you want to go deeper in implementation details or verify that an information written here is correct.</p> <p>Please, if you find any issue about documentation, feel free to open an issue and I'll be happy to fix it (even a PR with your corrections can be valuable!).</p> <p>To me a proper documentation doesn't have to explain the source code (source code should be as much readable as possible) but it should give insights about the process that leads toward specific implementations and have indications about good practice to work within the built library.</p> <p>Beside this premise, I'm writing this documentation as if I were the target, in order to have a maintainable and easy to follow repository and of course be able to give good understanding about how to extend this project further with custom features (shards) to people that may be interested.</p> <p>Nevertheless I would be happy to know that it could be useful to someone who may find it interesting and help in understanding why an approach has been chosen over another!</p> <p>Also if you have question or want to discuss about technical details, you can use the repository Discussion section.</p>"}, {"location": "shards/bitcoin/#project-overview", "title": "Project Overview", "text": "<p>Bitcoin Mithril Shard has been built on top of Mithril Shards framework. Mithril Shards goal is to be a framework and toolkit to build modular and distributed/P2P applications using .Net 8 stack, focusing both on good design, good practices and performance.</p> <p>Core functionalities can be glued togheter to compose the needed application, ranging from a P2P network layer, Web Api layer, Diagnostic tools, cross platform UI based on blazor, distributed eventing using SignalR, MQ brokers like RabbitMq or any kind of other useful libraries.</p> <p>Thanks to its design, anyone can build it's own Shard to create other features that can be used by Mithril Shards community.</p> <p>More details about Mithril Shards can be found on the main documentation (TODO).</p> <p>Bitcoin shard is a very good example about how to build a fully functional full node for bitcoin, leveraging all the juicy features that Mithril Shards exposes.</p> <ul> <li>Network layer is implemented by leveraging Bedrock Framework for the TCP implementation using both Client and Server connections.   Data is serialized thanks to an well defined set of interfaces and classes that allows to implement an easy to read and maintain code.</li> <li>Incoming messages are dispatched to \"Message Processors\" that allow to handle the application logic following a good practice of separation of concerns.</li> <li>Meaningful events are dispatched using a message bus implementation that can reach any component in any application layer.</li> <li>A Web API infrastructure allow to create Web API endpoint easily and each feature can have its set of API published on different document specifications.   Swagger is used as a UI to expose these API documents and allows to execute these APIs straight from that interface.</li> <li>For development/debugging purpose, a Shard inject some useful endpoint to inspect internal details of the running application.</li> <li>Logging is done using structured logging, makes use of Serilog to persist them and a configuration example shows how to use Seq to have a very good UI to view logs, filter them, etc...</li> <li>Blazor is used to implement a cross platform UI as a companion for the full node.</li> </ul>"}, {"location": "shards/bitcoin/network/", "title": "Network Protocol", "text": "<p>The Bitcoin network protocol is a TCP protocol that serializes messages starting from a special 4 bytes constant data called Magic bytes, followed by 12 bytes representing the command name, 4 bytes representing the payload size and 4 bytes with the checksum of the payload. More specific information about bitcoin protocol can be found here. </p> <p>Mithril Shards implements a low level stack of interfaces and implementations that allow to focus on the application logic instead on low level details. A default implementation uses Bedrock Framework to leverage the low level communication between peers and this is what's used in the Bitcoin shard to provide P2P connectivity.</p> <p>A typical Bitcoin full node (henceforth called FN) is able to connect to other nodes and accept incoming connections. Before two peers can exchange information, they have to perform an handshake to prove that they can understand each other (more details on the the bitcoin network protocol can be found on this bitcoin developer resource).</p> <p>Before being able to handshake, whenever a connection has been established between two peers the FN stores some metadata about the remote peer. This data is stored into a class that implements IPeerContext interface and its implementation represents our next section.</p>"}, {"location": "shards/bitcoin/network/#peer-context", "title": "Peer Context", "text": "<p>Default Mithril Shards implementation uses <code>PeerContext</code> class to store, among other things, information like peer unique identification, direction (inbound/outbound) remote and local endpoints, user agent identification, negotiated protocol version and other attachable properties leveraging the .Net IFeatureCollection interface.</p> <p>Bitcoin needs some additional information and some of the properties that are ubiquitous needed among all optional Bitcoin features (shards) like wallet, APIs, indexer, etc... have been defined directly into <code>BitcoinPeerContext</code> that extends the default <code>PeerContext</code>. Some of the additional properties are Permissions (that may change the FN behavior based on its set) and TimeOffset, that's an important aspect for the consensus logic.</p> <p>Another important property exposed by peer context is the <code>ConnectionCancellationTokenSource</code> property, that's a CancellationTokenSource that can be used to trigger the disconnection from a peer. It's internally used to know when the connection has been closed, to stop the execution of async methods that rely on an active connection to a remote peer.</p> <p>As per <code>IPeerContext</code> interface, <code>ConnectionCancellationTokenSource</code> can only be read so it's important that custom implementation of <code>IPeerContext</code> don't change it's value out of constructor. This property is actively used within message processors (more about it in a later section).</p> <p>The cancellation of <code>ConnectionCancellationTokenSource</code> shouldn't be canceled directly, to force a peer disconnection an event of type <code>PeerDisconnectionRequired</code> has to be published on the event bus, but for simplicity <code>BitcoinPeerContext</code> implements a <code>Disconnect</code> method that does that. So anytime you have a need to disconnect a peer, just call <code>thePeerContext.Disconnect(\"My Disconnection reason!\")</code>. You can find already usage of it in message processor classes.</p> <p>The peer context creation is handled by the core Mithril Shard network implementation and since it can't know about the <code>BitcoinPeerContext</code> properties, it relies on a peer context factory, in this case we are talking about <code>BitcoinPeerContextFactory</code> class.</p> <p>It leverages the generic class <code>PeerContextFactory&lt;&gt;</code> and its implementation is bare bone, no need to override anything.</p> <pre><code>public class PeerContextFactory&lt;TPeerContext&gt; : IPeerContextFactory where TPeerContext : IPeerContext\n</code></pre>"}, {"location": "shards/bitcoin/network/#accepting-a-connection", "title": "Accepting a connection", "text": "<p>Once the peer context has been created, a sanity check is performed to see if the two peers can connect to each other before trying to handshake and the behavior is very similar to both inbound and outbound connections.</p> <p>The only difference is that actually for outgoing connection the check is done before trying to connect but very likely it would be done as per incoming connection soon.</p> <p>What happens when an incoming connection has been accepted is that the connection has to pass all registered (in the DI containers) implementations of <code>IServerPeerConnectionGuard</code> interface.</p>"}, {"location": "shards/bitcoin/network/#serverpeerconnectionguardbase", "title": "<code>ServerPeerConnectionGuardBase</code>", "text": "<p>In Bitcoin shard all guard rules are extending <code>ServerPeerConnectionGuardBase</code> implementation that's a simple class:</p> <pre><code>public abstract class ServerPeerConnectionGuardBase : IServerPeerConnectionGuard\n{\nprotected readonly ILogger logger;\nprotected readonly ForgeConnectivitySettings settings;\n\npublic ServerPeerConnectionGuardBase(ILogger logger, IOptions&lt;ForgeConnectivitySettings&gt; options)\n{\nthis.logger = logger;\nsettings = options.Value;\n}\n\npublic ServerPeerConnectionGuardResult Check(IPeerContext peerContext)\n{\nstring? denyReason = TryGetDenyReason(peerContext);\nif (!string.IsNullOrEmpty(denyReason))\n{\nlogger.LogDebug(\"Peer connection guard not passed: {denyReason}\", denyReason);\nreturn ServerPeerConnectionGuardResult.Deny(denyReason);\n}\n\nreturn ServerPeerConnectionGuardResult.Allow();\n}\n\ninternal abstract string? TryGetDenyReason(IPeerContext peerContext);\n}\n</code></pre> <p>This class implements the plumbing code required to run (and log in case of rule check not passed) the guard rule, so a guard rule implementation has just to focus on its guarding logic. A simple example is the <code>MaxConnectionThresholdGuard</code> rule that ensure that an incoming transaction doesn't exceed the maximum allowed number of inbound connections:</p> <pre><code>public class MaxConnectionThresholdGuard : ServerPeerConnectionGuardBase\n{\nreadonly IConnectivityPeerStats _peerStats;\n\npublic MaxConnectionThresholdGuard(ILogger&lt;MaxConnectionThresholdGuard&gt; logger,\nIOptions&lt;ForgeConnectivitySettings&gt; settings,\nIConnectivityPeerStats serverPeerStats) : base(logger, settings)\n{\n_peerStats = serverPeerStats;\n}\n\ninternal override string? TryGetDenyReason(IPeerContext peerContext)\n{\nif (_peerStats.ConnectedInboundPeersCount &gt;= settings.MaxInboundConnections)\n{\nreturn \"Inbound connection refused: max connection threshold reached.\";\n}\nreturn null;\n}\n}\n</code></pre> <p>In order to be used during connection check, these guard classes have to be registered in the DI container. <code>MaxConnectionThresholdGuard</code> for example is registered into the extension that register the bitcoin shard by using</p> <pre><code>services.AddSingleton&lt;IServerPeerConnectionGuard, InitialBlockDownloadStateGuard&gt;()\n</code></pre> <p>This allow the flexibility of having custom guard rule simply by implementing a rule and register in the DI container, any required service will be injected automatically; of course if it relies on a custom service not already available in my implementation, that service has to be registered too.</p> <p>Info</p> <p>These classes have to be registered as singleton and therefor must be stateless</p> <p>Network protocol is implemented through the serialization of classes which implement <code>INetworkMessage</code> interface and are decorated with <code>NetworkMessageAttribute</code> that works in synergy with an implementation of <code>INetworkMessageSerializer</code> to implement network serialization.</p>"}, {"location": "shards/bitcoin/network/#handshake", "title": "Handshake", "text": "<p>Once a connection has been accepted between two nodes, they start exchanging messages in order to handshake and prove each other they are two compatible nodes that can exchange informations.</p> <p>Info</p> <p>Bitcoin protocol doesn't punish nodes that send unknown messages. I think however that a node has to monitor its connected peer activities and punish them if they send too many unknown messages causing our node to waste resources.</p> <p>Without going too deeper into bitcoin handshake process, the exchanges messages are summarized by this sequence diagram:</p> sequenceDiagram     participant L as Local     participant R as Remote     L--&gt;&gt;+R:Connects to     L-&gt;&gt;+R:Version     R-&gt;&gt;L:Version     R-&gt;&gt;L:Verack     L-&gt;&gt;R:Verack <p>Info</p> <p>Bitcoin protocol doesn't define a specific order for the <code>Remote</code> node to send its <code>Verack</code> and <code>Version</code> message so <code>Local</code> node has to account that and accept these messages in any order.</p>"}, {"location": "shards/bitcoin/testing_node_communication/", "title": "Testing node communication", "text": "<p>In order to test the Forge implementation, I used the handy bitcoin testnet in a box </p> <p>I used the docker implementation:</p> <p><code>docker pull freewil/bitcoin-testnet-box</code></p> <p>then I modified the suggested docker run arguments, in order to open the node port, this way, to run the image with an reachable testnet node, run the image as</p> <p><code>docker run -t -i -p 19000:19000 -p 19001:19001 -p 19011:19011 freewil/bitcoin-testnet-box</code></p> <p>after that, in the tty console, write <code>make start</code> to start the node and this way you can connect to the testnet box using the endpoint <code>127.0.0.1:19000</code></p> <p>If everything is going as expected and you ran the Forge within bitcoin-testnet network, you should see something similar to this</p> <p></p> <p>At the time of the screenshot (2nd of January 2020) only the handshake implementation was ready, this is why of warnings following the successful handshake.</p>"}, {"location": "shards/bitcoin/testing_node_communication/#troubleshooting", "title": "Troubleshooting", "text": ""}, {"location": "shards/bitcoin/testing_node_communication/#systemnetsocketssocketexception-10013", "title": "System.Net.Sockets.SocketException (10013)", "text": "<p>In case you receive this error while trying to open some port for listening, the reason may be your OS is excluding some port ranges for some reason. To check if the port is reserved, you can use the command</p> <p><code>netsh interface ipv4 show excludedportrange tcp</code></p> <p>you'll see a list of port ranges that may include the port you are trying to open. To fix that your best bet is to just change the port you want to use in your configuration file, otherwise you need to understand why a specific port range is being reserved and eventually change it.</p> <p>You can delete the excludedportrange if you want and you know what you are doing, using commands like</p> <p><code>netsh int ipv4 delete excludedportrange protocol=tcp startport=45000 numberofports=100</code></p> <p>and add new ones with  <code>netsh int ipv4 add excludedportrange protocol=tcp startport=45000 numberofports=100</code></p>"}, {"location": "shards/dev-controller/", "title": "Overview", "text": "<p>DevControllerShard is a shard that depends on WebApiShard, it's goal is to inject some useful controllers meant to be used in DEV area.</p> <p>To add DevControllerShard into the forge you can use the <code>IForgeBuilder</code> extension <code>UseDevController</code>.</p> <p>Note</p> <p>This shard register a new ApiServiceDefinition for the dev area, so if you plan implementing a custom feature that aims to add one or more controller to DEV area, remember to add this shard or register yourself the DEV area.</p> <p>Current available controllers are PeerManagementController, ShardsController and StaticsController.</p>"}, {"location": "shards/dev-controller/#peermanagementcontroller", "title": "PeerManagementController", "text": "<p>This controller exposes actions useful to connect or disconnect from a specific peer. It leverages <code>RequiredConnection</code> service whose task is to periodically try to connect to a issued list of peers.</p> <p>The list of peers can be issued both by Connect API or by configuration file using the <code>Connect</code> property of <code>ForgeConnectivitySettings</code> settings, used by BedrockNetworkShard.</p>"}, {"location": "shards/serilog/", "title": "Overview", "text": "<p>SerilogShard allows to inject Serilog log provider into the forge, allowing every service to leverage it to produce a proper loggin implementation for the application.</p> <p>It can be injected into the forge just by using the IForgeBuilder extension</p> <pre><code>public static IForgeBuilder UseSerilog(this IForgeBuilder forgeBuilder, string? configurationFile = null)\n</code></pre> <p><code>configurationFile</code> is optional, and can contain the path of a JSON configuration file, refers to Serilog documentation to see how to configure it properly.</p> <p>If no <code>configurationFile</code> is specified, the forge configuration file is used.</p> <p>Note</p> <p>Using an explicit configuration file allows to have more control over the configuration files used during debug and deploy, because allows you to have a file for application configuration, and a different set of configuration files specific for logging, where you can pre-configure a set of filters based on your needs</p> <p>An example of a configuration section is this:</p> <pre><code>{\n\"Serilog\": {\n\"Using\": [ \"Serilog.Sinks.Console\", \"Serilog.Sinks.Seq\" ],\n\"Enrich\": [ \"FromLogContext\", \"WithMachineName\", \"WithThreadId\" ],\n\"WriteTo\": [\n{\n\"Name\": \"Console\",\n\"Args\": {\n\"IncludeScopes\": true,\n\"theme\": \"Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console\"\n}\n},\n{\n\"Name\": \"Seq\",\n\"Args\": { \"serverUrl\": \"http://localhost:5341\" }\n}\n],\n\"MinimumLevel\": {\n\"Default\": \"Debug\",\n\"Override\": {\n\"Bedrock.Framework\": \"Warning\",\n\"Microsoft\": \"Warning\",\n\"System\": \"Warning\"\n}\n}\n}\n}\n</code></pre> <p>In this example we are defining two serilog sinks: console and seq sink.</p> <p><code>MinimulLevel</code> section allows to configure the filter based on logging severity level, in this case the default level is Debug and we have a couple of override to rise the level to warning for all classes belonging to namespace Bedrok.Framework, Microsoft and System</p> <p>Tweaking these settings is important to reduce the noise of unwanted logs of 3rd party libraries and focus our attention on logs that matter to us.</p>"}, {"location": "shards/serilog/#console-sink", "title": "Console Sink", "text": "<p>Console configure the logger to use console output and in the <code>WriteTo</code> section we specify to include scopes and use a theme to colorize the output.</p> <p>An output example is this</p> <p></p>"}, {"location": "shards/serilog/#seq-sink", "title": "Seq Sink", "text": "<p>Seq  is an interesting web application that can be configured to receive logs generated by Serilog, it has a free plan for single user and in my case it was a good choice for development purpose because I can host it in my local environment and leverage its feature to be able to investigate problems. It can be both installed locally or be hosted in a docker container.</p> <p>In the example above it has been configured to receive logs on port 5341</p> <pre><code>{\n\"Name\": \"Seq\",\n\"Args\": { \"serverUrl\": \"http://localhost:5341\" }\n}\n</code></pre> <p>It shares the same MinimumLevel section to configure which logs will be persisted but can have dynamic overrides.</p> <p>Seq allows you to query, create filters, signals and show structured logs in a friendly way, for further information refers to Seq website.</p> <p>An example of Seq interface with a couple of expanded logs, to show you additional information you can found in these logs</p> <p></p>"}, {"location": "shards/web-api/", "title": "Overview", "text": "<p>WebApiShard is an important shard that allows to expose Web API endpoints based on OpeAPI specifications.</p> <p>Swashbuckle is used under the hood and you can find more technical information about OpenAPI, REST APIs and Swagger concepts on microsoft documentation.</p> <p>WebApiShard comes with a WebApiSettings class that holds settings to configure the service.</p> <p>To add the shard to the forge, the <code>IForgeBuilder</code> extension <code>UseApi</code> has to be called, passing optional <code>options</code> to further configure the service</p> <pre><code>public static IForgeBuilder UseApi(this IForgeBuilder forgeBuilder, Action&lt;WebApiOptions&gt;? options = null)\n</code></pre> <p>WebApiShard implements the Web API controllers using the standard aspnet ControllerBase class but decorates it with a set of default attributes needed to expose these controllers in the right context. To create a proper WebApiShard controller, an abstract base class <code>MithrilControllerBase</code> exists that applies already the required attributes.</p> <pre><code>[ApiController]\n[Produces(\"application/json\")]\n[Route(\"[area]/[controller]/[action]\")]\npublic abstract class MithrilControllerBase : ControllerBase { }\n</code></pre> <p>Areas are used to subdivide APIs based on grouping criteria and each area can be enabled or disabled by configuring the corresponding ApiServiceDefinition. By default two areas are defined but custom areas can be created easily.</p> <pre><code>/// &lt;summary&gt;\n/// Placeholder to define known core Web API areas.\n/// This class may be extended to add more const for 3rd party areas.\n/// &lt;/summary&gt;\npublic abstract class WebApiArea\n{\n/// &lt;summary&gt;\n/// The default API area where common actions will be available.\n/// &lt;/summary&gt;\npublic const string AREA_API = \"api\";\n\n/// &lt;summary&gt;\n/// The area where Dev controllers has to be placed.\n/// Dev controllers are controllers useful during debug that can expose internal details\n/// or are risky to be used in a public environment\n/// They may be risky to execute by an end user that doesn't have good technical details\n/// knowledge about the application.\n/// &lt;/summary&gt;\npublic const string AREA_DEV = \"dev\";\n}\n</code></pre> <p>Note</p> <p>WebApiShard controllers have to belong to a specific area. More information in Creating a Controller section.</p> <p><code>DisableByEndPointActionFilterAttribute</code> class, that's a registered ActionFilterAttribute, is responsible to enforce proper checks against executing an action on an unspecified, unknown or disabled area.</p> <p>Warning</p> <p>The current implementation may be subject to changes to implement the authentication and authorization layer.</p>"}, {"location": "shards/web-api/areas/", "title": "Web API Areas", "text": "<p>WebApiShard organize controllers assigning them to specific areas.  </p> <p>Areas are used to subdivide APIs based on grouping criteria and each area can be enabled or disabled by configuring the corresponding ApiServiceDefinition. By default two areas are defined:</p> <pre><code>/// &lt;summary&gt;\n/// Placeholder to define known core Web API areas.\n/// This class may be extended to add more const for 3rd party areas.\n/// &lt;/summary&gt;\npublic abstract class WebApiArea\n{\n/// &lt;summary&gt;\n/// The default API area where common actions will be available.\n/// &lt;/summary&gt;\npublic const string AREA_API = \"api\";\n\n/// &lt;summary&gt;\n/// The area where Dev controllers has to be placed.\n/// Dev controllers are controllers useful during debug that can expose internal details\n/// or are risky to be used in a public environment\n/// They may be risky to execute by an end user that doesn't have good technical details\n/// knowledge about the application.\n/// &lt;/summary&gt;\npublic const string AREA_DEV = \"dev\";\n}\n</code></pre> <p>Custom areas can be created easily by defining them using ApiServiceDefinition. DevControllerShard for example defines its own ApiServiceDefinition to group all controllers meant to be used for development / diagnostic purpose.</p> <p>Note</p> <p>Any WebApiShard compliant controller has to belong to a specific area, by specifying an <code>AreaAttribute</code> at controller class level.</p>"}, {"location": "shards/web-api/areas/#apiservicedefinition", "title": "ApiServiceDefinition", "text": "<p>ApiServiceDefinition is a class responsible to hold a WEB Api area configuration. It contains an <code>Enabled</code> property used to enable or disable that specific area and its value is usually set by using the configuration file of the shard responsible for the ApiServiceDefinition.</p> <p>DevControllerShard code shows an example of how to register an area during the shard registration:</p> <pre><code>forgeBuilder.AddShard&lt;DevControllerShard, DevControllerSettings&gt;((context, services) =&gt;\n{\nif (context.GetShardSettings&lt;DevControllerSettings&gt;()!.Enabled)\n{\nservices.AddApiServiceDefinition(new ApiServiceDefinition\n{\nArea = WebApiArea.AREA_DEV,\nName = \"Dev API\",\nDescription = \"API useful for debug purpose.\",\nVersion = \"v1\",\n});\n}\n});\n</code></pre> <p>In this example you can see that <code>Area</code> is set to <code>WebApiArea.AREA_DEV</code> that's simply a constant string that's the equivalent of set it to <code>\"dev\"</code> and Enabled is set to <code>settings.Enabled</code>, this way it's enabled or disabled based on the <code>DevControllerSettings</code> configuration.</p> <p>Note</p> <p>Each different ApiServiceDefinition generates an OpenAPI document following its specification. Swagger UI allows to select which document to show, see Using Swagger UI section. An OpenAPI document can be used by tools like AutoRest to generate automatically clients for RESTful API, not just for C# but for many other languages (after all OpenAPI is an agnostic specification).</p>"}, {"location": "shards/web-api/areas/#creating-custom-areas", "title": "Creating custom areas", "text": "<p>The process to create a custom area is the same as the one shown in the example above, the only difference is the <code>Area</code> value, that can be any string.</p> <p>If we want to create an area named \"area51\" and be available for controllers defined in our shards or a 3rd party shards, we can register such area by creating a new ApiServiceDefinition instance and register it using AddApiServiceDefinition:</p> <pre><code>forgeBuilder.AddShard&lt;YourShard, YourShardSettings&gt;((context, services) =&gt;\n{\nif (context.GetShardSettings&lt;YourShardSettings&gt;()!.Enabled)\n{\nservices.AddApiServiceDefinition(new ApiServiceDefinition\n{\nEnabled = true,\nArea = \"area51\",\nName = \"Area 51 - trust no one!\",\nDescription = \"Nothing to see here...\",\nVersion = \"v1\",\n});\n}\n});\n</code></pre> <p>The example above implies that YourShardSettings has a <code>Enabled</code> boolean property that describes if the shard has to generate or not an ApiServiceDefinition. You are free to skip that check if you want to have an area always defined and/or want to tweak the ApiServiceDefinition Enabled property at runtime based on some custom conditions.</p> <p>Note</p> <p>An ApiServiceDefinition can be enabled or disabled at runtime by changing its <code>Enabled</code> property. Registering an area implicitly generates its OpenAPI document, but access to its API are controlled by its Enabled property.</p> <p>In order to have controllers assigned to such area, a controller has to be decorated with an Area attribute like in this example:</p> <pre><code>[Area(\"area51\")]\npublic class YourAreaController : MithrilControllerBase\n</code></pre> <p>You can find more information on controller creation in the Creating a Controller section.</p>"}, {"location": "shards/web-api/creating-a-controller/", "title": "Creating a Controller", "text": "<p>To create a controller that can be exposed by the WebApiShard we can take advantage of the <code>MithrilControllerBase</code> class.</p> <p>We can take a look at the controller implemented in the example project, to dissect it and discuss about its implementation.</p> <p>Let's take a meaningful part of that class and let's dissect it by highlighting some code part:</p> <pre><code>[Area(WebApiArea.AREA_API)]\npublic class ExampleController : MithrilControllerBase\n{\nprivate readonly ILogger&lt;ExampleController&gt; _logger;\nreadonly IQuoteService _quoteService;\n\npublic ExampleController(ILogger&lt;ExampleController&gt; logger, IQuoteService quoteService)\n{\n_logger = logger;\n_quoteService = quoteService;\n}\n\n[HttpGet]\n[ProducesResponseType(StatusCodes.Status200OK)]\npublic ActionResult GetQuotes()\n{\nreturn Ok(_quoteService.Quotes);\n}\n</code></pre>"}, {"location": "shards/web-api/creating-a-controller/#define-the-area", "title": "Define the area", "text": "<p>Line 1 describes, using AreaAttribute, the area we want this controller to be included.</p> <p>WebApiArea is an helper class that just contains a bounch of constant string of known areas: \"api\" and \"dev\".</p> <ul> <li>\"api\" ( <code>WebApiArea.AREA_API</code> ) is the area where generic purpose controller should be placed.   They are meant to be used by end users or 3rd party integration, to interact with our application.</li> <li>\"dev\" ( <code>WebApiArea.AREA_DEV</code> ) is the area where Dev controllers should be placed.   Dev controllers are controllers useful during debug that can expose internal details or are risky to be used in a    public environment.   They may be risky to execute by an end user that doesn't have good technical details knowledge about the application and generally you want to enable them when you are developing or you need to collect more information on a running instance of your application.</li> </ul> <p>There are some Controllers that are available out of the box when you use Mithril Shards features, an example is SerilogShard that includes SeriLogController that allows to control Log filters at runtime and it's exposed in the \"api\" area, while many more Controllers are exposed in \"dev\" area like the ones included by DevControllerShard.</p> <p>Tip</p> <p>You can create custom areas, for more information see Web API Areas documentation.</p>"}, {"location": "shards/web-api/creating-a-controller/#declare-controller-type", "title": "Declare controller Type", "text": "<p>Line 2 is the Controller class definition and it just declare our <code>ExampleController</code> class that inherit from MithrilControllerBase. The name of the controller class is important because by default the actions implemented in the controller will have a route like the one defined by RouteAttribute that decorates the MithrilControllerBase</p> <pre><code>[Route(\"[area]/[controller]/[action]\")]\n</code></pre> <ul> <li>area will be replaced by the are we declared our controller belongs to (e.g. \"api\").</li> <li>controller is the name of the Controller class, stripping out \"Controller\" part, e.g. ExampleController will become \"Example\"</li> <li>action is the name of the action we can invoke</li> </ul> <p>ExampleController action GetQuotes URL will then become <code>api/Example/GetQuotes</code>. This represents the part of the URL to append to the WebApiShard configured Endpoint, so if we configured it to <code>127.0.0.1:45030</code> the complete URL will be <code>http://127.0.0.1:45020/api/Example/GetQuotes</code> (or https if we enabled Https).</p>"}, {"location": "shards/web-api/creating-a-controller/#inject-services-into-constructor", "title": "Inject services into constructor", "text": "<p>Line 7-10 is the Controller constructor. A controller is created automatically at each web request and the parameters declared in the constructor will be populated by using DI In this example, <code>ILogger&lt;ExampleController&gt; logger</code> gets populated with strongly typed instance of our logger and IQuoteService quoteService with the instance of the concrete implementation of our <code>IQuoteService</code> that in our example project we registered as a singleton</p> <pre><code>.AddSingleton&lt;IQuoteService, QuoteService&gt;()\n</code></pre> <p>Note</p> <p>It's important to know the life cycle of our injected service because they may impact performance. If the constructor of a service is slow and that service is defined as Transient (or Scoped) every action will have to wait its completion before being able to perform its job.</p>"}, {"location": "shards/web-api/creating-a-controller/#implement-an-action", "title": "Implement an action", "text": "<p>Lines 13-18 declare and implement an action.</p> <p>In this case, the action is declared as <code>HttpGet</code>, this mean that it will only respond to GET requests. If you try to access that action with others HTTP verbs, it will return a status error <code>405 Method Not Allowed</code></p> <p><code>[ProducesResponseType(StatusCodes.Status200OK)]</code> declare known action status that can be returned by the action. It's just an helpful attribute useful to produce a better documentation on swagger interface and document definition but the action itself may even generate different statuses. This documentation however don't cover canonical Web API implementation, so refer to .Net documentation. to read more about it.</p> <p>To return an action result, the method <code>Ok</code> is invoked, passing the payload (that will be serialized in JSON) as a response.</p> <p>To document better the result type, we could specify in ProduceResponseTypeAttribute the returned type, it could be helpful for the consumer to know which type of object to receive back and which properties it exposes. In this example it's a simple list of string but it can be any JSON serializable type:</p> <pre><code>[ProducesResponseType(StatusCodes.Status200OK, Type = typeof(List&lt;string&gt;))]\n</code></pre> <p>As an additional example, this is the code of a DEV controller action that generates different status based on internal state of the node</p> <pre><code>[HttpPost]\n[ProducesResponseType(StatusCodes.Status200OK)]\n[ProducesResponseType(StatusCodes.Status404NotFound)]\n[ProducesResponseType(StatusCodes.Status400BadRequest)]\npublic IActionResult Connect(PeerManagementConnectRequest request)\n{\nif (_requiredConnection == null)\n{\nreturn NotFound($\"Cannot produce output because {nameof(RequiredConnection)} is not available\");\n}\n\nif (!IPEndPoint.TryParse(request.EndPoint, out IPEndPoint? ipEndPoint))\n{\nreturn ValidationProblem(\"Incorrect endpoint\");\n}\n\n_requiredConnection.TryAddEndPoint(ipEndPoint);\nreturn Ok();\n}\n</code></pre> <p>In this example, this action will return 404 (not found) if the member variables _requiredConnection isn't set, or 400 (bad request) if the input peer isn't formatted properly as a valid endpoint. If everything goes fine it will instead return 200 (ok).</p> <p>Tip</p> <p>In case of action problems, instead of calling BadRequest or Problem method extensions, use <code>ValidationProblem</code>, it uses a ValidationProblemDetails response that's consistent with automatic validation error responses, as stated here. In the example above, NotFound could be replaced with ValidationProblem too for a consistent behavior.</p>"}, {"location": "shards/web-api/creating-a-controller/#producing-documentation-for-swagger-ui", "title": "Producing documentation for Swagger UI", "text": "<p>In order to produce proper documentation to be shown on Swagger UI, XML comments within C# source can be used but the build process has to generate a documentation file.</p> <p>The easier way is to edit your project file adding this snippet:</p> <pre><code>&lt;PropertyGroup&gt;\n&lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;\n&lt;/PropertyGroup&gt;\n</code></pre> <p>For Mithril Shards project defined within the Mithril Shard solution folder this is not necessary because that snippet is already defined in <code>Directory.Build.props</code> file.</p> <p>Note</p> <p>WebApiShard already take care of including documentation files by looking at files with the name of the assembly that contains the controller, with an <code>.xml</code> extension. <code>var xmlFile = $\"{assembly.GetName().Name}.xml\";</code></p> <p>Tip</p> <p>Directory.Build.props file is a powerful way to set common project configurations for complex solutions with multiple projects, you can read more about it here.</p>"}, {"location": "shards/web-api/swagger-ui/", "title": "Using Swagger UI", "text": "<p>Swagger UI allows to visualize and interact with the Web API resources generated from OpenAPI toolset. WebApiShard makes use of it and thus we can have a nice UI to test and document our API.</p> <p>As stated in ApiServiceDefinition section, each area generates a different OpenAPI document and we can use tool like Swagger UI to convert that specification to turn that document into an UI that allows us to test and read documentation about our exposed API resources.</p> <p>An OpenAPI document can even be used by tools like AutoRest to generate automatically clients (in different programming languages) for RESTful API!</p> <p>Note</p> <p>Mithril Shards customizes a bit the look of Swagger UI but it will be familiar to who is already used to work with it.</p> <p>The address to access swagger UI depends on WebApiSettings <code>EndPoint</code> parameter.</p> <p>If we consider the default EndPoint <code>127.0.0.1:45020</code>, a WebApiShard enabled application exposes Swagger at the url </p>"}, {"location": "shards/web-api/swagger-ui/#swagger-ui-elements", "title": "Swagger UI Elements", "text": "<p>Without going too deeper into documenting the UI (there are a lot of resources on the web about Swagger UI and anyway it's pretty straightforward) I want to highlight a couple of sections</p> <p></p>"}, {"location": "shards/web-api/swagger-ui/#document-selection", "title": "Document Selection", "text": "<p>It's a combo box that allows you to select one of the ApiServiceDefinition defined area that are currently enabled. In this example we have selected API that corresponds to our <code>WebApiArea.API</code> (or simply \"api\") area defined by WebApiShard itself. You can see another option, DEV API, that corresponds to the <code>WebApiArea.DEV</code> (or simply \"dev\") area defined by DevControllerShard.</p> <p>Note</p> <p>The displayed name corresponds to ApiServiceDefinition <code>Name</code> property.</p>"}, {"location": "shards/web-api/swagger-ui/#openapi-document-url", "title": "OpenAPI document URL", "text": "<p>It's the URL of the selected OpenAPI document. It can be used to generate RESTful clients with tools like AutoRest.</p>"}, {"location": "shards/web-api/swagger-ui/#search-box", "title": "Search Box", "text": "<p>Allows to filter Web API resources by their name or description.</p>"}, {"location": "shards/web-api/swagger-ui/#performing-an-api-request", "title": "Performing an API request", "text": "<p>By clicking on an API entry, it's possible to execute it by clicking on <code>Try it out</code> button, filling the required data (in this example the field <code>quote</code>) and then pressing the \"Execute\" button that will be displayed</p> <p></p> <p>Note</p> <p>It is possible to provide examples and more documentation by using C# XML comments, you can find more information in the section Include Descriptions from XML Comments on Swashbuckle.AspNetCore repository or by looking at the <code>ExampleController</code> source code in the MithrilShards.Example.Dev project.</p> <p>The screenshot above shows the <code>AddQuote</code> action in the example project and it has been fully documented:</p> <pre><code>/// &lt;summary&gt;\n/// Adds a quote.\n/// &lt;/summary&gt;\n/// &lt;param name=\"quote\" example=\"Tu quoque, Brute, fili mi!\"&gt;The quote to add.&lt;/param&gt;\n/// &lt;response code=\"200\"&gt;The quote that has been added.&lt;/response&gt;\n/// &lt;remarks&gt;\n/// Adds a quote to the quotes list.\n/// &lt;/remarks&gt;\n[HttpPost]\n[ProducesResponseType(StatusCodes.Status200OK)]\npublic ActionResult AddQuote(string quote)\n{\n_quoteService.Quotes.Add(quote);\n\n_logger.LogDebug(\"A new quote has been added: `{Quote}`\", quote);\n\nreturn Ok(quote);\n}\n</code></pre>"}, {"location": "shards/web-api/using-webapishard/", "title": "Using WebApiShard", "text": ""}, {"location": "shards/web-api/using-webapishard/#add-webapiservice-to-the-forge", "title": "Add WebApiService to the forge", "text": "<p>To add the shard to the forge, the <code>IForgeBuilder</code> extension <code>UseApi</code> has to be called, passing optional <code>options</code> to further configure the service</p> <pre><code>public static IForgeBuilder UseApi(this IForgeBuilder forgeBuilder, Action&lt;WebApiOptions&gt;? options = null)\n</code></pre>"}, {"location": "shards/web-api/using-webapishard/#webapioptions", "title": "WebApiOptions", "text": "<p>WebApiOptions class allows to customize the discovery process that's responsible to find and register Web API controllers end include them into a specific ApiServiceDefinition.</p> <p>The discovery process happens during WebApiShard initialization: it generates an ApplicationPart for each registered shard that will include all discovered <code>MithrilControllerBase</code>(ControllerBase) types defined in the shard assembly.</p>"}, {"location": "shards/web-api/using-webapishard/#controllersseeker", "title": "ControllersSeeker", "text": "<p>Sometimes you may have a project that just holds Controllers but isn't exposed as a shard, in this scenario you can use WebApiOptions during the call of UseApi, to explicitly add an assembly to inspect for controllers.</p> <p>The example project makes use of this when it builds the forge:</p> <pre><code>/// we are injecting ExampleDev type to allow &lt;see cref=\"WebApi.WebApiShard\"/&gt; to find all the controllers\n/// defined there because only controllers defined in an included shard assemblies are discovered automatically.\n/// Passing ExampleDev will cause dotnet runtime to load the assembly where ExampleDev Type is defined and every\n/// controllers defined there will be found later during &lt;see cref=\"WebApi.WebApiShard\"/&gt; initialization.\n.UseApi(options =&gt; options.ControllersSeeker = (seeker) =&gt; seeker.LoadAssemblyFromType&lt;ExampleDev&gt;())\n</code></pre> <p>By doing this WebApiOptions will create an Application part for each explicitly added assembly and all Controller types defined in that assembly will be found and added to the available controllers in their specific area.</p>"}, {"location": "shards/web-api/using-webapishard/#enablepublicapi", "title": "EnablePublicApi", "text": "<p>This settings enables or disables the public API area. The public area corresponds to the ApiServiceDefinition that's responsible to enable all controllers assigned to the area <code>WebApiArea.AREA_API</code>. </p> <p>If you are creating an application where a public area is never needed, you may want to use this property rather than relying on external configuration file that may be missing or edited.</p>"}, {"location": "shards/web-api/using-webapishard/#publicapidescription", "title": "PublicApiDescription", "text": "<p>This settings allow to customize the description used to describe public API. Defaults to <code>Mithril Shards public API</code>.</p>"}, {"location": "shards/web-api/using-webapishard/#title", "title": "Title", "text": "<p>Configures the Swagger UI page title, useful for branding. Defaults to <code>Mithril Shards Web API</code>.</p>"}, {"location": "shards/web-api/using-webapishard/#webapisettings", "title": "WebApiSettings", "text": "<p>WebApiSettings is the class that holds configuration settings required by the shard to works. It contains few properties to configure the endpoint used to listen to API requests and its behavior:</p> Property Type Description Default EndPoint string IP address and port number on which the shard will serve its Web API endpoint, in the form of <code>ip_address:port</code>. \"127.0.0.1:45020\" Https bool Whether WEB API should be exposed on HTTPS. false Enabled bool Whether WebApiShard is enabled or not. Disabling it would cause any shard depending on WebApiShard, such as custom controllers or custom areas, to be unable to be served. true <p>Configuration properties can be set in the application configuration file, within its root section, under the name of <code>WebApi</code></p> <p>Note</p> <p>every shard configuration section is mapped by default to the name of the configuration setting class, stripping out the <code>Settings</code> part</p> <p>example:</p> <pre><code>\"WebApi\": {\n\"EndPoint\": \"127.0.0.1:45030\",\n\"Enabled\": false,\n\"Https\": false\n}\n</code></pre>"}]}