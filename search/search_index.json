{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mithril Shards Goal Mithril Shards goal is to implement a .NET 5 extensible P2P network & distributed services library from scratch with focus on architecture and performance. Allows you to define custom network serialization protocol, easily handle payload messages and interact with the software leveraging any available features (named Shards) like WEB Api endpoints, Blazor UI, and a lot of other exciting stuffs that community can implements and release to the public too! The project is very ambitious and it's currently developed just by me as a pet project but a huge effort has gone into already and some part of this unique code base has been already reused in other blockchain technologies to improve their performance. Current Tech A random list of available tech used within Mithril Shards. .Net 5 - ... for everything. Bedrock Framework - TCP/IP default connectivity implementation. Swashbuckle - to handle WEB Api (multiple) documents and have a playground to test APIs with swagger. Serilog - default logging implementation. BenchmarkDotNet - a benchmark framework, very handy to benchmark different approach during implementation phases. Blockchain tech inside As a proof of concept, a new Bitcoin full node is being developed using this library, actually hosted in this repository (it's a WIP project). Why Mithril Shards? Well... let's bullet some facts I like fantasy a lot, J.R.R. Tolkien of course has been one of my reads and mithril is a fictional metal in his universe. The main properties of mithri are: being very strong, light and in its pure form very malleable to work with. I'm a developer that like to curate its software to be extensible and solid. Now take these informations, mix them up, and you'll see that to I aim to have a robust, fast and flexible project! So this explain mithril, while about Shards , is because I see this project as a mix of shards that can be assembled togheter to give you a precious artifact! In fact you shouldn't be surprised that the root class is called Forge... who says we can't have a bit of fun while designing a software? Call to Action! Join to give feedback, ask for features, support, etc... Discord server: https://discord.gg/T9kyKz4bAu CI Current status","title":"Welcome"},{"location":"#mithril-shards","text":"","title":"Mithril Shards"},{"location":"#goal","text":"Mithril Shards goal is to implement a .NET 5 extensible P2P network & distributed services library from scratch with focus on architecture and performance. Allows you to define custom network serialization protocol, easily handle payload messages and interact with the software leveraging any available features (named Shards) like WEB Api endpoints, Blazor UI, and a lot of other exciting stuffs that community can implements and release to the public too! The project is very ambitious and it's currently developed just by me as a pet project but a huge effort has gone into already and some part of this unique code base has been already reused in other blockchain technologies to improve their performance.","title":"Goal"},{"location":"#current-tech","text":"A random list of available tech used within Mithril Shards. .Net 5 - ... for everything. Bedrock Framework - TCP/IP default connectivity implementation. Swashbuckle - to handle WEB Api (multiple) documents and have a playground to test APIs with swagger. Serilog - default logging implementation. BenchmarkDotNet - a benchmark framework, very handy to benchmark different approach during implementation phases.","title":"Current Tech"},{"location":"#blockchain-tech-inside","text":"As a proof of concept, a new Bitcoin full node is being developed using this library, actually hosted in this repository (it's a WIP project).","title":"Blockchain tech inside"},{"location":"#why-mithril-shards","text":"Well... let's bullet some facts I like fantasy a lot, J.R.R. Tolkien of course has been one of my reads and mithril is a fictional metal in his universe. The main properties of mithri are: being very strong, light and in its pure form very malleable to work with. I'm a developer that like to curate its software to be extensible and solid. Now take these informations, mix them up, and you'll see that to I aim to have a robust, fast and flexible project! So this explain mithril, while about Shards , is because I see this project as a mix of shards that can be assembled togheter to give you a precious artifact! In fact you shouldn't be surprised that the root class is called Forge... who says we can't have a bit of fun while designing a software?","title":"Why Mithril Shards?"},{"location":"#call-to-action","text":"Join to give feedback, ask for features, support, etc... Discord server: https://discord.gg/T9kyKz4bAu","title":"Call to Action!"},{"location":"#ci","text":"Current status","title":"CI"},{"location":"_private/note/","text":"Tutto quello che la dependency injection injetta ed \u00e8 disposable, viene automaticamente disposed","title":"Note"},{"location":"_private/todo/","text":"Le consensus rule le definir\u00f2 con delle extensions/metodi parlanti Un modo potrebbe essere quello di avere una classe che espone tutti dati base necessari alle regole affinch\u00e8 vengano eseguite. Ad esempio ci deve essere un modo per recuperare il previous output di una transazione. Il codice di tale controllo (guard?) si potrebbe aggiungere ad una specie di dictionary, di modo che altre regole possano sfruttare lo stesso codice, sfruttando magari il concetto di cache (se un altra regola ha gi\u00e0 chiamato quella funzione, il valore restituito deve essere lo stesso e quindi si pu\u00f2 restituire il valore precedente, che va quindi cachato) Un modello di riferimento a quanto ho in mente \u00e8 il funzionamento di ngrx per angular: Bisogna avere uno stato immutabile che pu\u00f2 essere restituito a chi necessit\u00e0 di informazioni. L'immutabilit\u00e0 dello stato fa si che non ci possano essere errori dove per sbaglio una regola cambia il valore dello stato e quindi un'altra regola che richiede la stessa informazione otterr\u00e0 valori diversi (le regole devono essere idempotenti) Continuando l'analogia con ngrx, lo stato esportato alle varie rules deve essere ovviamente uno stato comune e le regole potrebbero agire a livello di selector. Il valore iniziale dello stato va impostato all'inizio del ciclo di validazione. L'unico momento in cui lo stato si pu\u00f2 modificare \u00e8 quando una transazione viene validata (full) in quanto in quel momento sta virtualmente alterando lo stato nuovo (e.g. dobbiamo evitare il double spending quindi dobbiamo evitare di mettere nello stesso blocco due transazioni che spendono lo stesso input) In alternativa potremmo avere uno stato parallelo contenente solo le transazioni validate, questo per\u00f2 richiederebbe al consensus rule di agire su due stati diversi (ma non sarebbe un problema e forse sarebbe pure una soluzione pi\u00f9 appropriata)","title":"Todo"},{"location":"_private/bitcoin/raw-messages/","text":"PACKETS EXAMPLE Bitcoin Regtest sendheaders FA BF B5 DA 73 65 6E 64 68 65 61 64 65 72 73 00 00 00 00 00 5D F6 E0 E2 sendcmpct FA BF B5 DA 73 65 6E 64 63 6D 70 63 74 00 00 00 09 00 00 00 E9 2F 5E F8 00 02 00 00 00 00 00 00 00 FA BF B5 DA 73 65 6E 64 63 6D 70 63 74 00 00 00 09 00 00 00 CC FE 10 4A 00 01 00 00 00 00 00 00 00 ping FA BF B5 DA 70 69 6E 67 00 00 00 00 00 00 00 00 08 00 00 00 39 AD 44 A3 0C 8E 5A C3 A0 0D F3 2F getheaders FA BF B5 DA 67 65 74 68 65 61 64 65 72 73 00 00 E5 00 00 00 8A 94 35 BC 7F 11 01 00 06 2A 82 9C AD 81 6A 70 3D E3 5F 2B 18 9A 10 DA 4B 08 93 0A E9 6E ED C0 D7 32 12 8B 9A 91 C1 3B 51 8C 68 7D 8E D2 23 90 00 16 C6 70 50 AB 04 4A 6F 3A B0 4C 00 29 78 BF 5E 7B 7A A9 2D 56 4B 03 58 10 94 3F CC 3B C5 06 99 5A 7F 37 6B A1 6D 6C 80 CF 59 6B AC CC D9 09 34 11 F6 AE 44 D1 04 BF 42 97 FB CE AF 53 A8 3C FC 91 6A CD E8 11 6B C4 9E D3 62 AB A6 EC 34 C5 91 99 20 DC 43 06 E0 29 3B BA 09 3E E7 1E 02 18 A0 7C 4D 92 B0 47 29 0D FD 5B C0 80 89 76 58 E6 A8 89 90 1B 5A BD C3 F2 5B 06 22 6E 46 11 1A 0B 59 CA AF 12 60 43 EB 5B BF 28 C3 4F 3A 5E 33 2A 1F C7 B2 B7 3C F1 88 91 0F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 FA BF B5 DA 66 65 65 66 69 6C 74 65 72 00 00 00 08 00 00 00 E8 0F D1 9F E8 03 00 00 00 00 00 00","title":"PACKETS EXAMPLE"},{"location":"_private/bitcoin/raw-messages/#packets-example","text":"","title":"PACKETS EXAMPLE"},{"location":"_private/bitcoin/raw-messages/#bitcoin-regtest","text":"","title":"Bitcoin Regtest"},{"location":"_private/bitcoin/raw-messages/#sendheaders","text":"FA BF B5 DA 73 65 6E 64 68 65 61 64 65 72 73 00 00 00 00 00 5D F6 E0 E2","title":"sendheaders"},{"location":"_private/bitcoin/raw-messages/#sendcmpct","text":"FA BF B5 DA 73 65 6E 64 63 6D 70 63 74 00 00 00 09 00 00 00 E9 2F 5E F8 00 02 00 00 00 00 00 00 00 FA BF B5 DA 73 65 6E 64 63 6D 70 63 74 00 00 00 09 00 00 00 CC FE 10 4A 00 01 00 00 00 00 00 00 00","title":"sendcmpct"},{"location":"_private/bitcoin/raw-messages/#ping","text":"FA BF B5 DA 70 69 6E 67 00 00 00 00 00 00 00 00 08 00 00 00 39 AD 44 A3 0C 8E 5A C3 A0 0D F3 2F","title":"ping"},{"location":"_private/bitcoin/raw-messages/#getheaders","text":"FA BF B5 DA 67 65 74 68 65 61 64 65 72 73 00 00 E5 00 00 00 8A 94 35 BC 7F 11 01 00 06 2A 82 9C AD 81 6A 70 3D E3 5F 2B 18 9A 10 DA 4B 08 93 0A E9 6E ED C0 D7 32 12 8B 9A 91 C1 3B 51 8C 68 7D 8E D2 23 90 00 16 C6 70 50 AB 04 4A 6F 3A B0 4C 00 29 78 BF 5E 7B 7A A9 2D 56 4B 03 58 10 94 3F CC 3B C5 06 99 5A 7F 37 6B A1 6D 6C 80 CF 59 6B AC CC D9 09 34 11 F6 AE 44 D1 04 BF 42 97 FB CE AF 53 A8 3C FC 91 6A CD E8 11 6B C4 9E D3 62 AB A6 EC 34 C5 91 99 20 DC 43 06 E0 29 3B BA 09 3E E7 1E 02 18 A0 7C 4D 92 B0 47 29 0D FD 5B C0 80 89 76 58 E6 A8 89 90 1B 5A BD C3 F2 5B 06 22 6E 46 11 1A 0B 59 CA AF 12 60 43 EB 5B BF 28 C3 4F 3A 5E 33 2A 1F C7 B2 B7 3C F1 88 91 0F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 FA BF B5 DA 66 65 65 66 69 6C 74 65 72 00 00 00 08 00 00 00 E8 0F D1 9F E8 03 00 00 00 00 00 00","title":"getheaders"},{"location":"_private/bitcoin/specifications/","text":"Needs When we get headers from peers, in order to validate the chain we need to fetch blocks. We may face problems implementing a naive block downloader: If we download blocks everytime a new header is validated, we may waste resource validating blocks of forks that are far behind the tip. A bad peer could send us a long chain of technically valid headers but when we try later to validate its blocks, they could be invalid: this would cause the node to waste lot of resources to validate blocks that will turn out to be wrong. We must ask blocks only to peers that prove us they have such block (otherwise we may ban them while they are instead on a better chain and we'll sit on a fork) A way to achieve a fair block distribution is to ask blocks to peer that proved us to have required blocks and with a good score, in order to maximixe the throughput and the chance to succeed. The score system may take into consideration the ping time (obtained by ping messages) and can eventually track download speed of blocks to have a better understanding of the peer performance. Note that a sheer byte/sec indicator isn't enough because the problem may be our network, so the peer speeds must be compared between them in order to diminish the impact of the node connection. Possible implementation During header sync, peers check if they are in a position to ask for block downloads, judging by their position respect the node tip and their communicated best peer header. Following bitcoin core implementation logic, a peer may trigger a block download when: its best known header has more chainwork than our current chain tip","title":"Needs"},{"location":"_private/bitcoin/specifications/#needs","text":"When we get headers from peers, in order to validate the chain we need to fetch blocks. We may face problems implementing a naive block downloader: If we download blocks everytime a new header is validated, we may waste resource validating blocks of forks that are far behind the tip. A bad peer could send us a long chain of technically valid headers but when we try later to validate its blocks, they could be invalid: this would cause the node to waste lot of resources to validate blocks that will turn out to be wrong. We must ask blocks only to peers that prove us they have such block (otherwise we may ban them while they are instead on a better chain and we'll sit on a fork) A way to achieve a fair block distribution is to ask blocks to peer that proved us to have required blocks and with a good score, in order to maximixe the throughput and the chance to succeed. The score system may take into consideration the ping time (obtained by ping messages) and can eventually track download speed of blocks to have a better understanding of the peer performance. Note that a sheer byte/sec indicator isn't enough because the problem may be our network, so the peer speeds must be compared between them in order to diminish the impact of the node connection.","title":"Needs"},{"location":"_private/bitcoin/specifications/#possible-implementation","text":"During header sync, peers check if they are in a position to ask for block downloads, judging by their position respect the node tip and their communicated best peer header. Following bitcoin core implementation logic, a peer may trigger a block download when: its best known header has more chainwork than our current chain tip","title":"Possible implementation"},{"location":"_private/bitcoin/todo/","text":"Implement peer permissions. On Bitcoin core, peer permissions are a way to specify special permissions to peers that are whitelisted or whitebinded. Whitebind allows to define an endpoint to which peers that connects to inherit the permissions defined for that whitebind. [host]:port Whitelist allows to define specific permissions to peers connecting from specific IP address or CIDR notated network 1.2.3.4 1.2.3.0/24 Bitcoin core syntax for such configuration is 1 2 -whitelist=bloomfilter@127.0.0.1/32. -whitebind=bloomfilter,relay,noban@127.0.0.1:10020 I've already implemented a class BitcoinPeerPermissions but I've not yet decided how to allow to specify such permissions. Since my implementation is json friendly, I'd prefer to specify settings by config file in a more structured way (command line is still possible even if more awkward) Redesign classes to hold Chain state Current IChainState implementation (and the interface itself) is a result of many iteration starting from different point and converging into something I'm not happy with. These classes are very important so need a proper design and performance tuning. Some important aspects are: the memory footprint required to host the current chain representation in memory the lookup speed during IBD and during data fetch to serve other peers the tradeoff between in-memory stored data and data on disk that has to be fetched per request (consider a caching layer)","title":"Todo"},{"location":"_private/bitcoin/todo/#implement-peer-permissions","text":"On Bitcoin core, peer permissions are a way to specify special permissions to peers that are whitelisted or whitebinded. Whitebind allows to define an endpoint to which peers that connects to inherit the permissions defined for that whitebind. [host]:port Whitelist allows to define specific permissions to peers connecting from specific IP address or CIDR notated network 1.2.3.4 1.2.3.0/24 Bitcoin core syntax for such configuration is 1 2 -whitelist=bloomfilter@127.0.0.1/32. -whitebind=bloomfilter,relay,noban@127.0.0.1:10020 I've already implemented a class BitcoinPeerPermissions but I've not yet decided how to allow to specify such permissions. Since my implementation is json friendly, I'd prefer to specify settings by config file in a more structured way (command line is still possible even if more awkward)","title":"Implement peer permissions."},{"location":"_private/bitcoin/todo/#redesign-classes-to-hold-chain-state","text":"Current IChainState implementation (and the interface itself) is a result of many iteration starting from different point and converging into something I'm not happy with. These classes are very important so need a proper design and performance tuning. Some important aspects are: the memory footprint required to host the current chain representation in memory the lookup speed during IBD and during data fetch to serve other peers the tradeoff between in-memory stored data and data on disk that has to be fetched per request (consider a caching layer)","title":"Redesign classes to hold Chain state"},{"location":"bitcoin-shard/","text":"Premise This folder contains technical documentation that helps to understand the choices behind the implementation and design of current project. Personally I'm not a fan of bitcoin core code base: even if it improved since early days, it's confusing, it lacks of an homogeneous design and architecture and suffers from old bad choices and above all lacks of proper technical documentation, following the mantra \"source code is the documentation\". To be clear, I don't blame who contributes on bitcoin core, I'm just stating objective facts and I hope to fix some of these issues with my project but I don't pretend to have documentation always in sync with latest changes because it's a huge effort and I agree at some extents that source code is the final judge and I encourage you to dig into it if you want to go deeper in implementation details or verify that an information written here is correct and please, if you find any issue about documentation, feel free to open an issue and I'll be happy to fix it (even a PR with your corrections can be valuable!). To me a proper documentation doesn't have to explain the source code (source code should be as much readable as possible) but it should give insights about the process that leads toward specific implementations and have indications about good practice to work within the built library. Beside this premise, I'm writing this documentation as if I were the target, in order to have a maintainable and easy to follow repository and of course be able to give good understanding about how to extend this project further with custom features (shards) to people that may be interested. Nevertheless I would be happy to know that it could be useful to someone who may find it interesting and help in understanding why an approach has been chosen over another! Also if you have question or want to discuss about technical details, you can use the repository Discussion section . Project Overview Bitcoin Mithril Shard has been built on top of Mithril Shards framework. Mithril Shards goal is to be a framework and toolkit to build modular and distributed/P2P applications using .Net 5 stack, focusing both on good design, good practices and performance. Core functionalities can be glued togheter to compose the needed application, ranging from a P2P network layer, WEB Api layer, Diagnostic tools, cross platform UI based on blazor, distributed eventing using SignalR, MQ brokers like RabbitMq or any kind of other useful libraries. Thanks to its design, anyone can build it's own Shard to create other features that can be used by Mithril Shards community. More details about Mithril Shards can be found on the main documentation (TODO). Bitcoin shard is a very good example about how to build a fully functional full node for bitcoin, leveraging all the juicy features that Mithril Shards exposes. Network layer is implemented by leveraging Bedrock Framework for the TCP implementation using both Client and Server connections. Data is serialized thanks to an well defined set of interfaces and classes that allows to implement an easy to read and maintain code. Incoming messages are dispatched to \"Message Processors\" that allow to handle the application logic following a good practice of separation of concerns. Meaningful events are dispatched using a message bus implementation that can reach any component in any application layer. A WEB Api infrastructure allow to create WEB Api endpoint easily and each feature can have its set of API published on different document specifications. Swagger is used as a UI to expose these API documents and allows to execute these APIs straight from that interface. For development/debugging purpose, a Shard inject some useful endpoint to inspect internal details of the running application. Logging is done using structured logging, makes use of Serilog to persist them and a configuration example shows how to use Seq to have a very good UI to view logs, filter them, etc... Blazor is used to implement a cross platform UI as a companion for the full node.","title":"Overview"},{"location":"bitcoin-shard/#premise","text":"This folder contains technical documentation that helps to understand the choices behind the implementation and design of current project. Personally I'm not a fan of bitcoin core code base: even if it improved since early days, it's confusing, it lacks of an homogeneous design and architecture and suffers from old bad choices and above all lacks of proper technical documentation, following the mantra \"source code is the documentation\". To be clear, I don't blame who contributes on bitcoin core, I'm just stating objective facts and I hope to fix some of these issues with my project but I don't pretend to have documentation always in sync with latest changes because it's a huge effort and I agree at some extents that source code is the final judge and I encourage you to dig into it if you want to go deeper in implementation details or verify that an information written here is correct and please, if you find any issue about documentation, feel free to open an issue and I'll be happy to fix it (even a PR with your corrections can be valuable!). To me a proper documentation doesn't have to explain the source code (source code should be as much readable as possible) but it should give insights about the process that leads toward specific implementations and have indications about good practice to work within the built library. Beside this premise, I'm writing this documentation as if I were the target, in order to have a maintainable and easy to follow repository and of course be able to give good understanding about how to extend this project further with custom features (shards) to people that may be interested. Nevertheless I would be happy to know that it could be useful to someone who may find it interesting and help in understanding why an approach has been chosen over another! Also if you have question or want to discuss about technical details, you can use the repository Discussion section .","title":"Premise"},{"location":"bitcoin-shard/#project-overview","text":"Bitcoin Mithril Shard has been built on top of Mithril Shards framework. Mithril Shards goal is to be a framework and toolkit to build modular and distributed/P2P applications using .Net 5 stack, focusing both on good design, good practices and performance. Core functionalities can be glued togheter to compose the needed application, ranging from a P2P network layer, WEB Api layer, Diagnostic tools, cross platform UI based on blazor, distributed eventing using SignalR, MQ brokers like RabbitMq or any kind of other useful libraries. Thanks to its design, anyone can build it's own Shard to create other features that can be used by Mithril Shards community. More details about Mithril Shards can be found on the main documentation (TODO). Bitcoin shard is a very good example about how to build a fully functional full node for bitcoin, leveraging all the juicy features that Mithril Shards exposes. Network layer is implemented by leveraging Bedrock Framework for the TCP implementation using both Client and Server connections. Data is serialized thanks to an well defined set of interfaces and classes that allows to implement an easy to read and maintain code. Incoming messages are dispatched to \"Message Processors\" that allow to handle the application logic following a good practice of separation of concerns. Meaningful events are dispatched using a message bus implementation that can reach any component in any application layer. A WEB Api infrastructure allow to create WEB Api endpoint easily and each feature can have its set of API published on different document specifications. Swagger is used as a UI to expose these API documents and allows to execute these APIs straight from that interface. For development/debugging purpose, a Shard inject some useful endpoint to inspect internal details of the running application. Logging is done using structured logging, makes use of Serilog to persist them and a configuration example shows how to use Seq to have a very good UI to view logs, filter them, etc... Blazor is used to implement a cross platform UI as a companion for the full node.","title":"Project Overview"},{"location":"bitcoin-shard/network/","text":"Network Protocol The Bitcoin network protocol is a TCP protocol that serializes messages starting from a special 4 bytes constant data called Magic bytes , followed by 12 bytes representing the command name , 4 bytes representing the payload size and 4 bytes with the checksum of the payload. More specific information about bitcoin protocol can be found here. Mithril Shards implements a low level stack of interfaces and implementations that allow to focus on the application logic instead on low level details. A default implementation uses Bedrock Framework to leverage the low level communication between peers and this is what's used in the Bitcoin shard to provide P2P connectivity. A typical Bitcoin full node (henceforth called FN ) is able to connect to other nodes and accept incoming connections. Before two peers can exchange information, they have to perform an handshake to prove that they can understand each other (more details on the the bitcoin network protocol can be found on this bitcoin developer resource ). Before being able to handshake, whenever a connection has been established between two peers the FN stores some metadata about the remote peer. This data is stored into a class that implements IPeerContext interface and its implementation represents our next section. Peer Context Default Mithril Shards implementation uses PeerContext class to store, among other things, information like peer unique identification, direction (inbound/outbound) remote and local endpoints, user agent identification, negotiated protocol version and other attachable properties leveraging the .Net IFeatureCollection interface. Bitcoin needs some additional information and some of the properties that are ubiquitous needed among all optional Bitcoin features (shards) like wallet, APIs, indexer, etc... have been defined directly into BitcoinPeerContext that extends the default PeerContext . Some of the additional properties are Permissions (that may change the FN behavior based on its set) and TimeOffset, that's an important aspect for the consensus logic. Another important property exposed by peer context is the ConnectionCancellationTokenSource property, that's a CancellationTokenSource that can be used to trigger the disconnection from a peer. It's internally used to know when the connection has been closed, to stop the execution of async methods that rely on an active connection to a remote peer. As per IPeerContext interface, ConnectionCancellationTokenSource can only be read so it's important that custom implementation of IPeerContext don't change it's value out of constructor. This property is actively used within message processors (more about it in a later section). The cancellation of ConnectionCancellationTokenSource shouldn't be canceled directly, to force a peer disconnection an event of type PeerDisconnectionRequired has to be published on the event bus, but for simplicity BitcoinPeerContext implements a Disconnect method that does that. So anytime you have a need to disconnect a peer, just call thePeerContext.Disconnect(\"My Disconnection reason!\") . You can find already usage of it in message processor classes. The peer context creation is handled by the core Mithril Shard network implementation and since it can't know about the BitcoinPeerContext properties, it relies on a peer context factory, in this case we are talking about BitcoinPeerContextFactory class. It leverages the generic class PeerContextFactory<> and its implementation is bare bone, no need to override anything. 1 public class PeerContextFactory < TPeerContext > : IPeerContextFactory where TPeerContext : IPeerContext Accepting a connection Once the peer context has been created, a sanity check is performed to see if the two peers can connect to each other before trying to handshake and the behavior is very similar to both inbound and outbound connections. The only difference is that actually for outgoing connection the check is done before trying to connect but very likely it would be done as per incoming connection soon. What happens when an incoming connection has been accepted is that the connection has to pass all registered (in the DI containers) implementations of IServerPeerConnectionGuard interface. ServerPeerConnectionGuardBase In Bitcoin shard all guard rules are extending ServerPeerConnectionGuardBase implementation that's a simple class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public abstract class ServerPeerConnectionGuardBase : IServerPeerConnectionGuard { protected readonly ILogger logger ; protected readonly ForgeConnectivitySettings settings ; public ServerPeerConnectionGuardBase ( ILogger logger , IOptions < ForgeConnectivitySettings > options ) { this . logger = logger ; settings = options . Value ; } public ServerPeerConnectionGuardResult Check ( IPeerContext peerContext ) { string? denyReason = TryGetDenyReason ( peerContext ); if (! string . IsNullOrEmpty ( denyReason )) { logger . LogDebug ( \"Peer connection guard not passed: {denyReason}\" , denyReason ); return ServerPeerConnectionGuardResult . Deny ( denyReason ); } return ServerPeerConnectionGuardResult . Allow (); } internal abstract string? TryGetDenyReason ( IPeerContext peerContext ); } This class implements the plumbing code required to run (and log in case of rule check not passed) the guard rule, so a guard rule implementation has just to focus on its guarding logic. A simple example is the MaxConnectionThresholdGuard rule that ensure that an incoming transaction doesn't exceed the maximum allowed number of inbound connections: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MaxConnectionThresholdGuard : ServerPeerConnectionGuardBase { readonly IConnectivityPeerStats _peerStats ; public MaxConnectionThresholdGuard ( ILogger < MaxConnectionThresholdGuard > logger , IOptions < ForgeConnectivitySettings > settings , IConnectivityPeerStats serverPeerStats ) : base ( logger , settings ) { _peerStats = serverPeerStats ; } internal override string? TryGetDenyReason ( IPeerContext peerContext ) { if ( _peerStats . ConnectedInboundPeersCount >= settings . MaxInboundConnections ) { return \"Inbound connection refused: max connection threshold reached.\" ; } return null ; } } In order to be used during connection check, these guard classes have to be registered in the DI container. MaxConnectionThresholdGuard for example is registered into the extension that register the bitcoin shard by using 1 services.AddSingleton<IServerPeerConnectionGuard, InitialBlockDownloadStateGuard>() This allow the flexibility of having custom guard rule simply by implementing a rule and register in the DI container, any required service will be injected automatically; of course if it relies on a custom service not already available in my implementation, that service has to be registered too. Info These classes have to be registered as singleton and therefor must be stateless Network protocol is implemented through the serialization of classes which implement INetworkMessage interface and are decorated with NetworkMessageAttribute that works in synergy with an implementation of INetworkMessageSerializer to implement network serialization. Handshake Once a connection has been accepted between two nodes, they start exchanging messages in order to handshake and prove each other they are two compatible nodes that can exchange informations. Info Bitcoin protocol doesn't punish nodes that send unknown messages. I think however that a node has to monitor its connected peer activities and punish them if they send too many unknown messages causing our node to waste resources. Without going too deeper into bitcoin handshake process, the exchanges messages are summarized by this sequence diagram: sequenceDiagram participant L as Local participant R as Remote L-->>+R:Connects to L->>+R:Version R->>L:Version R->>L:Verack L->>R:Verack Info Bitcoin protocol doesn't define a specific order for the Remote node to send its Verack and Version message so Local node has to account that and accept these messages in any order.","title":"Network implementation"},{"location":"bitcoin-shard/network/#network-protocol","text":"The Bitcoin network protocol is a TCP protocol that serializes messages starting from a special 4 bytes constant data called Magic bytes , followed by 12 bytes representing the command name , 4 bytes representing the payload size and 4 bytes with the checksum of the payload. More specific information about bitcoin protocol can be found here. Mithril Shards implements a low level stack of interfaces and implementations that allow to focus on the application logic instead on low level details. A default implementation uses Bedrock Framework to leverage the low level communication between peers and this is what's used in the Bitcoin shard to provide P2P connectivity. A typical Bitcoin full node (henceforth called FN ) is able to connect to other nodes and accept incoming connections. Before two peers can exchange information, they have to perform an handshake to prove that they can understand each other (more details on the the bitcoin network protocol can be found on this bitcoin developer resource ). Before being able to handshake, whenever a connection has been established between two peers the FN stores some metadata about the remote peer. This data is stored into a class that implements IPeerContext interface and its implementation represents our next section.","title":"Network Protocol"},{"location":"bitcoin-shard/network/#peer-context","text":"Default Mithril Shards implementation uses PeerContext class to store, among other things, information like peer unique identification, direction (inbound/outbound) remote and local endpoints, user agent identification, negotiated protocol version and other attachable properties leveraging the .Net IFeatureCollection interface. Bitcoin needs some additional information and some of the properties that are ubiquitous needed among all optional Bitcoin features (shards) like wallet, APIs, indexer, etc... have been defined directly into BitcoinPeerContext that extends the default PeerContext . Some of the additional properties are Permissions (that may change the FN behavior based on its set) and TimeOffset, that's an important aspect for the consensus logic. Another important property exposed by peer context is the ConnectionCancellationTokenSource property, that's a CancellationTokenSource that can be used to trigger the disconnection from a peer. It's internally used to know when the connection has been closed, to stop the execution of async methods that rely on an active connection to a remote peer. As per IPeerContext interface, ConnectionCancellationTokenSource can only be read so it's important that custom implementation of IPeerContext don't change it's value out of constructor. This property is actively used within message processors (more about it in a later section). The cancellation of ConnectionCancellationTokenSource shouldn't be canceled directly, to force a peer disconnection an event of type PeerDisconnectionRequired has to be published on the event bus, but for simplicity BitcoinPeerContext implements a Disconnect method that does that. So anytime you have a need to disconnect a peer, just call thePeerContext.Disconnect(\"My Disconnection reason!\") . You can find already usage of it in message processor classes. The peer context creation is handled by the core Mithril Shard network implementation and since it can't know about the BitcoinPeerContext properties, it relies on a peer context factory, in this case we are talking about BitcoinPeerContextFactory class. It leverages the generic class PeerContextFactory<> and its implementation is bare bone, no need to override anything. 1 public class PeerContextFactory < TPeerContext > : IPeerContextFactory where TPeerContext : IPeerContext","title":"Peer Context"},{"location":"bitcoin-shard/network/#accepting-a-connection","text":"Once the peer context has been created, a sanity check is performed to see if the two peers can connect to each other before trying to handshake and the behavior is very similar to both inbound and outbound connections. The only difference is that actually for outgoing connection the check is done before trying to connect but very likely it would be done as per incoming connection soon. What happens when an incoming connection has been accepted is that the connection has to pass all registered (in the DI containers) implementations of IServerPeerConnectionGuard interface.","title":"Accepting a connection"},{"location":"bitcoin-shard/network/#serverpeerconnectionguardbase","text":"In Bitcoin shard all guard rules are extending ServerPeerConnectionGuardBase implementation that's a simple class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public abstract class ServerPeerConnectionGuardBase : IServerPeerConnectionGuard { protected readonly ILogger logger ; protected readonly ForgeConnectivitySettings settings ; public ServerPeerConnectionGuardBase ( ILogger logger , IOptions < ForgeConnectivitySettings > options ) { this . logger = logger ; settings = options . Value ; } public ServerPeerConnectionGuardResult Check ( IPeerContext peerContext ) { string? denyReason = TryGetDenyReason ( peerContext ); if (! string . IsNullOrEmpty ( denyReason )) { logger . LogDebug ( \"Peer connection guard not passed: {denyReason}\" , denyReason ); return ServerPeerConnectionGuardResult . Deny ( denyReason ); } return ServerPeerConnectionGuardResult . Allow (); } internal abstract string? TryGetDenyReason ( IPeerContext peerContext ); } This class implements the plumbing code required to run (and log in case of rule check not passed) the guard rule, so a guard rule implementation has just to focus on its guarding logic. A simple example is the MaxConnectionThresholdGuard rule that ensure that an incoming transaction doesn't exceed the maximum allowed number of inbound connections: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MaxConnectionThresholdGuard : ServerPeerConnectionGuardBase { readonly IConnectivityPeerStats _peerStats ; public MaxConnectionThresholdGuard ( ILogger < MaxConnectionThresholdGuard > logger , IOptions < ForgeConnectivitySettings > settings , IConnectivityPeerStats serverPeerStats ) : base ( logger , settings ) { _peerStats = serverPeerStats ; } internal override string? TryGetDenyReason ( IPeerContext peerContext ) { if ( _peerStats . ConnectedInboundPeersCount >= settings . MaxInboundConnections ) { return \"Inbound connection refused: max connection threshold reached.\" ; } return null ; } } In order to be used during connection check, these guard classes have to be registered in the DI container. MaxConnectionThresholdGuard for example is registered into the extension that register the bitcoin shard by using 1 services.AddSingleton<IServerPeerConnectionGuard, InitialBlockDownloadStateGuard>() This allow the flexibility of having custom guard rule simply by implementing a rule and register in the DI container, any required service will be injected automatically; of course if it relies on a custom service not already available in my implementation, that service has to be registered too. Info These classes have to be registered as singleton and therefor must be stateless Network protocol is implemented through the serialization of classes which implement INetworkMessage interface and are decorated with NetworkMessageAttribute that works in synergy with an implementation of INetworkMessageSerializer to implement network serialization.","title":"ServerPeerConnectionGuardBase"},{"location":"bitcoin-shard/network/#handshake","text":"Once a connection has been accepted between two nodes, they start exchanging messages in order to handshake and prove each other they are two compatible nodes that can exchange informations. Info Bitcoin protocol doesn't punish nodes that send unknown messages. I think however that a node has to monitor its connected peer activities and punish them if they send too many unknown messages causing our node to waste resources. Without going too deeper into bitcoin handshake process, the exchanges messages are summarized by this sequence diagram: sequenceDiagram participant L as Local participant R as Remote L-->>+R:Connects to L->>+R:Version R->>L:Version R->>L:Verack L->>R:Verack Info Bitcoin protocol doesn't define a specific order for the Remote node to send its Verack and Version message so Local node has to account that and accept these messages in any order.","title":"Handshake"},{"location":"bitcoin-shard/testing_node_communication/","text":"Testing node communication In order to test the Forge implementation, I used the handy bitcoin testnet in a box I used the docker implementation: docker pull freewil/bitcoin-testnet-box then I modified the suggested docker run arguments, in order to open the node port, this way, to run the image with an reachable testnet node, run the image as docker run -t -i -p 19000:19000 -p 19001:19001 -p 19011:19011 freewil/bitcoin-testnet-box after that, in the tty console, write make start to start the node and this way you can connect to the testnet box using the endpoint 127.0.0.1:19000 If everything is going as expected and you ran the Forge within bitcoin-testnet network, you should see something similar to this At the time of the screenshot (2nd of January 2020) only the handshake implementation was ready, this is why of warnings following the successful handshake. Troubleshooting System.Net.Sockets.SocketException (10013) In case you receive this error while trying to open some port for listening, the reason may be your OS is excluding some port ranges for some reason. To check if the port is reserved, you can use the command netsh interface ipv4 show excludedportrange tcp you'll see a list of port ranges that may include the port you are trying to open. To fix that your best bet is to just change the port you want to use in your configuration file, otherwise you need to understand why a specific port range is being reserved and eventually change it. You can delete the excludedportrange if you want and you know what you are doing, using commands like netsh int ipv4 delete excludedportrange protocol=tcp startport=45000 numberofports=100 and add new ones with netsh int ipv4 add excludedportrange protocol=tcp startport=45000 numberofports=100","title":"Testing node communication"},{"location":"bitcoin-shard/testing_node_communication/#testing-node-communication","text":"In order to test the Forge implementation, I used the handy bitcoin testnet in a box I used the docker implementation: docker pull freewil/bitcoin-testnet-box then I modified the suggested docker run arguments, in order to open the node port, this way, to run the image with an reachable testnet node, run the image as docker run -t -i -p 19000:19000 -p 19001:19001 -p 19011:19011 freewil/bitcoin-testnet-box after that, in the tty console, write make start to start the node and this way you can connect to the testnet box using the endpoint 127.0.0.1:19000 If everything is going as expected and you ran the Forge within bitcoin-testnet network, you should see something similar to this At the time of the screenshot (2nd of January 2020) only the handshake implementation was ready, this is why of warnings following the successful handshake.","title":"Testing node communication"},{"location":"bitcoin-shard/testing_node_communication/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"bitcoin-shard/testing_node_communication/#systemnetsocketssocketexception-10013","text":"In case you receive this error while trying to open some port for listening, the reason may be your OS is excluding some port ranges for some reason. To check if the port is reserved, you can use the command netsh interface ipv4 show excludedportrange tcp you'll see a list of port ranges that may include the port you are trying to open. To fix that your best bet is to just change the port you want to use in your configuration file, otherwise you need to understand why a specific port range is being reserved and eventually change it. You can delete the excludedportrange if you want and you know what you are doing, using commands like netsh int ipv4 delete excludedportrange protocol=tcp startport=45000 numberofports=100 and add new ones with netsh int ipv4 add excludedportrange protocol=tcp startport=45000 numberofports=100","title":"System.Net.Sockets.SocketException (10013)"},{"location":"mithril-shards/dev-controller/","text":"MithrilShards.Dev.Controller This shard allows to have control over the forge, to perform some operation needed during development. It's not meant to be used in production but just as an helper to inject custom hooks into the Forge, for development and debug purpose.","title":"Network implementation"},{"location":"mithril-shards/dev-controller/#mithrilshardsdevcontroller","text":"This shard allows to have control over the forge, to perform some operation needed during development. It's not meant to be used in production but just as an helper to inject custom hooks into the Forge, for development and debug purpose.","title":"MithrilShards.Dev.Controller"}]}