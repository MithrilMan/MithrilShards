{"config": {"lang": ["en"], "min_search_length": 3, "prebuild_index": false, "separator": "[\\s\\-]+"}, "docs": [{"location": "", "text": "Goal Mithril Shards goal is to implement a .NET 5 extensible P2P network & distributed services library from scratch with focus on architecture and performance. Allows you to define custom network serialization protocol, easily handle payload messages and interact with the software leveraging any available features (named Shards) like Web API endpoints, cross platform Blazor UI , and a lot of other exciting stuffs that community can implement and release to the public too! The project is very ambitious and it's currently developed just by me as a pet project but a huge effort has gone into already and some part of this unique code base has been already reused in other blockchain technologies to improve their performance. Current Tech A random list of available tech used within Mithril Shards. .Net 5 - ... for everything. Bedrock Framework - TCP/IP default connectivity implementation. Swashbuckle - to handle Web API in a configurable, multi-area environment and have a playground to test APIs with swagger. Serilog - default logging implementation. BenchmarkDotNet - a benchmark framework, very handy to benchmark different approach during implementation phases. How things started I have DLT experience in the past years and one of my previous experience has been working for a blockchain tech firm that had a FN implementation in C#. I really love C# and .Net core has improved a lot performance too. Working on their codebase I saw lot of things that could have been improved, both in design and in performance. Their implementation started as a kind of 1-1 porting of bitcoin core source with all the cons that it brings. So I thought about diving into this titanic effort of creating a full node in C# starting from scratch, mainly to go as deeper as possible into technical details, trying to focus both on a proper architecture design and performance improvements. One of the first thing I implemented was of course the basic handshake process between two nodes and to achieve that, I started by following bitcoin core source because unluckily that's the only part that contains kind of specifications: it's hard to find a detailed updated technical documentations, even this protocol documentation page contains wrong information, even if it's still useful. I started using .Net TCP classes, using an internal state machine to handle peer connection statuses, then I found Bedrock Framework , that allowed me to abstract better my code and rely on it for the low level connection stuff (at the time of writing this documentation, that library is still in alpha and my concern about that project activity has been appeased ). As soon as I started defining properly my design, I found it interesting to abstract most of the stuff into an agnostic library that would allows me to create a P2P application in a modular way and attach additional features when needed, and this is how Mithril Shards started. Since then I added more and more stuff, both for generic Mithril Shards project and for specific Bitcoin needs. The multi project Example Shard showcases how you can create a custom P2P software leveraging networking, custom messages, Web API endpoints Diagnostic tools, everything with a proper logging system. Why the Mithril Shards name? Well... let's bullet some facts I like fantasy a lot, J.R.R. Tolkien of course has been one of my reads and mithril is a fictional metal in his universe. The main properties of mithri are: being very strong, light and in its pure form very malleable to work with. I'm a developer that like to curate its software to be extensible and solid. My github handle is MithrilMan, guess what? Now take these information, mix them up, and you'll see that to I aim to have a robust, fast and flexible project! So this explain mithril, while about Shards , is because I see this project as a mix of shards that can be assembled together to give you a precious artifact! In fact you shouldn't be surprised that the root class is called Forge... who says we can't have a bit of fun while designing a software? Call to Action! Join to give feedback, ask for features, support, etc... Discord server: https://discord.gg/T9kyKz4bAu CI Current status", "title": "Welcome!"}, {"location": "#goal", "text": "Mithril Shards goal is to implement a .NET 5 extensible P2P network & distributed services library from scratch with focus on architecture and performance. Allows you to define custom network serialization protocol, easily handle payload messages and interact with the software leveraging any available features (named Shards) like Web API endpoints, cross platform Blazor UI , and a lot of other exciting stuffs that community can implement and release to the public too! The project is very ambitious and it's currently developed just by me as a pet project but a huge effort has gone into already and some part of this unique code base has been already reused in other blockchain technologies to improve their performance.", "title": "Goal"}, {"location": "#current-tech", "text": "A random list of available tech used within Mithril Shards. .Net 5 - ... for everything. Bedrock Framework - TCP/IP default connectivity implementation. Swashbuckle - to handle Web API in a configurable, multi-area environment and have a playground to test APIs with swagger. Serilog - default logging implementation. BenchmarkDotNet - a benchmark framework, very handy to benchmark different approach during implementation phases.", "title": "Current Tech"}, {"location": "#how-things-started", "text": "I have DLT experience in the past years and one of my previous experience has been working for a blockchain tech firm that had a FN implementation in C#. I really love C# and .Net core has improved a lot performance too. Working on their codebase I saw lot of things that could have been improved, both in design and in performance. Their implementation started as a kind of 1-1 porting of bitcoin core source with all the cons that it brings. So I thought about diving into this titanic effort of creating a full node in C# starting from scratch, mainly to go as deeper as possible into technical details, trying to focus both on a proper architecture design and performance improvements. One of the first thing I implemented was of course the basic handshake process between two nodes and to achieve that, I started by following bitcoin core source because unluckily that's the only part that contains kind of specifications: it's hard to find a detailed updated technical documentations, even this protocol documentation page contains wrong information, even if it's still useful. I started using .Net TCP classes, using an internal state machine to handle peer connection statuses, then I found Bedrock Framework , that allowed me to abstract better my code and rely on it for the low level connection stuff (at the time of writing this documentation, that library is still in alpha and my concern about that project activity has been appeased ). As soon as I started defining properly my design, I found it interesting to abstract most of the stuff into an agnostic library that would allows me to create a P2P application in a modular way and attach additional features when needed, and this is how Mithril Shards started. Since then I added more and more stuff, both for generic Mithril Shards project and for specific Bitcoin needs. The multi project Example Shard showcases how you can create a custom P2P software leveraging networking, custom messages, Web API endpoints Diagnostic tools, everything with a proper logging system.", "title": "How things started"}, {"location": "#why-the-mithril-shards-name", "text": "Well... let's bullet some facts I like fantasy a lot, J.R.R. Tolkien of course has been one of my reads and mithril is a fictional metal in his universe. The main properties of mithri are: being very strong, light and in its pure form very malleable to work with. I'm a developer that like to curate its software to be extensible and solid. My github handle is MithrilMan, guess what? Now take these information, mix them up, and you'll see that to I aim to have a robust, fast and flexible project! So this explain mithril, while about Shards , is because I see this project as a mix of shards that can be assembled together to give you a precious artifact! In fact you shouldn't be surprised that the root class is called Forge... who says we can't have a bit of fun while designing a software?", "title": "Why the Mithril Shards name?"}, {"location": "#call-to-action", "text": "Join to give feedback, ask for features, support, etc... Discord server: https://discord.gg/T9kyKz4bAu", "title": "Call to Action!"}, {"location": "#ci", "text": "Current status", "title": "CI"}, {"location": "example-projects/", "text": "The best way to see it in action is by inspecting the Example projects I've created. It's a multi-project example where each project plays its role into the modular application architecture. Its goal is to show how to make use of Mithril Shards to implement a P2P application that implements a custom Web API controller, a custom network implementation and its own protocol with custom messages and serializators. It reuses some other standard shards like : BedrockNetworkShard [StatisticCollectorShard] SerilogShard WebApiShard DevControllerShard What it does is quite simple: You can run two instance of this project to connect to each other and every 10 seconds a ping message will be sent to the other peer, with a random quote message. The quote message is randomly picked by the QuoteService and quotes can be manipulated by using the ExampleController exposed by the Web API . All the code is well commented so you shouldn't have problem understanding it, in any case the Discussions on my repository is open for you. Example Projects The example is composed by several projects, each one with their own scope, to mimic a (simple) typical modular application: MithrilShards.Example MithrilShards.Example.Network.Bedrock MithrilShards.Example.Dev MithrilShards.Example.Node MithrilShards.Example It contains the core classes and services needed to run the example application. Here we can find: network classes like a custom IPeerContext implementation and its factory class some custom IServerPeerConnectionGuard implementation to filter incoming connections and a custom ConnectorBase implementation that contains the logic to connect to other peers protocol classes like INetworkMessage implementations of custom messages (payloads) and complex types used within their implementation. INetworkMessage and type serializators that serialize classes into a byte representation that can be sent through the network. INetworkMessage processors that contain the logic to parse incoming messages and send messages to other peers plumbing classes like shard setting class and services used by processors or other internal components. MithrilShards.Example.Network.Bedrock Contains few classes that are implementing the INetworkProtocolMessageSerializer interface needed by the BedrockNetworkShard shard to perform message serialization. In this example we are mimicking bitcoin protocol that uses a magic word (4 bytes) that mark the start of a new message and it's message layout to define the rule to decode and encode messages over the network (see ProtocolDefinition.cs file). Note how the code is really small and how it's easy to define custom network serialization of messages. Current implementation relies on Bedrock framework shard, but if you want to create another lol level network implementation you are free to do so, you don't have to change anything else except this project to make use of your new low level network protocol, everything is abstracted out in the Mithril Shards Core project!! MithrilShards.Example.Dev Contains just a Controller that expose a couple of Web API actions to manipulate the QuoteService and list, add and remove quotes. In order to show an alternative way to register controllers, this project doesn't implement a shard and doesn't have any Add* / Use* extension method to add its share, instead its controller is discovered using the ControllersSeeker property of WebApiShard in its UseApi extension method.. MithrilShards.Example.Node It makes use of System.CommandLine to have implement the application as a CLI . While all other projects were C# Class Library projects, this one produces an executable that's the actual, assembled application. It contains the Program.cs file that melt the shards into the forge and run it, plus a couple of configuration files that you can inspect to see different configuration combinations. Program.cs file is quote short and easy to read: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 using System.CommandLine ; using System.CommandLine.Invocation ; using System.Threading.Tasks ; using MithrilShards.Core.Forge ; using MithrilShards.Dev.Controller ; using MithrilShards.Diagnostic.StatisticsCollector ; using MithrilShards.Example.Dev ; using MithrilShards.Example.Network.Bedrock ; using MithrilShards.Example.Protocol ; using MithrilShards.Logging.Serilog ; using MithrilShards.Network.Bedrock ; using Serilog ; namespace MithrilShards.Example.Node { static class Program { static async Task Main ( string [] args ) { // Create a root command with some options var rootCommand = new RootCommand { new Option < string >( \"--settings\" , getDefaultValue : () => \"forge-settings.json\" , description : \"Specify the path to the forge settings file.\" ), new Option < string? >( \"--log-settings\" , getDefaultValue : () => null , description : \"Specify the path to the forge log settings file. If not specified, try to get logging information from the main forge settings file.\" ), new Option < int >( \"--protocol-version\" , getDefaultValue : () => KnownVersion . CurrentVersion , description : \"Specify the path to the forge settings file.\" ) }; rootCommand . Description = \"Example App\" ; rootCommand . TreatUnmatchedTokensAsErrors = false ; // Note that the parameters of the handler method are matched according to the names of the options rootCommand . Handler = CommandHandler . Create < string , string , int >( async ( settings , logSettings , protocolVersion ) => { await new ForgeBuilder () . UseForge < DefaultForge >( args , settings ) . UseSerilog ( logSettings ) . UseBedrockNetwork < ExampleNetworkProtocolMessageSerializer >() . UseStatisticsCollector ( options => options . DumpOnConsoleOnKeyPress = true ) /// we are injecting ExampleDev type to allow <see cref=\"MithrilShards.WebApi.WebApiShard\"/> to find all the controllers /// defined there because only controllers defined in an included shard assemblies are discovered automatically. /// Passing ExampleDev will cause dotnet runtime to load the assembly where ExampleDev Type is defined and every /// controllers defined there will be found later during <see cref=\"MithrilShards.WebApi.WebApiShard\"/> initialization. . UseApi ( options => options . ControllersSeeker = ( seeker ) => seeker . LoadAssemblyFromType < ExampleDev >()) . UseDevController () . UseExample ( KnownVersion . V1 , protocolVersion ) . RunConsoleAsync () . ConfigureAwait ( false ); }); await rootCommand . InvokeAsync ( args ). ConfigureAwait ( false ); } } } Running the example Running just an instance doesn't fully show you how the program behave, it needs at least 2 peers to connect to each other, that's why there are already multiple configuration files configured differently to let you connect two instances together. You can run one instance by setting MithrilShards.Example.Node as the startup project and run the launchSettings profile \"node1\" . Then open a shell at the MithrilShards.Example.Node project path and run the command below 1 dotnet run --no-build --settings forge-settings2.json This would cause you to have a debuggable instance running with the configuration defined in forge-settings.json file and another run running on the forge-settings2.json configuration. Alternatively you can run both instances, without a debugger (but you can attach later the process to Visual Studio) by running on two different shells: 1 2 dotnet run --no-build --settings forge-settings.json dotnet run --no-build --settings forge-settings2.json The program running forge-settings.json contains the most verbose log level and you'll have the best experience if you install (or use a docker image) of Seq configured on the port specified in your configuration file (e.g. localhost:5341). See SerilogShard for more details. Here an example of the configuration file (forge-settings.json) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 { \"ForgeConnectivity\" : { \"ForceShutdownAfter\" : 300 , \"MaxInboundConnections\" : 25 , \"AllowLoopbackConnection\" : false , \"Listeners\" : [ { \"IsWhitelistingEndpoint\" : true , \"Endpoint\" : \"0.0.0.0:45051\" }, { \"IsWhitelistingEndpoint\" : true , \"Endpoint\" : \"127.0.0.1:45052\" , \"PublicEndpoint\" : \"98.0.0.1:45011\" } ] }, \"Example\" : { \"MaxTimeAdjustment\" : 4200 , \"Connections\" : [ { \"Endpoint\" : \"127.0.0.1:45061\" , \"AdditionalInformation\" : \"I'm cool!\" } ] }, \"StatisticsCollector\" : { \"ContinuousConsoleDisplay\" : false , \"ContinuousConsoleDisplayRate\" : 5 }, \"DevController\" : { \"Enabled\" : true }, \"WebApi\" : { \"EndPoint\" : \"127.0.0.1:45020\" , \"Enabled\" : true , \"Https\" : false }, \"Serilog\" : { \"Using\" : [ \"Serilog.Sinks.Console\" , \"Serilog.Sinks.Seq\" ], \"Enrich\" : [ \"FromLogContext\" , \"WithMachineName\" , \"WithThreadId\" ], \"WriteTo\" : [ { \"Name\" : \"Console\" , \"Args\" : { \"IncludeScopes\" : true , \"theme\" : \"Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console\" } }, { \"Name\" : \"Seq\" , \"Args\" : { \"serverUrl\" : \"http://localhost:5341\" } } ], \"MinimumLevel\" : { \"Default\" : \"Debug\" , \"Override\" : { \"Bedrock.Framework\" : \"Warning\" , \"Microsoft\" : \"Warning\" , \"System\" : \"Warning\" } } } } Some Screenshots Here a screenshot that shows the content of the shell when running the node with settings = forge-settings.json You can access the Swagger UI by opening the address https://127.0.0.1:45020/docs/index.html Here you can manipulate quotes using the Web API , or even manually attempt to connect to other peers using PeerManagement Connect action in the DEV area. If you installed Seq, you can access the logs in a better way like shown here:", "title": "Example Projects"}, {"location": "example-projects/#example-projects", "text": "The example is composed by several projects, each one with their own scope, to mimic a (simple) typical modular application: MithrilShards.Example MithrilShards.Example.Network.Bedrock MithrilShards.Example.Dev MithrilShards.Example.Node", "title": "Example Projects"}, {"location": "example-projects/#mithrilshardsexample", "text": "It contains the core classes and services needed to run the example application. Here we can find: network classes like a custom IPeerContext implementation and its factory class some custom IServerPeerConnectionGuard implementation to filter incoming connections and a custom ConnectorBase implementation that contains the logic to connect to other peers protocol classes like INetworkMessage implementations of custom messages (payloads) and complex types used within their implementation. INetworkMessage and type serializators that serialize classes into a byte representation that can be sent through the network. INetworkMessage processors that contain the logic to parse incoming messages and send messages to other peers plumbing classes like shard setting class and services used by processors or other internal components.", "title": "MithrilShards.Example"}, {"location": "example-projects/#mithrilshardsexamplenetworkbedrock", "text": "Contains few classes that are implementing the INetworkProtocolMessageSerializer interface needed by the BedrockNetworkShard shard to perform message serialization. In this example we are mimicking bitcoin protocol that uses a magic word (4 bytes) that mark the start of a new message and it's message layout to define the rule to decode and encode messages over the network (see ProtocolDefinition.cs file). Note how the code is really small and how it's easy to define custom network serialization of messages. Current implementation relies on Bedrock framework shard, but if you want to create another lol level network implementation you are free to do so, you don't have to change anything else except this project to make use of your new low level network protocol, everything is abstracted out in the Mithril Shards Core project!!", "title": "MithrilShards.Example.Network.Bedrock"}, {"location": "example-projects/#mithrilshardsexampledev", "text": "Contains just a Controller that expose a couple of Web API actions to manipulate the QuoteService and list, add and remove quotes. In order to show an alternative way to register controllers, this project doesn't implement a shard and doesn't have any Add* / Use* extension method to add its share, instead its controller is discovered using the ControllersSeeker property of WebApiShard in its UseApi extension method..", "title": "MithrilShards.Example.Dev"}, {"location": "example-projects/#mithrilshardsexamplenode", "text": "It makes use of System.CommandLine to have implement the application as a CLI . While all other projects were C# Class Library projects, this one produces an executable that's the actual, assembled application. It contains the Program.cs file that melt the shards into the forge and run it, plus a couple of configuration files that you can inspect to see different configuration combinations. Program.cs file is quote short and easy to read: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 using System.CommandLine ; using System.CommandLine.Invocation ; using System.Threading.Tasks ; using MithrilShards.Core.Forge ; using MithrilShards.Dev.Controller ; using MithrilShards.Diagnostic.StatisticsCollector ; using MithrilShards.Example.Dev ; using MithrilShards.Example.Network.Bedrock ; using MithrilShards.Example.Protocol ; using MithrilShards.Logging.Serilog ; using MithrilShards.Network.Bedrock ; using Serilog ; namespace MithrilShards.Example.Node { static class Program { static async Task Main ( string [] args ) { // Create a root command with some options var rootCommand = new RootCommand { new Option < string >( \"--settings\" , getDefaultValue : () => \"forge-settings.json\" , description : \"Specify the path to the forge settings file.\" ), new Option < string? >( \"--log-settings\" , getDefaultValue : () => null , description : \"Specify the path to the forge log settings file. If not specified, try to get logging information from the main forge settings file.\" ), new Option < int >( \"--protocol-version\" , getDefaultValue : () => KnownVersion . CurrentVersion , description : \"Specify the path to the forge settings file.\" ) }; rootCommand . Description = \"Example App\" ; rootCommand . TreatUnmatchedTokensAsErrors = false ; // Note that the parameters of the handler method are matched according to the names of the options rootCommand . Handler = CommandHandler . Create < string , string , int >( async ( settings , logSettings , protocolVersion ) => { await new ForgeBuilder () . UseForge < DefaultForge >( args , settings ) . UseSerilog ( logSettings ) . UseBedrockNetwork < ExampleNetworkProtocolMessageSerializer >() . UseStatisticsCollector ( options => options . DumpOnConsoleOnKeyPress = true ) /// we are injecting ExampleDev type to allow <see cref=\"MithrilShards.WebApi.WebApiShard\"/> to find all the controllers /// defined there because only controllers defined in an included shard assemblies are discovered automatically. /// Passing ExampleDev will cause dotnet runtime to load the assembly where ExampleDev Type is defined and every /// controllers defined there will be found later during <see cref=\"MithrilShards.WebApi.WebApiShard\"/> initialization. . UseApi ( options => options . ControllersSeeker = ( seeker ) => seeker . LoadAssemblyFromType < ExampleDev >()) . UseDevController () . UseExample ( KnownVersion . V1 , protocolVersion ) . RunConsoleAsync () . ConfigureAwait ( false ); }); await rootCommand . InvokeAsync ( args ). ConfigureAwait ( false ); } } }", "title": "MithrilShards.Example.Node"}, {"location": "example-projects/#running-the-example", "text": "Running just an instance doesn't fully show you how the program behave, it needs at least 2 peers to connect to each other, that's why there are already multiple configuration files configured differently to let you connect two instances together. You can run one instance by setting MithrilShards.Example.Node as the startup project and run the launchSettings profile \"node1\" . Then open a shell at the MithrilShards.Example.Node project path and run the command below 1 dotnet run --no-build --settings forge-settings2.json This would cause you to have a debuggable instance running with the configuration defined in forge-settings.json file and another run running on the forge-settings2.json configuration. Alternatively you can run both instances, without a debugger (but you can attach later the process to Visual Studio) by running on two different shells: 1 2 dotnet run --no-build --settings forge-settings.json dotnet run --no-build --settings forge-settings2.json The program running forge-settings.json contains the most verbose log level and you'll have the best experience if you install (or use a docker image) of Seq configured on the port specified in your configuration file (e.g. localhost:5341). See SerilogShard for more details. Here an example of the configuration file (forge-settings.json) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 { \"ForgeConnectivity\" : { \"ForceShutdownAfter\" : 300 , \"MaxInboundConnections\" : 25 , \"AllowLoopbackConnection\" : false , \"Listeners\" : [ { \"IsWhitelistingEndpoint\" : true , \"Endpoint\" : \"0.0.0.0:45051\" }, { \"IsWhitelistingEndpoint\" : true , \"Endpoint\" : \"127.0.0.1:45052\" , \"PublicEndpoint\" : \"98.0.0.1:45011\" } ] }, \"Example\" : { \"MaxTimeAdjustment\" : 4200 , \"Connections\" : [ { \"Endpoint\" : \"127.0.0.1:45061\" , \"AdditionalInformation\" : \"I'm cool!\" } ] }, \"StatisticsCollector\" : { \"ContinuousConsoleDisplay\" : false , \"ContinuousConsoleDisplayRate\" : 5 }, \"DevController\" : { \"Enabled\" : true }, \"WebApi\" : { \"EndPoint\" : \"127.0.0.1:45020\" , \"Enabled\" : true , \"Https\" : false }, \"Serilog\" : { \"Using\" : [ \"Serilog.Sinks.Console\" , \"Serilog.Sinks.Seq\" ], \"Enrich\" : [ \"FromLogContext\" , \"WithMachineName\" , \"WithThreadId\" ], \"WriteTo\" : [ { \"Name\" : \"Console\" , \"Args\" : { \"IncludeScopes\" : true , \"theme\" : \"Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console\" } }, { \"Name\" : \"Seq\" , \"Args\" : { \"serverUrl\" : \"http://localhost:5341\" } } ], \"MinimumLevel\" : { \"Default\" : \"Debug\" , \"Override\" : { \"Bedrock.Framework\" : \"Warning\" , \"Microsoft\" : \"Warning\" , \"System\" : \"Warning\" } } } }", "title": "Running the example"}, {"location": "example-projects/#some-screenshots", "text": "Here a screenshot that shows the content of the shell when running the node with settings = forge-settings.json You can access the Swagger UI by opening the address https://127.0.0.1:45020/docs/index.html Here you can manipulate quotes using the Web API , or even manually attempt to connect to other peers using PeerManagement Connect action in the DEV area. If you installed Seq, you can access the logs in a better way like shown here:", "title": "Some Screenshots"}, {"location": "mithril-shards/", "text": "Architecture Overview Mithril Shards is a modular framework for building P2P Applications that can be expanded by additional features like Web API endpoints, MQ based services, SignalR hubs, cross platform UI and much more. Pretending to be into a Tolkien universe, I thought of defining features as shards , where each shard of mithril can be put into a forge and fused together with other mithril shards, to create a final artifact. To find analogies with .net naming conventions: Forge (to be more precise, ForgeBuilder ) is a HostBuilder on steroids (actually it encapsulate a HostBuilder instance). Shard is an application part that gets merged into the hostbuilder, using dependency injection, extending its functionality Artifact is just an allegoric view of the result of forgeBuilderInstance.RunConsoleAsync() . Note Current naming may be subject to changes. To build an application using these concepts, we have to create a ForgeBuilder, specify which Forge type to use and then we can put into the forge all the shards we need by calling AddShard method. Since a shard may require complex configurations and inject service implementations it may need, usually you don't want to call that method directly but instead you'd want to have a IForgeBuilder extension that you can put in a class in your shard project, where your initialization logic happens. That's how .Net core features and services are injected into the host builder and I think it's a good thing to use a similar approach because would be more friendly to devs used to .Net conventions. Each shard may be configured by a strong typed setting class that supports eager validation (would throw if the setting files contains invalid data) and each shard is responsible to register services it needs that would cooperate with the IForge implementation to perform needed tasks, more on this in the specific documentation sections. After all shards are added and ForgeBuilder is started by RunConsoleAsync , the forge will take care of all the plumbing stuff, initializing all the shards. For a detailed description of the components composing the Mithril Shards framework, refers to specific documentation pages. The entry point of a Mithril Shards application is the ForgeBuilder class.", "title": "Overview"}, {"location": "mithril-shards/#architecture-overview", "text": "Mithril Shards is a modular framework for building P2P Applications that can be expanded by additional features like Web API endpoints, MQ based services, SignalR hubs, cross platform UI and much more. Pretending to be into a Tolkien universe, I thought of defining features as shards , where each shard of mithril can be put into a forge and fused together with other mithril shards, to create a final artifact. To find analogies with .net naming conventions: Forge (to be more precise, ForgeBuilder ) is a HostBuilder on steroids (actually it encapsulate a HostBuilder instance). Shard is an application part that gets merged into the hostbuilder, using dependency injection, extending its functionality Artifact is just an allegoric view of the result of forgeBuilderInstance.RunConsoleAsync() . Note Current naming may be subject to changes. To build an application using these concepts, we have to create a ForgeBuilder, specify which Forge type to use and then we can put into the forge all the shards we need by calling AddShard method. Since a shard may require complex configurations and inject service implementations it may need, usually you don't want to call that method directly but instead you'd want to have a IForgeBuilder extension that you can put in a class in your shard project, where your initialization logic happens. That's how .Net core features and services are injected into the host builder and I think it's a good thing to use a similar approach because would be more friendly to devs used to .Net conventions. Each shard may be configured by a strong typed setting class that supports eager validation (would throw if the setting files contains invalid data) and each shard is responsible to register services it needs that would cooperate with the IForge implementation to perform needed tasks, more on this in the specific documentation sections. After all shards are added and ForgeBuilder is started by RunConsoleAsync , the forge will take care of all the plumbing stuff, initializing all the shards. For a detailed description of the components composing the Mithril Shards framework, refers to specific documentation pages. The entry point of a Mithril Shards application is the ForgeBuilder class.", "title": "Architecture Overview"}, {"location": "mithril-shards/default-forge/", "text": "The entry point is our forge builder class. After declaring an instance we have to specify which implementation of Forge we want to use. Actually the only available implementation is DefaultForge", "title": "DefaultForge"}, {"location": "mithril-shards/example-project/", "text": "The best way to see it in action is by inspecting the Example project I've created. Example Projects The example is composed by several projects, each one with their own scope, to mimic a (simple) typical modular application: MithrilShards.Example MithrilShards.Example.Network.Bedrock MithrilShards.Example.Dev MithrilShards.Example.Node MithrilShards.Example It contains the core classes and services needed to run the example application. Here we can find: network classes like a custom IPeerContext implementation and its factory class some custom IServerPeerConnectionGuard implementation to filter incoming connections and a custom ConnectorBase implementation that contains the logic to connect to other peers protocol classes like INetworkMessage implementations of custom messages (payloads) and complex types used within their implementation. INetworkMessage and type serializators that serialize classes into a byte representation that can be sent through the network. INetworkMessage processors that contain the logic to parse incoming messages and send messages to other peers plumbing classes like shard setting class and services used by processors or other internal components. It makes use of System.CommandLine to have implement the application as a CLI . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 using System.CommandLine; using System.CommandLine.Invocation; using System.Threading.Tasks; using MithrilShards.Core.Forge; using MithrilShards.Dev.Controller; using MithrilShards.Diagnostic.StatisticsCollector; using MithrilShards.Example.Dev; using MithrilShards.Example.Network.Bedrock; using MithrilShards.Example.Protocol; using MithrilShards.Logging.Serilog; using MithrilShards.Network.Bedrock; using Serilog; namespace MithrilShards.Example.Node { static class Program { static async Task Main(string[] args) { // Create a root command with some options var rootCommand = new RootCommand { new Option<string>( \"--settings\", getDefaultValue: () => \"forge-settings.json\", description: \"Specify the path to the forge settings file.\"), new Option<string?>( \"--log-settings\", getDefaultValue: () => null, description: \"Specify the path to the forge log settings file. If not specified, try to get logging information from the main forge settings file.\"), new Option<int>( \"--protocol-version\", getDefaultValue: () => KnownVersion.CurrentVersion, description: \"Specify the path to the forge settings file.\") }; rootCommand.Description = \"Example App\"; rootCommand.TreatUnmatchedTokensAsErrors = false; // Note that the parameters of the handler method are matched according to the names of the options rootCommand.Handler = CommandHandler.Create<string, string, int>(async (settings, logSettings, protocolVersion) => { await new ForgeBuilder() .UseForge<DefaultForge>(args, settings) .UseSerilog(logSettings) .UseBedrockNetwork<ExampleNetworkProtocolMessageSerializer>() .UseStatisticsCollector(options => options.DumpOnConsoleOnKeyPress = true) /// we are injecting ExampleDev type to allow <see cref=\"MithrilShards.WebApi.WebApiShard\"/> to find all the controllers /// defined there because only controllers defined in an included shard assemblies are discovered automatically. /// Passing ExampleDev will cause dotnet runtime to load the assembly where ExampleDev Type is defined and every /// controllers defined there will be found later during <see cref=\"MithrilShards.WebApi.WebApiShard\"/> initialization. .UseApi(options => options.ControllersSeeker = (seeker) => seeker.LoadAssemblyFromType<ExampleDev>()) .UseDevController() .UseExample(KnownVersion.V1, protocolVersion) .RunConsoleAsync() .ConfigureAwait(false); }); await rootCommand.InvokeAsync(args).ConfigureAwait(false); } } }", "title": "Example Project"}, {"location": "mithril-shards/example-project/#example-projects", "text": "The example is composed by several projects, each one with their own scope, to mimic a (simple) typical modular application: MithrilShards.Example MithrilShards.Example.Network.Bedrock MithrilShards.Example.Dev MithrilShards.Example.Node", "title": "Example Projects"}, {"location": "mithril-shards/example-project/#mithrilshardsexample", "text": "It contains the core classes and services needed to run the example application. Here we can find: network classes like a custom IPeerContext implementation and its factory class some custom IServerPeerConnectionGuard implementation to filter incoming connections and a custom ConnectorBase implementation that contains the logic to connect to other peers protocol classes like INetworkMessage implementations of custom messages (payloads) and complex types used within their implementation. INetworkMessage and type serializators that serialize classes into a byte representation that can be sent through the network. INetworkMessage processors that contain the logic to parse incoming messages and send messages to other peers plumbing classes like shard setting class and services used by processors or other internal components. It makes use of System.CommandLine to have implement the application as a CLI . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 using System.CommandLine; using System.CommandLine.Invocation; using System.Threading.Tasks; using MithrilShards.Core.Forge; using MithrilShards.Dev.Controller; using MithrilShards.Diagnostic.StatisticsCollector; using MithrilShards.Example.Dev; using MithrilShards.Example.Network.Bedrock; using MithrilShards.Example.Protocol; using MithrilShards.Logging.Serilog; using MithrilShards.Network.Bedrock; using Serilog; namespace MithrilShards.Example.Node { static class Program { static async Task Main(string[] args) { // Create a root command with some options var rootCommand = new RootCommand { new Option<string>( \"--settings\", getDefaultValue: () => \"forge-settings.json\", description: \"Specify the path to the forge settings file.\"), new Option<string?>( \"--log-settings\", getDefaultValue: () => null, description: \"Specify the path to the forge log settings file. If not specified, try to get logging information from the main forge settings file.\"), new Option<int>( \"--protocol-version\", getDefaultValue: () => KnownVersion.CurrentVersion, description: \"Specify the path to the forge settings file.\") }; rootCommand.Description = \"Example App\"; rootCommand.TreatUnmatchedTokensAsErrors = false; // Note that the parameters of the handler method are matched according to the names of the options rootCommand.Handler = CommandHandler.Create<string, string, int>(async (settings, logSettings, protocolVersion) => { await new ForgeBuilder() .UseForge<DefaultForge>(args, settings) .UseSerilog(logSettings) .UseBedrockNetwork<ExampleNetworkProtocolMessageSerializer>() .UseStatisticsCollector(options => options.DumpOnConsoleOnKeyPress = true) /// we are injecting ExampleDev type to allow <see cref=\"MithrilShards.WebApi.WebApiShard\"/> to find all the controllers /// defined there because only controllers defined in an included shard assemblies are discovered automatically. /// Passing ExampleDev will cause dotnet runtime to load the assembly where ExampleDev Type is defined and every /// controllers defined there will be found later during <see cref=\"MithrilShards.WebApi.WebApiShard\"/> initialization. .UseApi(options => options.ControllersSeeker = (seeker) => seeker.LoadAssemblyFromType<ExampleDev>()) .UseDevController() .UseExample(KnownVersion.V1, protocolVersion) .RunConsoleAsync() .ConfigureAwait(false); }); await rootCommand.InvokeAsync(args).ConfigureAwait(false); } } }", "title": "MithrilShards.Example"}, {"location": "mithril-shards/forge-builder/", "text": "ForgeBuilder class represents the entry point of a Mithril Shards application, it allows to add a shard by calling the generic AddShard method, with different overloads that accept an optional strongly typed shard setting file with an optional setting file validator. By using ConfigureLogging it's possible to configure logging, it's basically a wrapper on the inner hostbiulder ConfigureLogging method, you could use it to have a finer control over logging configuration and available providers, but the easier way to log is by using the available SerilogShard that uses Serilog to configure the logging and relies on a configurable setting file where you can specify which sink to use. You can find more details on its specific documentation page and an example of its usage in the example project After declaring an instance we have to specify which implementation of Forge we want to use. Actually the only available implementation is DefaultForge class.", "title": "ForgeBuilder"}, {"location": "mithril-shards/shards/", "text": "What is a shard When you think about a Mithril Shard, you have to think of it as a set of services that extend the capabilities of the application you are building. In layman's terms shards can augment the final application with additional functionality (features) and this is the core concept of a modular application framework. When you build an application using Mithril Shards you are like a blacksmith in an epic fantasy novel: you chose which shards of mithril to use, put them into the forge, melt them together and finally shape the final: your powerful artifact! I'd like to know the artist to give him credits for the image above. But we are not living in a Tolkien novel, so what we do is : choose the shards we need (either by creating them, forking their code or referencing their nuget package) add them to the ForgeBuilder using some extension method that the shard developer has created for us and that may contains some optional parameters configure shards based on their available settings and our needs in the application configuration file (by default it's forge-settings.json but can be changed when the IForge implementation is chosen by calling ForgeBuilder UseForge method) execute the forge builder to run the program. The example project contains code to show how to achieve this.", "title": "Understanding Shards"}, {"location": "mithril-shards/shards/#what-is-a-shard", "text": "When you think about a Mithril Shard, you have to think of it as a set of services that extend the capabilities of the application you are building. In layman's terms shards can augment the final application with additional functionality (features) and this is the core concept of a modular application framework. When you build an application using Mithril Shards you are like a blacksmith in an epic fantasy novel: you chose which shards of mithril to use, put them into the forge, melt them together and finally shape the final: your powerful artifact! I'd like to know the artist to give him credits for the image above. But we are not living in a Tolkien novel, so what we do is : choose the shards we need (either by creating them, forking their code or referencing their nuget package) add them to the ForgeBuilder using some extension method that the shard developer has created for us and that may contains some optional parameters configure shards based on their available settings and our needs in the application configuration file (by default it's forge-settings.json but can be changed when the IForge implementation is chosen by calling ForgeBuilder UseForge method) execute the forge builder to run the program. The example project contains code to show how to achieve this.", "title": "What is a shard"}, {"location": "shards/bedrock-network/", "text": "BedrockNetworkShard is a very important shard that provides to the forge the required connectivity implementation used to connects to other peers and accept peers connection requests. It implements the connectivity interfaces", "title": "Overview"}, {"location": "shards/bitcoin/", "text": "Premise This folder contains technical documentation that helps to understand the choices behind the implementation and design of current project. Personally I'm not a fan of bitcoin core code base: even if it improved since early days, it's confusing, it lacks of an homogeneous design and architecture and suffers from old bad choices and above all lacks of proper technical documentation, following the mantra \"source code is the documentation\". To be clear, I don't blame who contributes on bitcoin core, I'm just stating objective facts and I hope to fix some of these issues with my project. I don't pretend to have all the documentation always in sync with latest changes because it's a huge effort and I agree at a large extent that source code is the final judge and I encourage you to dig into it if you want to go deeper in implementation details or verify that an information written here is correct. Please, if you find any issue about documentation, feel free to open an issue and I'll be happy to fix it (even a PR with your corrections can be valuable!). To me a proper documentation doesn't have to explain the source code (source code should be as much readable as possible) but it should give insights about the process that leads toward specific implementations and have indications about good practice to work within the built library. Beside this premise, I'm writing this documentation as if I were the target, in order to have a maintainable and easy to follow repository and of course be able to give good understanding about how to extend this project further with custom features (shards) to people that may be interested. Nevertheless I would be happy to know that it could be useful to someone who may find it interesting and help in understanding why an approach has been chosen over another! Also if you have question or want to discuss about technical details, you can use the repository Discussion section . Project Overview Bitcoin Mithril Shard has been built on top of Mithril Shards framework. Mithril Shards goal is to be a framework and toolkit to build modular and distributed/ P2P applications using .Net 5 stack, focusing both on good design, good practices and performance. Core functionalities can be glued togheter to compose the needed application, ranging from a P2P network layer, Web Api layer, Diagnostic tools, cross platform UI based on blazor, distributed eventing using SignalR, MQ brokers like RabbitMq or any kind of other useful libraries. Thanks to its design, anyone can build it's own Shard to create other features that can be used by Mithril Shards community. More details about Mithril Shards can be found on the main documentation (TODO). Bitcoin shard is a very good example about how to build a fully functional full node for bitcoin, leveraging all the juicy features that Mithril Shards exposes. Network layer is implemented by leveraging Bedrock Framework for the TCP implementation using both Client and Server connections. Data is serialized thanks to an well defined set of interfaces and classes that allows to implement an easy to read and maintain code. Incoming messages are dispatched to \"Message Processors\" that allow to handle the application logic following a good practice of separation of concerns. Meaningful events are dispatched using a message bus implementation that can reach any component in any application layer. A Web API infrastructure allow to create Web API endpoint easily and each feature can have its set of API published on different document specifications. Swagger is used as a UI to expose these API documents and allows to execute these APIs straight from that interface. For development/debugging purpose, a Shard inject some useful endpoint to inspect internal details of the running application. Logging is done using structured logging, makes use of Serilog to persist them and a configuration example shows how to use Seq to have a very good UI to view logs, filter them, etc... Blazor is used to implement a cross platform UI as a companion for the full node.", "title": "Overview"}, {"location": "shards/bitcoin/#premise", "text": "This folder contains technical documentation that helps to understand the choices behind the implementation and design of current project. Personally I'm not a fan of bitcoin core code base: even if it improved since early days, it's confusing, it lacks of an homogeneous design and architecture and suffers from old bad choices and above all lacks of proper technical documentation, following the mantra \"source code is the documentation\". To be clear, I don't blame who contributes on bitcoin core, I'm just stating objective facts and I hope to fix some of these issues with my project. I don't pretend to have all the documentation always in sync with latest changes because it's a huge effort and I agree at a large extent that source code is the final judge and I encourage you to dig into it if you want to go deeper in implementation details or verify that an information written here is correct. Please, if you find any issue about documentation, feel free to open an issue and I'll be happy to fix it (even a PR with your corrections can be valuable!). To me a proper documentation doesn't have to explain the source code (source code should be as much readable as possible) but it should give insights about the process that leads toward specific implementations and have indications about good practice to work within the built library. Beside this premise, I'm writing this documentation as if I were the target, in order to have a maintainable and easy to follow repository and of course be able to give good understanding about how to extend this project further with custom features (shards) to people that may be interested. Nevertheless I would be happy to know that it could be useful to someone who may find it interesting and help in understanding why an approach has been chosen over another! Also if you have question or want to discuss about technical details, you can use the repository Discussion section .", "title": "Premise"}, {"location": "shards/bitcoin/#project-overview", "text": "Bitcoin Mithril Shard has been built on top of Mithril Shards framework. Mithril Shards goal is to be a framework and toolkit to build modular and distributed/ P2P applications using .Net 5 stack, focusing both on good design, good practices and performance. Core functionalities can be glued togheter to compose the needed application, ranging from a P2P network layer, Web Api layer, Diagnostic tools, cross platform UI based on blazor, distributed eventing using SignalR, MQ brokers like RabbitMq or any kind of other useful libraries. Thanks to its design, anyone can build it's own Shard to create other features that can be used by Mithril Shards community. More details about Mithril Shards can be found on the main documentation (TODO). Bitcoin shard is a very good example about how to build a fully functional full node for bitcoin, leveraging all the juicy features that Mithril Shards exposes. Network layer is implemented by leveraging Bedrock Framework for the TCP implementation using both Client and Server connections. Data is serialized thanks to an well defined set of interfaces and classes that allows to implement an easy to read and maintain code. Incoming messages are dispatched to \"Message Processors\" that allow to handle the application logic following a good practice of separation of concerns. Meaningful events are dispatched using a message bus implementation that can reach any component in any application layer. A Web API infrastructure allow to create Web API endpoint easily and each feature can have its set of API published on different document specifications. Swagger is used as a UI to expose these API documents and allows to execute these APIs straight from that interface. For development/debugging purpose, a Shard inject some useful endpoint to inspect internal details of the running application. Logging is done using structured logging, makes use of Serilog to persist them and a configuration example shows how to use Seq to have a very good UI to view logs, filter them, etc... Blazor is used to implement a cross platform UI as a companion for the full node.", "title": "Project Overview"}, {"location": "shards/bitcoin/network/", "text": "Network Protocol The Bitcoin network protocol is a TCP protocol that serializes messages starting from a special 4 bytes constant data called Magic bytes , followed by 12 bytes representing the command name , 4 bytes representing the payload size and 4 bytes with the checksum of the payload. More specific information about bitcoin protocol can be found here. Mithril Shards implements a low level stack of interfaces and implementations that allow to focus on the application logic instead on low level details. A default implementation uses Bedrock Framework to leverage the low level communication between peers and this is what's used in the Bitcoin shard to provide P2P connectivity. A typical Bitcoin full node (henceforth called FN ) is able to connect to other nodes and accept incoming connections. Before two peers can exchange information, they have to perform an handshake to prove that they can understand each other (more details on the the bitcoin network protocol can be found on this bitcoin developer resource ). Before being able to handshake, whenever a connection has been established between two peers the FN stores some metadata about the remote peer. This data is stored into a class that implements IPeerContext interface and its implementation represents our next section. Peer Context Default Mithril Shards implementation uses PeerContext class to store, among other things, information like peer unique identification, direction (inbound/outbound) remote and local endpoints, user agent identification, negotiated protocol version and other attachable properties leveraging the .Net IFeatureCollection interface. Bitcoin needs some additional information and some of the properties that are ubiquitous needed among all optional Bitcoin features (shards) like wallet, APIs, indexer, etc... have been defined directly into BitcoinPeerContext that extends the default PeerContext . Some of the additional properties are Permissions (that may change the FN behavior based on its set) and TimeOffset, that's an important aspect for the consensus logic. Another important property exposed by peer context is the ConnectionCancellationTokenSource property, that's a CancellationTokenSource that can be used to trigger the disconnection from a peer. It's internally used to know when the connection has been closed, to stop the execution of async methods that rely on an active connection to a remote peer. As per IPeerContext interface, ConnectionCancellationTokenSource can only be read so it's important that custom implementation of IPeerContext don't change it's value out of constructor. This property is actively used within message processors (more about it in a later section). The cancellation of ConnectionCancellationTokenSource shouldn't be canceled directly, to force a peer disconnection an event of type PeerDisconnectionRequired has to be published on the event bus, but for simplicity BitcoinPeerContext implements a Disconnect method that does that. So anytime you have a need to disconnect a peer, just call thePeerContext.Disconnect(\"My Disconnection reason!\") . You can find already usage of it in message processor classes. The peer context creation is handled by the core Mithril Shard network implementation and since it can't know about the BitcoinPeerContext properties, it relies on a peer context factory, in this case we are talking about BitcoinPeerContextFactory class. It leverages the generic class PeerContextFactory<> and its implementation is bare bone, no need to override anything. 1 public class PeerContextFactory < TPeerContext > : IPeerContextFactory where TPeerContext : IPeerContext Accepting a connection Once the peer context has been created, a sanity check is performed to see if the two peers can connect to each other before trying to handshake and the behavior is very similar to both inbound and outbound connections. The only difference is that actually for outgoing connection the check is done before trying to connect but very likely it would be done as per incoming connection soon. What happens when an incoming connection has been accepted is that the connection has to pass all registered (in the DI containers) implementations of IServerPeerConnectionGuard interface. ServerPeerConnectionGuardBase In Bitcoin shard all guard rules are extending ServerPeerConnectionGuardBase implementation that's a simple class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public abstract class ServerPeerConnectionGuardBase : IServerPeerConnectionGuard { protected readonly ILogger logger ; protected readonly ForgeConnectivitySettings settings ; public ServerPeerConnectionGuardBase ( ILogger logger , IOptions < ForgeConnectivitySettings > options ) { this . logger = logger ; settings = options . Value ; } public ServerPeerConnectionGuardResult Check ( IPeerContext peerContext ) { string? denyReason = TryGetDenyReason ( peerContext ); if (! string . IsNullOrEmpty ( denyReason )) { logger . LogDebug ( \"Peer connection guard not passed: {denyReason}\" , denyReason ); return ServerPeerConnectionGuardResult . Deny ( denyReason ); } return ServerPeerConnectionGuardResult . Allow (); } internal abstract string? TryGetDenyReason ( IPeerContext peerContext ); } This class implements the plumbing code required to run (and log in case of rule check not passed) the guard rule, so a guard rule implementation has just to focus on its guarding logic. A simple example is the MaxConnectionThresholdGuard rule that ensure that an incoming transaction doesn't exceed the maximum allowed number of inbound connections: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MaxConnectionThresholdGuard : ServerPeerConnectionGuardBase { readonly IConnectivityPeerStats _peerStats ; public MaxConnectionThresholdGuard ( ILogger < MaxConnectionThresholdGuard > logger , IOptions < ForgeConnectivitySettings > settings , IConnectivityPeerStats serverPeerStats ) : base ( logger , settings ) { _peerStats = serverPeerStats ; } internal override string? TryGetDenyReason ( IPeerContext peerContext ) { if ( _peerStats . ConnectedInboundPeersCount >= settings . MaxInboundConnections ) { return \"Inbound connection refused: max connection threshold reached.\" ; } return null ; } } In order to be used during connection check, these guard classes have to be registered in the DI container. MaxConnectionThresholdGuard for example is registered into the extension that register the bitcoin shard by using 1 services.AddSingleton<IServerPeerConnectionGuard, InitialBlockDownloadStateGuard>() This allow the flexibility of having custom guard rule simply by implementing a rule and register in the DI container, any required service will be injected automatically; of course if it relies on a custom service not already available in my implementation, that service has to be registered too. Info These classes have to be registered as singleton and therefor must be stateless Network protocol is implemented through the serialization of classes which implement INetworkMessage interface and are decorated with NetworkMessageAttribute that works in synergy with an implementation of INetworkMessageSerializer to implement network serialization. Handshake Once a connection has been accepted between two nodes, they start exchanging messages in order to handshake and prove each other they are two compatible nodes that can exchange informations. Info Bitcoin protocol doesn't punish nodes that send unknown messages. I think however that a node has to monitor its connected peer activities and punish them if they send too many unknown messages causing our node to waste resources. Without going too deeper into bitcoin handshake process, the exchanges messages are summarized by this sequence diagram: sequenceDiagram participant L as Local participant R as Remote L-->>+R:Connects to L->>+R:Version R->>L:Version R->>L:Verack L->>R:Verack Info Bitcoin protocol doesn't define a specific order for the Remote node to send its Verack and Version message so Local node has to account that and accept these messages in any order.", "title": "Network implementation"}, {"location": "shards/bitcoin/network/#network-protocol", "text": "The Bitcoin network protocol is a TCP protocol that serializes messages starting from a special 4 bytes constant data called Magic bytes , followed by 12 bytes representing the command name , 4 bytes representing the payload size and 4 bytes with the checksum of the payload. More specific information about bitcoin protocol can be found here. Mithril Shards implements a low level stack of interfaces and implementations that allow to focus on the application logic instead on low level details. A default implementation uses Bedrock Framework to leverage the low level communication between peers and this is what's used in the Bitcoin shard to provide P2P connectivity. A typical Bitcoin full node (henceforth called FN ) is able to connect to other nodes and accept incoming connections. Before two peers can exchange information, they have to perform an handshake to prove that they can understand each other (more details on the the bitcoin network protocol can be found on this bitcoin developer resource ). Before being able to handshake, whenever a connection has been established between two peers the FN stores some metadata about the remote peer. This data is stored into a class that implements IPeerContext interface and its implementation represents our next section.", "title": "Network Protocol"}, {"location": "shards/bitcoin/network/#peer-context", "text": "Default Mithril Shards implementation uses PeerContext class to store, among other things, information like peer unique identification, direction (inbound/outbound) remote and local endpoints, user agent identification, negotiated protocol version and other attachable properties leveraging the .Net IFeatureCollection interface. Bitcoin needs some additional information and some of the properties that are ubiquitous needed among all optional Bitcoin features (shards) like wallet, APIs, indexer, etc... have been defined directly into BitcoinPeerContext that extends the default PeerContext . Some of the additional properties are Permissions (that may change the FN behavior based on its set) and TimeOffset, that's an important aspect for the consensus logic. Another important property exposed by peer context is the ConnectionCancellationTokenSource property, that's a CancellationTokenSource that can be used to trigger the disconnection from a peer. It's internally used to know when the connection has been closed, to stop the execution of async methods that rely on an active connection to a remote peer. As per IPeerContext interface, ConnectionCancellationTokenSource can only be read so it's important that custom implementation of IPeerContext don't change it's value out of constructor. This property is actively used within message processors (more about it in a later section). The cancellation of ConnectionCancellationTokenSource shouldn't be canceled directly, to force a peer disconnection an event of type PeerDisconnectionRequired has to be published on the event bus, but for simplicity BitcoinPeerContext implements a Disconnect method that does that. So anytime you have a need to disconnect a peer, just call thePeerContext.Disconnect(\"My Disconnection reason!\") . You can find already usage of it in message processor classes. The peer context creation is handled by the core Mithril Shard network implementation and since it can't know about the BitcoinPeerContext properties, it relies on a peer context factory, in this case we are talking about BitcoinPeerContextFactory class. It leverages the generic class PeerContextFactory<> and its implementation is bare bone, no need to override anything. 1 public class PeerContextFactory < TPeerContext > : IPeerContextFactory where TPeerContext : IPeerContext", "title": "Peer Context"}, {"location": "shards/bitcoin/network/#accepting-a-connection", "text": "Once the peer context has been created, a sanity check is performed to see if the two peers can connect to each other before trying to handshake and the behavior is very similar to both inbound and outbound connections. The only difference is that actually for outgoing connection the check is done before trying to connect but very likely it would be done as per incoming connection soon. What happens when an incoming connection has been accepted is that the connection has to pass all registered (in the DI containers) implementations of IServerPeerConnectionGuard interface.", "title": "Accepting a connection"}, {"location": "shards/bitcoin/network/#serverpeerconnectionguardbase", "text": "In Bitcoin shard all guard rules are extending ServerPeerConnectionGuardBase implementation that's a simple class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public abstract class ServerPeerConnectionGuardBase : IServerPeerConnectionGuard { protected readonly ILogger logger ; protected readonly ForgeConnectivitySettings settings ; public ServerPeerConnectionGuardBase ( ILogger logger , IOptions < ForgeConnectivitySettings > options ) { this . logger = logger ; settings = options . Value ; } public ServerPeerConnectionGuardResult Check ( IPeerContext peerContext ) { string? denyReason = TryGetDenyReason ( peerContext ); if (! string . IsNullOrEmpty ( denyReason )) { logger . LogDebug ( \"Peer connection guard not passed: {denyReason}\" , denyReason ); return ServerPeerConnectionGuardResult . Deny ( denyReason ); } return ServerPeerConnectionGuardResult . Allow (); } internal abstract string? TryGetDenyReason ( IPeerContext peerContext ); } This class implements the plumbing code required to run (and log in case of rule check not passed) the guard rule, so a guard rule implementation has just to focus on its guarding logic. A simple example is the MaxConnectionThresholdGuard rule that ensure that an incoming transaction doesn't exceed the maximum allowed number of inbound connections: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MaxConnectionThresholdGuard : ServerPeerConnectionGuardBase { readonly IConnectivityPeerStats _peerStats ; public MaxConnectionThresholdGuard ( ILogger < MaxConnectionThresholdGuard > logger , IOptions < ForgeConnectivitySettings > settings , IConnectivityPeerStats serverPeerStats ) : base ( logger , settings ) { _peerStats = serverPeerStats ; } internal override string? TryGetDenyReason ( IPeerContext peerContext ) { if ( _peerStats . ConnectedInboundPeersCount >= settings . MaxInboundConnections ) { return \"Inbound connection refused: max connection threshold reached.\" ; } return null ; } } In order to be used during connection check, these guard classes have to be registered in the DI container. MaxConnectionThresholdGuard for example is registered into the extension that register the bitcoin shard by using 1 services.AddSingleton<IServerPeerConnectionGuard, InitialBlockDownloadStateGuard>() This allow the flexibility of having custom guard rule simply by implementing a rule and register in the DI container, any required service will be injected automatically; of course if it relies on a custom service not already available in my implementation, that service has to be registered too. Info These classes have to be registered as singleton and therefor must be stateless Network protocol is implemented through the serialization of classes which implement INetworkMessage interface and are decorated with NetworkMessageAttribute that works in synergy with an implementation of INetworkMessageSerializer to implement network serialization.", "title": "ServerPeerConnectionGuardBase"}, {"location": "shards/bitcoin/network/#handshake", "text": "Once a connection has been accepted between two nodes, they start exchanging messages in order to handshake and prove each other they are two compatible nodes that can exchange informations. Info Bitcoin protocol doesn't punish nodes that send unknown messages. I think however that a node has to monitor its connected peer activities and punish them if they send too many unknown messages causing our node to waste resources. Without going too deeper into bitcoin handshake process, the exchanges messages are summarized by this sequence diagram: sequenceDiagram participant L as Local participant R as Remote L-->>+R:Connects to L->>+R:Version R->>L:Version R->>L:Verack L->>R:Verack Info Bitcoin protocol doesn't define a specific order for the Remote node to send its Verack and Version message so Local node has to account that and accept these messages in any order.", "title": "Handshake"}, {"location": "shards/bitcoin/testing_node_communication/", "text": "Testing node communication In order to test the Forge implementation, I used the handy bitcoin testnet in a box I used the docker implementation: docker pull freewil/bitcoin-testnet-box then I modified the suggested docker run arguments, in order to open the node port, this way, to run the image with an reachable testnet node, run the image as docker run -t -i -p 19000:19000 -p 19001:19001 -p 19011:19011 freewil/bitcoin-testnet-box after that, in the tty console, write make start to start the node and this way you can connect to the testnet box using the endpoint 127.0.0.1:19000 If everything is going as expected and you ran the Forge within bitcoin-testnet network, you should see something similar to this At the time of the screenshot (2nd of January 2020) only the handshake implementation was ready, this is why of warnings following the successful handshake. Troubleshooting System.Net.Sockets.SocketException (10013) In case you receive this error while trying to open some port for listening, the reason may be your OS is excluding some port ranges for some reason. To check if the port is reserved, you can use the command netsh interface ipv4 show excludedportrange tcp you'll see a list of port ranges that may include the port you are trying to open. To fix that your best bet is to just change the port you want to use in your configuration file, otherwise you need to understand why a specific port range is being reserved and eventually change it. You can delete the excludedportrange if you want and you know what you are doing, using commands like netsh int ipv4 delete excludedportrange protocol=tcp startport=45000 numberofports=100 and add new ones with netsh int ipv4 add excludedportrange protocol=tcp startport=45000 numberofports=100", "title": "Testing node communication"}, {"location": "shards/bitcoin/testing_node_communication/#testing-node-communication", "text": "In order to test the Forge implementation, I used the handy bitcoin testnet in a box I used the docker implementation: docker pull freewil/bitcoin-testnet-box then I modified the suggested docker run arguments, in order to open the node port, this way, to run the image with an reachable testnet node, run the image as docker run -t -i -p 19000:19000 -p 19001:19001 -p 19011:19011 freewil/bitcoin-testnet-box after that, in the tty console, write make start to start the node and this way you can connect to the testnet box using the endpoint 127.0.0.1:19000 If everything is going as expected and you ran the Forge within bitcoin-testnet network, you should see something similar to this At the time of the screenshot (2nd of January 2020) only the handshake implementation was ready, this is why of warnings following the successful handshake.", "title": "Testing node communication"}, {"location": "shards/bitcoin/testing_node_communication/#troubleshooting", "text": "", "title": "Troubleshooting"}, {"location": "shards/bitcoin/testing_node_communication/#systemnetsocketssocketexception-10013", "text": "In case you receive this error while trying to open some port for listening, the reason may be your OS is excluding some port ranges for some reason. To check if the port is reserved, you can use the command netsh interface ipv4 show excludedportrange tcp you'll see a list of port ranges that may include the port you are trying to open. To fix that your best bet is to just change the port you want to use in your configuration file, otherwise you need to understand why a specific port range is being reserved and eventually change it. You can delete the excludedportrange if you want and you know what you are doing, using commands like netsh int ipv4 delete excludedportrange protocol=tcp startport=45000 numberofports=100 and add new ones with netsh int ipv4 add excludedportrange protocol=tcp startport=45000 numberofports=100", "title": "System.Net.Sockets.SocketException (10013)"}, {"location": "shards/dev-controller/", "text": "DevControllerShard is a shard that depends on WebApiShard , it's goal is to inject some useful controllers meant to be used in DEV area. To add DevControllerShard into the forge you can use the IForgeBuilder extension UseDevController . Note This shard register a new ApiServiceDefinition for the dev area, so if you plan implementing a custom feature that aims to add one or more controller to DEV area, remember to add this shard or register yourself the DEV area. Current available controllers are PeerManagementController , ShardsController and StaticsController . PeerManagementController This controller exposes actions useful to connect or disconnect from a specific peer. It leverages RequiredConnection service whose task is to periodically try to connect to a issued list of peers. The list of peers can be issued both by Connect API or by configuration file using the Connect property of ForgeConnectivitySettings settings, used by BedrockNetworkShard .", "title": "Overview"}, {"location": "shards/dev-controller/#peermanagementcontroller", "text": "This controller exposes actions useful to connect or disconnect from a specific peer. It leverages RequiredConnection service whose task is to periodically try to connect to a issued list of peers. The list of peers can be issued both by Connect API or by configuration file using the Connect property of ForgeConnectivitySettings settings, used by BedrockNetworkShard .", "title": "PeerManagementController"}, {"location": "shards/serilog/", "text": "SerilogShard allows to inject Serilog log provider into the forge, allowing every service to leverage it to produce a proper loggin implementation for the application. It can be injected into the forge just by using the IForgeBuilder extension 1 public static IForgeBuilder UseSerilog ( this IForgeBuilder forgeBuilder , string? configurationFile = null ) configurationFile is optional, and can contain the path of a JSON configuration file, refers to Serilog documentation to see how to configure it properly. If no configurationFile is specified, the forge configuration file is used. Note Using an explicit configuration file allows to have more control over the configuration files used during debug and deploy, because allows you to have a file for application configuration, and a different set of configuration files specific for logging, where you can pre-configure a set of filters based on your needs An example of a configuration section is this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 { \"Serilog\" : { \"Using\" : [ \"Serilog.Sinks.Console\" , \"Serilog.Sinks.Seq\" ], \"Enrich\" : [ \"FromLogContext\" , \"WithMachineName\" , \"WithThreadId\" ], \"WriteTo\" : [ { \"Name\" : \"Console\" , \"Args\" : { \"IncludeScopes\" : true , \"theme\" : \"Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console\" } }, { \"Name\" : \"Seq\" , \"Args\" : { \"serverUrl\" : \"http://localhost:5341\" } } ], \"MinimumLevel\" : { \"Default\" : \"Debug\" , \"Override\" : { \"Bedrock.Framework\" : \"Warning\" , \"Microsoft\" : \"Warning\" , \"System\" : \"Warning\" } } } } In this example we are defining two serilog sinks: console and seq sink . MinimulLevel section allows to configure the filter based on logging severity level, in this case the default level is Debug and we have a couple of override to rise the level to warning for all classes belonging to namespace Bedrok.Framework , Microsoft and System Tweaking these settings is important to reduce the noise of unwanted logs of 3rd party libraries and focus our attention on logs that matter to us. Console Sink Console configure the logger to use console output and in the WriteTo section we specify to include scopes and use a theme to colorize the output. An output example is this Seq Sink Seq is an interesting web application that can be configured to receive logs generated by Serilog, it has a free plan for single user and in my case it was a good choice for development purpose because I can host it in my local environment and leverage its feature to be able to investigate problems. It can be both installed locally or be hosted in a docker container. In the example above it has been configured to receive logs on port 5341 1 2 3 4 { \"Name\" : \"Seq\" , \"Args\" : { \"serverUrl\" : \"http://localhost:5341\" } } It shares the same MinimumLevel section to configure which logs will be persisted but can have dynamic overrides. Seq allows you to query, create filters, signals and show structured logs in a friendly way, for further information refers to Seq website. An example of Seq interface with a couple of expanded logs, to show you additional information you can found in these logs", "title": "Overview"}, {"location": "shards/serilog/#console-sink", "text": "Console configure the logger to use console output and in the WriteTo section we specify to include scopes and use a theme to colorize the output. An output example is this", "title": "Console Sink"}, {"location": "shards/serilog/#seq-sink", "text": "Seq is an interesting web application that can be configured to receive logs generated by Serilog, it has a free plan for single user and in my case it was a good choice for development purpose because I can host it in my local environment and leverage its feature to be able to investigate problems. It can be both installed locally or be hosted in a docker container. In the example above it has been configured to receive logs on port 5341 1 2 3 4 { \"Name\" : \"Seq\" , \"Args\" : { \"serverUrl\" : \"http://localhost:5341\" } } It shares the same MinimumLevel section to configure which logs will be persisted but can have dynamic overrides. Seq allows you to query, create filters, signals and show structured logs in a friendly way, for further information refers to Seq website. An example of Seq interface with a couple of expanded logs, to show you additional information you can found in these logs", "title": "Seq Sink"}, {"location": "shards/web-api/", "text": "WebApiShard is an important shard that allows to expose Web API endpoints based on OpeAPI specifications . Swashbuckle is used under the hood and you can find more technical information about OpenAPI, REST APIs and Swagger concepts on microsoft documentation . WebApiShard comes with a WebApiSettings class that holds settings to configure the service. To add the shard to the forge, the IForgeBuilder extension UseApi has to be called, passing optional options to further configure the service 1 public static IForgeBuilder UseApi ( this IForgeBuilder forgeBuilder , Action < WebApiOptions >? options = null ) WebApiShard implements the Web API controllers using the standard aspnet ControllerBase class but decorates it with a set of default attributes needed to expose these controllers in the right context. To create a proper WebApiShard controller, an abstract base class MithrilControllerBase exists that applies already the required attributes. 1 2 3 4 [ApiController] [Produces(\"application/json\")] [Route(\"[area] /[ controller ]/[ action ] \")] public abstract class MithrilControllerBase : ControllerBase { } Areas are used to subdivide APIs based on grouping criteria and each area can be enabled or disabled by configuring the corresponding ApiServiceDefinition . By default two areas are defined but custom areas can be created easily. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /// <summary> /// Placeholder to define known core Web API areas. /// This class may be extended to add more const for 3rd party areas. /// </summary> public abstract class WebApiArea { /// <summary> /// The default API area where common actions will be available. /// </summary> public const string AREA_API = \"api\" ; /// <summary> /// The area where Dev controllers has to be placed. /// Dev controllers are controllers useful during debug that can expose internal details /// or are risky to be used in a public environment /// They may be risky to execute by an end user that doesn't have good technical details /// knowledge about the application. /// </summary> public const string AREA_DEV = \"dev\" ; } Note WebApiShard controllers have to belong to a specific area. More information in Creating a Controller section. DisableByEndPointActionFilterAttribute class, that's a registered ActionFilterAttribute , is responsible to enforce proper checks against executing an action on an unspecified, unknown or disabled area. Warning The current implementation may be subject to changes to implement the authentication and authorization layer.", "title": "Overview"}, {"location": "shards/web-api/areas/", "text": "WebApiShard organize controllers assigning them to specific areas. Areas are used to subdivide APIs based on grouping criteria and each area can be enabled or disabled by configuring the corresponding ApiServiceDefinition . By default two areas are defined: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /// <summary> /// Placeholder to define known core Web API areas. /// This class may be extended to add more const for 3rd party areas. /// </summary> public abstract class WebApiArea { /// <summary> /// The default API area where common actions will be available. /// </summary> public const string AREA_API = \"api\" ; /// <summary> /// The area where Dev controllers has to be placed. /// Dev controllers are controllers useful during debug that can expose internal details /// or are risky to be used in a public environment /// They may be risky to execute by an end user that doesn't have good technical details /// knowledge about the application. /// </summary> public const string AREA_DEV = \"dev\" ; } Custom areas can be created easily by defining them using ApiServiceDefinition . DevControllerShard for example defines its own ApiServiceDefinition to group all controllers meant to be used for development / diagnostic purpose. Note Any WebApiShard compliant controller has to belong to a specific area, by specifying an AreaAttribute at controller class level. ApiServiceDefinition ApiServiceDefinition is a class responsible to hold a WEB Api area configuration. It contains an Enabled property used to enable or disable that specific area and its value is usually set by using the configuration file of the shard responsible for the ApiServiceDefinition. DevControllerShard code shows an example of how to register an area during the shard registration: 1 2 3 4 5 6 7 8 9 10 11 12 13 forgeBuilder . AddShard < DevControllerShard , DevControllerSettings >(( context , services ) => { if ( context . GetShardSettings < DevControllerSettings >()!. Enabled ) { services . AddApiServiceDefinition ( new ApiServiceDefinition { Area = WebApiArea . AREA_DEV , Name = \"Dev API\" , Description = \"API useful for debug purpose.\" , Version = \"v1\" , }); } }); In this example you can see that Area is set to WebApiArea.AREA_DEV that's simply a constant string that's the equivalent of set it to \"dev\" and Enabled is set to settings.Enabled , this way it's enabled or disabled based on the DevControllerSettings configuration. Note Each different ApiServiceDefinition generates an OpenAPI document following its specification. Swagger UI allows to select which document to show, see Using Swagger UI section. An OpenAPI document can be used by tools like AutoRest to generate automatically clients for RESTful API , not just for C# but for many other languages (after all OpenAPI is an agnostic specification). Creating custom areas The process to create a custom area is the same as the one shown in the example above, the only difference is the Area value, that can be any string. If we want to create an area named \"area51\" and be available for controllers defined in our shards or a 3rd party shards, we can register such area by creating a new ApiServiceDefinition instance and register it using AddApiServiceDefinition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 forgeBuilder . AddShard < YourShard , YourShardSettings >(( context , services ) => { if ( context . GetShardSettings < YourShardSettings >()!. Enabled ) { services . AddApiServiceDefinition ( new ApiServiceDefinition { Enabled = true , Area = \"area51\" , Name = \"Area 51 - trust no one!\" , Description = \"Nothing to see here...\" , Version = \"v1\" , }); } }); The example above implies that YourShardSettings has a Enabled boolean property that describes if the shard has to generate or not an ApiServiceDefinition. You are free to skip that check if you want to have an area always defined and/or want to tweak the ApiServiceDefinition Enabled property at runtime based on some custom conditions. Note An ApiServiceDefinition can be enabled or disabled at runtime by changing its Enabled property. Registering an area implicitly generates its OpenAPI document, but access to its API are controlled by its Enabled property. In order to have controllers assigned to such area, a controller has to be decorated with an Area attribute like in this example: 1 2 [Area(\"area51\")] public class YourAreaController : MithrilControllerBase You can find more information on controller creation in the Creating a Controller section.", "title": "Web API Areas"}, {"location": "shards/web-api/areas/#apiservicedefinition", "text": "ApiServiceDefinition is a class responsible to hold a WEB Api area configuration. It contains an Enabled property used to enable or disable that specific area and its value is usually set by using the configuration file of the shard responsible for the ApiServiceDefinition. DevControllerShard code shows an example of how to register an area during the shard registration: 1 2 3 4 5 6 7 8 9 10 11 12 13 forgeBuilder . AddShard < DevControllerShard , DevControllerSettings >(( context , services ) => { if ( context . GetShardSettings < DevControllerSettings >()!. Enabled ) { services . AddApiServiceDefinition ( new ApiServiceDefinition { Area = WebApiArea . AREA_DEV , Name = \"Dev API\" , Description = \"API useful for debug purpose.\" , Version = \"v1\" , }); } }); In this example you can see that Area is set to WebApiArea.AREA_DEV that's simply a constant string that's the equivalent of set it to \"dev\" and Enabled is set to settings.Enabled , this way it's enabled or disabled based on the DevControllerSettings configuration. Note Each different ApiServiceDefinition generates an OpenAPI document following its specification. Swagger UI allows to select which document to show, see Using Swagger UI section. An OpenAPI document can be used by tools like AutoRest to generate automatically clients for RESTful API , not just for C# but for many other languages (after all OpenAPI is an agnostic specification).", "title": "ApiServiceDefinition"}, {"location": "shards/web-api/areas/#creating-custom-areas", "text": "The process to create a custom area is the same as the one shown in the example above, the only difference is the Area value, that can be any string. If we want to create an area named \"area51\" and be available for controllers defined in our shards or a 3rd party shards, we can register such area by creating a new ApiServiceDefinition instance and register it using AddApiServiceDefinition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 forgeBuilder . AddShard < YourShard , YourShardSettings >(( context , services ) => { if ( context . GetShardSettings < YourShardSettings >()!. Enabled ) { services . AddApiServiceDefinition ( new ApiServiceDefinition { Enabled = true , Area = \"area51\" , Name = \"Area 51 - trust no one!\" , Description = \"Nothing to see here...\" , Version = \"v1\" , }); } }); The example above implies that YourShardSettings has a Enabled boolean property that describes if the shard has to generate or not an ApiServiceDefinition. You are free to skip that check if you want to have an area always defined and/or want to tweak the ApiServiceDefinition Enabled property at runtime based on some custom conditions. Note An ApiServiceDefinition can be enabled or disabled at runtime by changing its Enabled property. Registering an area implicitly generates its OpenAPI document, but access to its API are controlled by its Enabled property. In order to have controllers assigned to such area, a controller has to be decorated with an Area attribute like in this example: 1 2 [Area(\"area51\")] public class YourAreaController : MithrilControllerBase You can find more information on controller creation in the Creating a Controller section.", "title": "Creating custom areas"}, {"location": "shards/web-api/creating-a-controller/", "text": "To create a controller that can be exposed by the WebApiShard we can take advantage of the MithrilControllerBase class. We can take a look at the controller implemented in the example project , to dissect it and discuss about its implementation. Let's take a meaningful part of that class and let's dissect it by highlighting some code part: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [Area(WebApiArea.AREA_API)] public class ExampleController : MithrilControllerBase { private readonly ILogger < ExampleController > _logger ; readonly IQuoteService _quoteService ; public ExampleController ( ILogger < ExampleController > logger , IQuoteService quoteService ) { _logger = logger ; _quoteService = quoteService ; } [HttpGet] [ProducesResponseType(StatusCodes.Status200OK)] public ActionResult GetQuotes () { return Ok ( _quoteService . Quotes ); } Define the area Line 1 describes, using AreaAttribute , the area we want this controller to be included. WebApiArea is an helper class that just contains a bounch of constant string of known areas: \"api\" and \"dev\". \"api\" ( WebApiArea.AREA_API ) is the area where generic purpose controller should be placed. They are meant to be used by end users or 3rd party integration, to interact with our application. \"dev\" ( WebApiArea.AREA_DEV ) is the area where Dev controllers should be placed. Dev controllers are controllers useful during debug that can expose internal details or are risky to be used in a public environment. They may be risky to execute by an end user that doesn't have good technical details knowledge about the application and generally you want to enable them when you are developing or you need to collect more information on a running instance of your application. There are some Controllers that are available out of the box when you use Mithril Shards features, an example is SerilogShard that includes SeriLogController that allows to control Log filters at runtime and it's exposed in the \"api\" area, while many more Controllers are exposed in \"dev\" area like the ones included by DevControllerShard . Tip You can create custom areas, for more information see Web API Areas documentation. Declare controller Type Line 2 is the Controller class definition and it just declare our ExampleController class that inherit from MithrilControllerBase. The name of the controller class is important because by default the actions implemented in the controller will have a route like the one defined by RouteAttribute that decorates the MithrilControllerBase 1 [Route(\"[area] /[ controller ]/[ action ] \")] area will be replaced by the are we declared our controller belongs to (e.g. \"api\"). controller is the name of the Controller class, stripping out \"Controller\" part, e.g. ExampleController will become \"Example\" action is the name of the action we can invoke ExampleController action GetQuotes URL will then become api/Example/GetQuotes . This represents the part of the URL to append to the WebApiShard configured Endpoint, so if we configured it to 127.0.0.1:45030 the complete URL will be http://127.0.0.1:45020/api/Example/GetQuotes (or https if we enabled Https). Inject services into constructor Line 7-10 is the Controller constructor. A controller is created automatically at each web request and the parameters declared in the constructor will be populated by using DI In this example, ILogger<ExampleController> logger gets populated with strongly typed instance of our logger and IQuoteService quoteService with the instance of the concrete implementation of our IQuoteService that in our example project we registered as a singleton 1 . AddSingleton < IQuoteService , QuoteService >() Note It's important to know the life cycle of our injected service because they may impact performance. If the constructor of a service is slow and that service is defined as Transient (or Scoped) every action will have to wait its completion before being able to perform its job. Implement an action Lines 13-18 declare and implement an action. In this case, the action is declared as HttpGet , this mean that it will only respond to GET requests. If you try to access that action with others HTTP verbs, it will return a status error 405 Method Not Allowed [ProducesResponseType(StatusCodes.Status200OK)] declare known action status that can be returned by the action. It's just an helpful attribute useful to produce a better documentation on swagger interface and document definition but the action itself may even generate different statuses. This documentation however don't cover canonical Web API implementation, so refer to .Net documentation . to read more about it. To return an action result, the method Ok is invoked, passing the payload (that will be serialized in JSON ) as a response. To document better the result type, we could specify in ProduceResponseTypeAttribute the returned type, it could be helpful for the consumer to know which type of object to receive back and which properties it exposes. In this example it's a simple list of string but it can be any JSON serializable type: 1 [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(List<string>))] As an additional example, this is the code of a DEV controller action that generates different status based on internal state of the node 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 [HttpPost] [ProducesResponseType(StatusCodes.Status200OK)] [ProducesResponseType(StatusCodes.Status404NotFound)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public IActionResult Connect ( PeerManagementConnectRequest request ) { if ( _requiredConnection == null ) { return NotFound ( $ \"Cannot produce output because {nameof(RequiredConnection)} is not available\" ); } if (! IPEndPoint . TryParse ( request . EndPoint , out IPEndPoint ? ipEndPoint )) { return ValidationProblem ( \"Incorrect endpoint\" ); } _requiredConnection . TryAddEndPoint ( ipEndPoint ); return Ok (); } In this example, this action will return 404 (not found) if the member variables _requiredConnection isn't set, or 400 (bad request) if the input peer isn't formatted properly as a valid endpoint. If everything goes fine it will instead return 200 (ok). Tip In case of action problems, instead of calling BadRequest or Problem method extensions, use ValidationProblem , it uses a ValidationProblemDetails response that's consistent with automatic validation error responses, as stated here . In the example above, NotFound could be replaced with ValidationProblem too for a consistent behavior. Producing documentation for Swagger UI In order to produce proper documentation to be shown on Swagger UI , XML comments within C# source can be used but the build process has to generate a documentation file. The easier way is to edit your project file adding this snippet: 1 2 3 <PropertyGroup> <GenerateDocumentationFile> true </GenerateDocumentationFile> </PropertyGroup> For Mithril Shards project defined within the Mithril Shard solution folder this is not necessary because that snippet is already defined in Directory.Build.props file. Note WebApiShard already take care of including documentation files by looking at files with the name of the assembly that contains the controller, with an .xml extension. var xmlFile = $\"{assembly.GetName().Name}.xml\"; Tip Directory.Build.props file is a powerful way to set common project configurations for complex solutions with multiple projects, you can read more about it here .", "title": "Creating a Controller"}, {"location": "shards/web-api/creating-a-controller/#define-the-area", "text": "Line 1 describes, using AreaAttribute , the area we want this controller to be included. WebApiArea is an helper class that just contains a bounch of constant string of known areas: \"api\" and \"dev\". \"api\" ( WebApiArea.AREA_API ) is the area where generic purpose controller should be placed. They are meant to be used by end users or 3rd party integration, to interact with our application. \"dev\" ( WebApiArea.AREA_DEV ) is the area where Dev controllers should be placed. Dev controllers are controllers useful during debug that can expose internal details or are risky to be used in a public environment. They may be risky to execute by an end user that doesn't have good technical details knowledge about the application and generally you want to enable them when you are developing or you need to collect more information on a running instance of your application. There are some Controllers that are available out of the box when you use Mithril Shards features, an example is SerilogShard that includes SeriLogController that allows to control Log filters at runtime and it's exposed in the \"api\" area, while many more Controllers are exposed in \"dev\" area like the ones included by DevControllerShard . Tip You can create custom areas, for more information see Web API Areas documentation.", "title": "Define the area"}, {"location": "shards/web-api/creating-a-controller/#declare-controller-type", "text": "Line 2 is the Controller class definition and it just declare our ExampleController class that inherit from MithrilControllerBase. The name of the controller class is important because by default the actions implemented in the controller will have a route like the one defined by RouteAttribute that decorates the MithrilControllerBase 1 [Route(\"[area] /[ controller ]/[ action ] \")] area will be replaced by the are we declared our controller belongs to (e.g. \"api\"). controller is the name of the Controller class, stripping out \"Controller\" part, e.g. ExampleController will become \"Example\" action is the name of the action we can invoke ExampleController action GetQuotes URL will then become api/Example/GetQuotes . This represents the part of the URL to append to the WebApiShard configured Endpoint, so if we configured it to 127.0.0.1:45030 the complete URL will be http://127.0.0.1:45020/api/Example/GetQuotes (or https if we enabled Https).", "title": "Declare controller Type"}, {"location": "shards/web-api/creating-a-controller/#inject-services-into-constructor", "text": "Line 7-10 is the Controller constructor. A controller is created automatically at each web request and the parameters declared in the constructor will be populated by using DI In this example, ILogger<ExampleController> logger gets populated with strongly typed instance of our logger and IQuoteService quoteService with the instance of the concrete implementation of our IQuoteService that in our example project we registered as a singleton 1 . AddSingleton < IQuoteService , QuoteService >() Note It's important to know the life cycle of our injected service because they may impact performance. If the constructor of a service is slow and that service is defined as Transient (or Scoped) every action will have to wait its completion before being able to perform its job.", "title": "Inject services into constructor"}, {"location": "shards/web-api/creating-a-controller/#implement-an-action", "text": "Lines 13-18 declare and implement an action. In this case, the action is declared as HttpGet , this mean that it will only respond to GET requests. If you try to access that action with others HTTP verbs, it will return a status error 405 Method Not Allowed [ProducesResponseType(StatusCodes.Status200OK)] declare known action status that can be returned by the action. It's just an helpful attribute useful to produce a better documentation on swagger interface and document definition but the action itself may even generate different statuses. This documentation however don't cover canonical Web API implementation, so refer to .Net documentation . to read more about it. To return an action result, the method Ok is invoked, passing the payload (that will be serialized in JSON ) as a response. To document better the result type, we could specify in ProduceResponseTypeAttribute the returned type, it could be helpful for the consumer to know which type of object to receive back and which properties it exposes. In this example it's a simple list of string but it can be any JSON serializable type: 1 [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(List<string>))] As an additional example, this is the code of a DEV controller action that generates different status based on internal state of the node 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 [HttpPost] [ProducesResponseType(StatusCodes.Status200OK)] [ProducesResponseType(StatusCodes.Status404NotFound)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public IActionResult Connect ( PeerManagementConnectRequest request ) { if ( _requiredConnection == null ) { return NotFound ( $ \"Cannot produce output because {nameof(RequiredConnection)} is not available\" ); } if (! IPEndPoint . TryParse ( request . EndPoint , out IPEndPoint ? ipEndPoint )) { return ValidationProblem ( \"Incorrect endpoint\" ); } _requiredConnection . TryAddEndPoint ( ipEndPoint ); return Ok (); } In this example, this action will return 404 (not found) if the member variables _requiredConnection isn't set, or 400 (bad request) if the input peer isn't formatted properly as a valid endpoint. If everything goes fine it will instead return 200 (ok). Tip In case of action problems, instead of calling BadRequest or Problem method extensions, use ValidationProblem , it uses a ValidationProblemDetails response that's consistent with automatic validation error responses, as stated here . In the example above, NotFound could be replaced with ValidationProblem too for a consistent behavior.", "title": "Implement an action"}, {"location": "shards/web-api/creating-a-controller/#producing-documentation-for-swagger-ui", "text": "In order to produce proper documentation to be shown on Swagger UI , XML comments within C# source can be used but the build process has to generate a documentation file. The easier way is to edit your project file adding this snippet: 1 2 3 <PropertyGroup> <GenerateDocumentationFile> true </GenerateDocumentationFile> </PropertyGroup> For Mithril Shards project defined within the Mithril Shard solution folder this is not necessary because that snippet is already defined in Directory.Build.props file. Note WebApiShard already take care of including documentation files by looking at files with the name of the assembly that contains the controller, with an .xml extension. var xmlFile = $\"{assembly.GetName().Name}.xml\"; Tip Directory.Build.props file is a powerful way to set common project configurations for complex solutions with multiple projects, you can read more about it here .", "title": "Producing documentation for Swagger UI"}, {"location": "shards/web-api/swagger-ui/", "text": "Swagger UI allows to visualize and interact with the Web API resources generated from OpenAPI toolset. WebApiShard makes use of it and thus we can have a nice UI to test and document our API . As stated in ApiServiceDefinition section, each area generates a different OpenAPI document and we can use tool like Swagger UI to convert that specification to turn that document into an UI that allows us to test and read documentation about our exposed API resources. An OpenAPI document can even be used by tools like AutoRest to generate automatically clients (in different programming languages) for RESTful API ! Note Mithril Shards customizes a bit the look of Swagger UI but it will be familiar to who is already used to work with it. The address to access swagger UI depends on WebApiSettings EndPoint parameter. If we consider the default EndPoint 127.0.0.1:45020 , a WebApiShard enabled application exposes Swagger at the url Swagger UI Elements Without going too deeper into documenting the UI (there are a lot of resources on the web about Swagger UI and anyway it's pretty straightforward) I want to highlight a couple of sections Document Selection It's a combo box that allows you to select one of the ApiServiceDefinition defined area that are currently enabled. In this example we have selected API that corresponds to our WebApiArea.API (or simply \"api\") area defined by WebApiShard itself. You can see another option, DEV API , that corresponds to the WebApiArea.DEV (or simply \"dev\") area defined by DevControllerShard . Note The displayed name corresponds to ApiServiceDefinition Name property. OpenAPI document URL It's the URL of the selected OpenAPI document. It can be used to generate RESTful clients with tools like AutoRest . Search Box Allows to filter Web API resources by their name or description. Performing an API request By clicking on an API entry, it's possible to execute it by clicking on Try it out button, filling the required data (in this example the field quote ) and then pressing the \"Execute\" button that will be displayed Note It is possible to provide examples and more documentation by using C# XML comments, you can find more information in the section Include Descriptions from XML Comments on Swashbuckle.AspNetCore repository or by looking at the ExampleController source code in the MithrilShards.Example.Dev project. The screenshot above shows the AddQuote action in the example project and it has been fully documented: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /// <summary> /// Adds a quote. /// </summary> /// <param name=\"quote\" example=\"Tu quoque, Brute, fili mi!\">The quote to add.</param> /// <response code=\"200\">The quote that has been added.</response> /// <remarks> /// Adds a quote to the quotes list. /// </remarks> [HttpPost] [ProducesResponseType(StatusCodes.Status200OK)] public ActionResult AddQuote ( string quote ) { _quoteService . Quotes . Add ( quote ); _logger . LogDebug ( \"A new quote has been added: `{Quote}`\" , quote ); return Ok ( quote ); }", "title": "Using Swagger UI"}, {"location": "shards/web-api/swagger-ui/#swagger-ui-elements", "text": "Without going too deeper into documenting the UI (there are a lot of resources on the web about Swagger UI and anyway it's pretty straightforward) I want to highlight a couple of sections", "title": "Swagger UI Elements"}, {"location": "shards/web-api/swagger-ui/#document-selection", "text": "It's a combo box that allows you to select one of the ApiServiceDefinition defined area that are currently enabled. In this example we have selected API that corresponds to our WebApiArea.API (or simply \"api\") area defined by WebApiShard itself. You can see another option, DEV API , that corresponds to the WebApiArea.DEV (or simply \"dev\") area defined by DevControllerShard . Note The displayed name corresponds to ApiServiceDefinition Name property.", "title": "Document Selection"}, {"location": "shards/web-api/swagger-ui/#openapi-document-url", "text": "It's the URL of the selected OpenAPI document. It can be used to generate RESTful clients with tools like AutoRest .", "title": "OpenAPI document URL"}, {"location": "shards/web-api/swagger-ui/#search-box", "text": "Allows to filter Web API resources by their name or description.", "title": "Search Box"}, {"location": "shards/web-api/swagger-ui/#performing-an-api-request", "text": "By clicking on an API entry, it's possible to execute it by clicking on Try it out button, filling the required data (in this example the field quote ) and then pressing the \"Execute\" button that will be displayed Note It is possible to provide examples and more documentation by using C# XML comments, you can find more information in the section Include Descriptions from XML Comments on Swashbuckle.AspNetCore repository or by looking at the ExampleController source code in the MithrilShards.Example.Dev project. The screenshot above shows the AddQuote action in the example project and it has been fully documented: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /// <summary> /// Adds a quote. /// </summary> /// <param name=\"quote\" example=\"Tu quoque, Brute, fili mi!\">The quote to add.</param> /// <response code=\"200\">The quote that has been added.</response> /// <remarks> /// Adds a quote to the quotes list. /// </remarks> [HttpPost] [ProducesResponseType(StatusCodes.Status200OK)] public ActionResult AddQuote ( string quote ) { _quoteService . Quotes . Add ( quote ); _logger . LogDebug ( \"A new quote has been added: `{Quote}`\" , quote ); return Ok ( quote ); }", "title": "Performing an API request"}, {"location": "shards/web-api/using-webapishard/", "text": "Add WebApiService to the forge To add the shard to the forge, the IForgeBuilder extension UseApi has to be called, passing optional options to further configure the service 1 public static IForgeBuilder UseApi ( this IForgeBuilder forgeBuilder , Action < WebApiOptions >? options = null ) WebApiOptions WebApiOptions class allows to customize the discovery process that's responsible to find and register Web API controllers end include them into a specific ApiServiceDefinition . The discovery process happens during WebApiShard initialization: it generates an ApplicationPart for each registered shard that will include all discovered MithrilControllerBase (ControllerBase) types defined in the shard assembly. ControllersSeeker Sometimes you may have a project that just holds Controllers but isn't exposed as a shard, in this scenario you can use WebApiOptions during the call of UseApi, to explicitly add an assembly to inspect for controllers. The example project makes use of this when it builds the forge: 1 2 3 4 5 /// we are injecting ExampleDev type to allow <see cref=\"WebApi.WebApiShard\"/> to find all the controllers /// defined there because only controllers defined in an included shard assemblies are discovered automatically. /// Passing ExampleDev will cause dotnet runtime to load the assembly where ExampleDev Type is defined and every /// controllers defined there will be found later during <see cref=\"WebApi.WebApiShard\"/> initialization. . UseApi ( options => options . ControllersSeeker = ( seeker ) => seeker . LoadAssemblyFromType < ExampleDev >()) By doing this WebApiOptions will create an Application part for each explicitly added assembly and all Controller types defined in that assembly will be found and added to the available controllers in their specific area. EnablePublicApi This settings enables or disables the public API area . The public area corresponds to the ApiServiceDefinition that's responsible to enable all controllers assigned to the area WebApiArea.AREA_API . If you are creating an application where a public area is never needed, you may want to use this property rather than relying on external configuration file that may be missing or edited. PublicApiDescription This settings allow to customize the description used to describe public API . Defaults to Mithril Shards public API . Title Configures the Swagger UI page title, useful for branding. Defaults to Mithril Shards Web API . WebApiSettings WebApiSettings is the class that holds configuration settings required by the shard to works. It contains few properties to configure the endpoint used to listen to API requests and its behavior: Property Type Description Default EndPoint string IP address and port number on which the shard will serve its Web API endpoint, in the form of ip_address:port . \"127.0.0.1:45020\" Https bool Whether WEB API should be exposed on HTTPS. false Enabled bool Whether WebApiShard is enabled or not. Disabling it would cause any shard depending on WebApiShard, such as custom controllers or custom areas, to be unable to be served. true Configuration properties can be set in the application configuration file, within its root section, under the name of WebApi Note every shard configuration section is mapped by default to the name of the configuration setting class, stripping out the Settings part example: 1 2 3 4 5 \"WebApi\" : { \"EndPoint\" : \"127.0.0.1:45030\" , \"Enabled\" : false , \"Https\" : false }", "title": "Using WebApiShard"}, {"location": "shards/web-api/using-webapishard/#add-webapiservice-to-the-forge", "text": "To add the shard to the forge, the IForgeBuilder extension UseApi has to be called, passing optional options to further configure the service 1 public static IForgeBuilder UseApi ( this IForgeBuilder forgeBuilder , Action < WebApiOptions >? options = null )", "title": "Add WebApiService to the forge"}, {"location": "shards/web-api/using-webapishard/#webapioptions", "text": "WebApiOptions class allows to customize the discovery process that's responsible to find and register Web API controllers end include them into a specific ApiServiceDefinition . The discovery process happens during WebApiShard initialization: it generates an ApplicationPart for each registered shard that will include all discovered MithrilControllerBase (ControllerBase) types defined in the shard assembly.", "title": "WebApiOptions"}, {"location": "shards/web-api/using-webapishard/#controllersseeker", "text": "Sometimes you may have a project that just holds Controllers but isn't exposed as a shard, in this scenario you can use WebApiOptions during the call of UseApi, to explicitly add an assembly to inspect for controllers. The example project makes use of this when it builds the forge: 1 2 3 4 5 /// we are injecting ExampleDev type to allow <see cref=\"WebApi.WebApiShard\"/> to find all the controllers /// defined there because only controllers defined in an included shard assemblies are discovered automatically. /// Passing ExampleDev will cause dotnet runtime to load the assembly where ExampleDev Type is defined and every /// controllers defined there will be found later during <see cref=\"WebApi.WebApiShard\"/> initialization. . UseApi ( options => options . ControllersSeeker = ( seeker ) => seeker . LoadAssemblyFromType < ExampleDev >()) By doing this WebApiOptions will create an Application part for each explicitly added assembly and all Controller types defined in that assembly will be found and added to the available controllers in their specific area.", "title": "ControllersSeeker"}, {"location": "shards/web-api/using-webapishard/#enablepublicapi", "text": "This settings enables or disables the public API area . The public area corresponds to the ApiServiceDefinition that's responsible to enable all controllers assigned to the area WebApiArea.AREA_API . If you are creating an application where a public area is never needed, you may want to use this property rather than relying on external configuration file that may be missing or edited.", "title": "EnablePublicApi"}, {"location": "shards/web-api/using-webapishard/#publicapidescription", "text": "This settings allow to customize the description used to describe public API . Defaults to Mithril Shards public API .", "title": "PublicApiDescription"}, {"location": "shards/web-api/using-webapishard/#title", "text": "Configures the Swagger UI page title, useful for branding. Defaults to Mithril Shards Web API .", "title": "Title"}, {"location": "shards/web-api/using-webapishard/#webapisettings", "text": "WebApiSettings is the class that holds configuration settings required by the shard to works. It contains few properties to configure the endpoint used to listen to API requests and its behavior: Property Type Description Default EndPoint string IP address and port number on which the shard will serve its Web API endpoint, in the form of ip_address:port . \"127.0.0.1:45020\" Https bool Whether WEB API should be exposed on HTTPS. false Enabled bool Whether WebApiShard is enabled or not. Disabling it would cause any shard depending on WebApiShard, such as custom controllers or custom areas, to be unable to be served. true Configuration properties can be set in the application configuration file, within its root section, under the name of WebApi Note every shard configuration section is mapped by default to the name of the configuration setting class, stripping out the Settings part example: 1 2 3 4 5 \"WebApi\" : { \"EndPoint\" : \"127.0.0.1:45030\" , \"Enabled\" : false , \"Https\" : false }", "title": "WebApiSettings"}]}